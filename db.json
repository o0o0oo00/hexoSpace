{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-matery-1.0.1/source/favicon.png","path":"favicon.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/css/gitment.css","path":"css/gitment.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/css/my.css","path":"css/my.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/css/matery.css","path":"css/matery.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/js/matery.js","path":"js/matery.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/star.png","path":"medias/star.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/avatar.jpg","path":"medias/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/cover.jpg","path":"medias/cover.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/22.jpg","path":"medias/featureimages/22.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/23.jpg","path":"medias/featureimages/23.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/jquery/jquery-2.2.0.min.js","path":"libs/jquery/jquery-2.2.0.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/19.jpg","path":"medias/featureimages/19.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/21.jpg","path":"medias/featureimages/21.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/awesome/css/font-awesome.min.css","path":"libs/awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/awesome/fonts/fontawesome-webfont.woff","path":"libs/awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/awesome/fonts/fontawesome-webfont.woff2","path":"libs/awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/material-design-icons/LICENSE.txt","path":"libs/materialize/font/material-design-icons/LICENSE.txt","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/material-design-icons/Material-Design-Icons.woff2","path":"libs/materialize/font/material-design-icons/Material-Design-Icons.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Bold.eot","path":"libs/materialize/font/roboto/Roboto-Bold.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Medium.eot","path":"libs/materialize/font/roboto/Roboto-Medium.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Regular.eot","path":"libs/materialize/font/roboto/Roboto-Regular.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Medium.woff","path":"libs/materialize/font/roboto/Roboto-Medium.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Thin.eot","path":"libs/materialize/font/roboto/Roboto-Thin.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Thin.woff2","path":"libs/materialize/font/roboto/Roboto-Thin.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Thin.woff","path":"libs/materialize/font/roboto/Roboto-Thin.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/awesome/fonts/fontawesome-webfont.ttf","path":"libs/awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/material-design-icons/Material-Design-Icons.ttf","path":"libs/materialize/font/material-design-icons/Material-Design-Icons.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/material-design-icons/Material-Design-Icons.woff","path":"libs/materialize/font/material-design-icons/Material-Design-Icons.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Bold.woff","path":"libs/materialize/font/roboto/Roboto-Bold.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Bold.woff2","path":"libs/materialize/font/roboto/Roboto-Bold.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Light.eot","path":"libs/materialize/font/roboto/Roboto-Light.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Light.woff","path":"libs/materialize/font/roboto/Roboto-Light.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Light.woff2","path":"libs/materialize/font/roboto/Roboto-Light.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Medium.ttf","path":"libs/materialize/font/roboto/Roboto-Medium.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Medium.woff2","path":"libs/materialize/font/roboto/Roboto-Medium.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Regular.woff","path":"libs/materialize/font/roboto/Roboto-Regular.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Regular.woff2","path":"libs/materialize/font/roboto/Roboto-Regular.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/js/materialize.min.js","path":"libs/materialize/js/materialize.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/css/materialize.min.css","path":"libs/materialize/css/materialize.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/awesome/fonts/FontAwesome.otf","path":"libs/awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/material-design-icons/Material-Design-Icons.eot","path":"libs/materialize/font/material-design-icons/Material-Design-Icons.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Bold.ttf","path":"libs/materialize/font/roboto/Roboto-Bold.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Light.ttf","path":"libs/materialize/font/roboto/Roboto-Light.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/awesome/fonts/fontawesome-webfont.eot","path":"libs/awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Regular.ttf","path":"libs/materialize/font/roboto/Roboto-Regular.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Thin.ttf","path":"libs/materialize/font/roboto/Roboto-Thin.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/awesome/fonts/fontawesome-webfont.svg","path":"libs/awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/material-design-icons/Material-Design-Icons.svg","path":"libs/materialize/font/material-design-icons/Material-Design-Icons.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"bf1a7f878555a5fc5d015599b3997a5f0b70372c","modified":1551346098198},{"_id":"themes/hexo-theme-matery-1.0.1/.DS_Store","hash":"597632c6bc817a3a48dd9118f35c6886d8c906f5","modified":1551345933351},{"_id":"themes/hexo-theme-matery-1.0.1/README.md","hash":"9a63ad948c0db34aa4789a82c8f843c8bd9f8fa5","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/LICENSE","hash":"7df059597099bb7dcf25d2a9aedfaf4465f72d8d","modified":1550616946000},{"_id":"source/_posts/English.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551262839659},{"_id":"themes/hexo-theme-matery-1.0.1/README_CN.md","hash":"a59bd7f914c41deee3aed87276309a0c755e76ac","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/_config.yml","hash":"7aa1227aa43a37213a4d1e254e42063ccf0ae03d","modified":1551345428727},{"_id":"source/_data/friends.json","hash":"7e8c373bf32099b9ae82580644f201cab8c4213a","modified":1551342186617},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1551344894877},{"_id":"source/_posts/1022.md","hash":"3e509c533a7df18a3fad675f2e5587f57843806f","modified":1551344691906},{"_id":"source/_posts/2018-9-21-秋高气爽.md","hash":"a5da9dfbd243676aeee04846d262b6e155607d60","modified":1551344710050},{"_id":"source/_posts/AndroidProblem.md","hash":"160fa57791f526653d7acab600984e3662a0c12b","modified":1551344770239},{"_id":"source/_posts/Cold Observable.md","hash":"c36d882faf6f4db8070bffef9c47704bd9b31887","modified":1550659104521},{"_id":"source/_posts/Kodein .md","hash":"97cdee7c0eb64738152d979efc8b391ecdebe36f","modified":1551262813657},{"_id":"source/_posts/Navigation.md","hash":"d7361068243bdc4e5707fc9b5a857ea8c56d8398","modified":1551344895152},{"_id":"source/_posts/Observer.md","hash":"6681c56e15a18990eb0333e89aa9d5272ba5c6fa","modified":1551344918911},{"_id":"source/_posts/Personal-introduction.md","hash":"0a00176d03aaec21a2188096be25aef3804e8468","modified":1538556288000},{"_id":"source/_posts/alert.md","hash":"2717ce101084b80413db242e5b9f3df3c329c36a","modified":1551344761233},{"_id":"source/_posts/annotation.md","hash":"28f42a388f362dd7a3d6360c501f2ac21abae40d","modified":1551346023183},{"_id":"source/_posts/dagger.md","hash":"128577125e324d889c8eaa413363c48357cbbdba","modified":1551169700877},{"_id":"source/_posts/blog.md","hash":"0ef66d96784398b22adfe47879508485ddded6ee","modified":1551346124217},{"_id":"source/_posts/databinding.md","hash":"54a434d78cdf1f322cbb9a44cc03a704ec36f526","modified":1551344806707},{"_id":"source/_posts/decoration.md","hash":"5d9a8836db534e457454051ae738c772a5954a48","modified":1551344814679},{"_id":"source/_posts/eventbus.md","hash":"e10f08eda6987f5c661f8b70a2e0648849fe0988","modified":1551344831179},{"_id":"source/_posts/fancyDialog.md","hash":"b46f1e8a71ed8706660da8a15ae765eb51c9ece1","modified":1551347774806},{"_id":"source/_posts/fx.md","hash":"2b1cf0b506cda791a7768755e74808e7a4c08f34","modified":1551344852398},{"_id":"source/_posts/hello-world.md","hash":"a559a6fc510985d4b6a40d76ced723cc6c995889","modified":1551346110047},{"_id":"source/_posts/reflection.md","hash":"240c5b5ef7d8ffe712f55fd4b841647565c960a9","modified":1551344942903},{"_id":"source/_posts/jetpack.md","hash":"ef11dc0da639db2f5d137d387c9b1ab9502efa84","modified":1551344868797},{"_id":"source/_posts/rxScheduler.md","hash":"1cd8af1fdc874a941300a4e7a15676e961a50cba","modified":1551344975932},{"_id":"source/_posts/twitter.md","hash":"e0065177b3de341e4c18c9736d8752278384ce33","modified":1551344985436},{"_id":"source/_posts/rxoperator.md","hash":"9136f9bf7a2777dabcf42812b0d52764d5624681","modified":1551344965688},{"_id":"source/_posts/rx.md","hash":"ec69e03731f85903e4e157044f71c371d4da3b01","modified":1551344954767},{"_id":"source/_posts/仿写RHine 所需要积累的知识点.md","hash":"485633a98524f6a4dfd0a1d8fb3b1ffb354051c0","modified":1550659099030},{"_id":"source/_posts/名人名言.md","hash":"40e18745236b6fa3d1642965e17ec98a1bf9146e","modified":1550141888799},{"_id":"source/_posts/天气好好.md","hash":"904724eb242f31ff1fec9f6733ec35dd3b8f4d82","modified":1551344732125},{"_id":"source/_posts/小雨.md","hash":"a788618be4ffea2d5823c835553584186375cbd0","modified":1551344738117},{"_id":"source/_posts/有风冷了.md","hash":"7e34714764c794736e8286f3afe133b09734929f","modified":1551344743391},{"_id":"source/about/index.md","hash":"fbb5a2c4d17622ddeea5448e7e1cfadda30b1196","modified":1551333798736},{"_id":"source/categories/index.md","hash":"0d5e17af1d98968d0bd7c620582da0f3d9436a05","modified":1551333412656},{"_id":"source/categories/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1551333437417},{"_id":"source/tags/index.md","hash":"a8f80336c83163fbc1e2772977b233ff687561b8","modified":1551333816951},{"_id":"source/friends/index.md","hash":"24d27d6ded6f90b8aa850234192c25f2aef9e241","modified":1551333601179},{"_id":"themes/hexo-theme-matery-1.0.1/layout/about.ejs","hash":"ee639d0310867976b3e5fb9f92c215a17a433703","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/archive.ejs","hash":"c8459660e87a0a07a6e007a99a2303b142bb7744","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/categories.ejs","hash":"8e54665cc25d7c333da7d9f312987190be6215da","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/category.ejs","hash":"95176564ea32e65ddc9fdbe9074332239d6a1305","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/friends.ejs","hash":"89c47cf1eb2cf1feb8a8d06f4eb7c76b713f79c0","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/layout.ejs","hash":"bcc7b119496f0049862d3a53467aa7e5829219b0","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/tag.ejs","hash":"ad1cc11ac2b99bd803276b28ae57340cdd5810c8","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/post.ejs","hash":"f9662a96d0f497a3b2731472b8ad871c7cbdf13a","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/index.ejs","hash":"0332a899bb76cd974dd26c8847837ff3f69e4569","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/tags.ejs","hash":"cf9517aa6a0111355121f44615d6923e312283c7","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/languages/zh-CN.yml","hash":"978718ecafe858d5a2357e72e12daea3326c26fa","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/languages/default.yml","hash":"9d8609d0213ca88c48b0a4dbcbc4ca2effdda1d7","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/.DS_Store","hash":"76b667408fa7d6a8fca08657ac7994f3b61411e5","modified":1551345587863},{"_id":"themes/hexo-theme-matery-1.0.1/source/favicon.png","hash":"20674c497b75fc889194b47fd18ecea12303d8ec","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_widget/category-cloud.ejs","hash":"a5a10d6fa66a389d0253d7a52e0a646af6e8e9be","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_widget/dream.ejs","hash":"684450f0b42f89ab70370c5248b34e55b7adf6fc","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_widget/music.ejs","hash":"8eafddbd73fed80e85c66d49837c1a241b087258","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_widget/category-radar.ejs","hash":"f5561dd7d53d68897a33090bf677719213459b19","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_widget/my-gallery.ejs","hash":"f81eb2891bea326908057029e2a063001371ba9b","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_widget/my-projects.ejs","hash":"b9bf70ec5d97b0e14bb1b4f60f92db7680be5949","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_widget/post-calendar.ejs","hash":"0b0a3eb6af29bf0d55d535958c44b01c0f18d10d","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_widget/my-skills.ejs","hash":"bd0edf8dad95b2255890d59fb6d6ed6f2eab9c2f","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_widget/post-charts.ejs","hash":"af0604623db37ef800bb7ad48028d18d99efbbc3","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_widget/recommend.ejs","hash":"babaa0cb32146870785449c70748721235e4eff0","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_widget/tag-wordcloud.ejs","hash":"cb7a0151cd20e90351e151c22bca9d4c3112f234","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_widget/tag-cloud.ejs","hash":"a3725f0e3a405acb595b04630a27765b537fb580","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_widget/video.ejs","hash":"bda810cc135b52f834f1c1ccf52defccacace714","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_partial/bg-cover.ejs","hash":"ce7c5798a1af534f99c1efa66ab4edba1f520ea8","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_partial/footer.ejs","hash":"e8fa64db1c0210e3fac372637691f940d63a1ff4","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_partial/back-top.ejs","hash":"8c91d2088c9bb323246b054d4940bde6cead6828","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_partial/disqus.ejs","hash":"a0f53d1a9b579d52e52ccad8c6e330bf3b89547e","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_partial/gitalk.ejs","hash":"e4c5bf28ddc29519eee8debe79cce45bf279adeb","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_partial/head.ejs","hash":"5ad8cc2b4077b26c58d5da94d631b62089fbab26","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_partial/gitment.ejs","hash":"0abfb51dc80ad063fb2118bee28de6bb8d99ed4e","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_partial/github-link.ejs","hash":"3aeb581bd78ab8e15b858e4c44c03bcf92f20b9e","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_partial/google-analytics.ejs","hash":"5f4992205617da5f8cc5863c62b5ec46e414e2fb","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_partial/mobile-nav.ejs","hash":"f02c7f9654cfff38ae0a4814015820c2ab2ee526","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_partial/livere.ejs","hash":"9c3401b42ea7f26410a5593bae93ada7e57b43be","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_partial/header.ejs","hash":"3956916f8fff21e619619c0c518bd05be39a2f4f","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_partial/paging.ejs","hash":"68a24cad2b2049c4dc3a250aa30bf4256f9e50cb","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_partial/post-cover.ejs","hash":"202dfebd4ce1e2e647e0fcbf275b30820d16507c","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_partial/navigation.ejs","hash":"4a2dfc04ee0ee22ed2a097d04896143f7ef3b344","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_partial/post-detail-toc.ejs","hash":"b7320ccb822f9969c58401a0bc946a8a7a1fea9c","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_partial/post-detail.ejs","hash":"13cc4efb0cf29dc9879041da74d6bc8bf2695010","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_partial/post-statis.ejs","hash":"2b2fe8e8e94e65c52a4dbd454168e9b9df6baf10","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_partial/reward.ejs","hash":"d545c74f26ec321ba7e942d469f354eadd57e407","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_partial/search.ejs","hash":"c948aa82afc65f08f1c894b049d6899577536306","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_partial/prev-next.ejs","hash":"3f73f077b05b6bf41150b00f43870a41d3fa390f","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_partial/share.ejs","hash":"34f8e4250bb66012026aa50686a7c89a0414ca1b","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_partial/social-link.ejs","hash":"62e10bf4577946190e9c31dcdc2799a4ad1d00dd","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/layout/_partial/valine.ejs","hash":"90527186fc8ed906eb1f20b59bc7f86caab9087b","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/css/my.css","hash":"497e50351f7838f8546cac76850a42e7e380a110","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/css/matery.css","hash":"ca6c7ab8d1a23150361bd27889db6245ed03b5ed","modified":1551345710603},{"_id":"themes/hexo-theme-matery-1.0.1/source/js/matery.js","hash":"3eedb26fa1295f463aee179d4945eb650a1f441c","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/js/search.js","hash":"499e11786efbb04815b54a1de317cc8606a37555","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/.DS_Store","hash":"170ea15cda403a2d9c9eda07ad8fc3a6ef44410f","modified":1551345531824},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/star.png","hash":"6f11856b3653c1202688b96f19c96569fdf91686","modified":1551339788191},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/avatar.jpg","hash":"b2988a30d3473c5e4d7c0e01a2f431631b6d7198","modified":1551345495269},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/gitalk/gitalk.css","hash":"3aac1db83b0135c521187254ff302d125cc30706","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/tocbot/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/16.jpg","hash":"9cac6b80b0cc8959fc8aabfbd1adcab79ebebfc9","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/cover.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/2.jpg","hash":"16f1d89cdba4dce935ac0f12599e0fcfda543a93","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/22.jpg","hash":"bf5b59d193e5ca089a7fff034c222bfa2c4dc41f","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/23.jpg","hash":"ed5ac9f616d3b99af5188a10b1761884c37e93e5","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/5.jpg","hash":"c3c1f36a1b1886037db604f151f335cd4599e970","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/7.jpg","hash":"a0246a4a560438938489cdd154e35f172b3f31b0","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/8.jpg","hash":"5a46ca4ab4c4ab2101a2af77a31a8878bccc483c","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/reward/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1551338598036},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/jquery/jquery-2.2.0.min.js","hash":"5d7e5bbfa540f0e53bd599e4305e1a4e815b5dd1","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/valine/Valine.min.js","hash":"031c1a5640d64ab3b829395ad5a7596b9fb122e6","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/10.jpg","hash":"838e704942de076c60894d14e5f280e2724b6f68","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/1.jpg","hash":"d16e28bd23ea3a63643826dde5eea6b7a9bdda5d","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/0.jpg","hash":"2066cdda98ad0035071cd4aa7bd696eb078c0b6d","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/11.jpg","hash":"9ed45f95b83626e3d91d6c405eb8bfe6fcb9736a","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/13.jpg","hash":"66706dfde7d910182c2f1dbadd0e9e917630b8dd","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/14.jpg","hash":"8aeb816faca2d5eaea4cce9e881d6ff87b8c7cf1","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/15.jpg","hash":"5cf9fc64d5d74ab6ba69bb8bff580fdc22ba32d0","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/17.jpg","hash":"f168ca5b046d10a878a7b0bcfab540e2c4428887","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/18.jpg","hash":"ae23fdfaa59bc57b7ed49e90c5d59e4b68e1eea5","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/19.jpg","hash":"57bc7c804b78b5cceb4eb1f9e51b734b75151b71","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/20.jpg","hash":"8271c4a327632b566ea62f546c083d08a0528e72","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/21.jpg","hash":"d70b088850c3565e5b5bb9eb8fe4abe688c964cf","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/4.jpg","hash":"4eea5bdb5724ef1ed65790e481eda0d2fb176bf0","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/3.jpg","hash":"5e879652e032f02961a331b598a50b60ebe80a39","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/6.jpg","hash":"c63ff64bdd5f6c82da8804c7248fc519d23eaf0b","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/9.jpg","hash":"815c84778b721e3606c2bd7c099c7de7c53251ba","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/banner/0.jpg","hash":"1f2ec55fe7825475fde2601573bb622f0bf2acba","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/banner/2.jpg","hash":"8d3c8391ff161eec70f66d69e5545a9468cc52ef","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/lightGallery/fonts/lg.svg","hash":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/gitalk/gitalk.min.js","hash":"734f56442e62fe55f677e8ccae7f175445667767","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/share/fonts/iconfont.svg","hash":"f0a1b849868a6bf351ff98dc3924a4e7254eb88b","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/share/js/jquery.share.min.js","hash":"16ce82901ca0e302cf47a35fb10f59009a5e7eb9","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/share/js/social-share.min.js","hash":"4df722bafde2c5d8faaace0d1f894798385a8793","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/valine/av-min.js","hash":"2577e72b52b736d99649f9e95be8976d58563333","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/featureimages/12.jpg","hash":"047be4239dd7e0be83243ee6b49a392a61f16b9a","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/banner/3.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/banner/5.jpg","hash":"4a08deec1dd5b4f1490e8fc23adfb75a0f88b0c4","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/banner/6.jpg","hash":"62e9586a8cec91a160f147c424a3d1d1aea360f9","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/material-design-icons/LICENSE.txt","hash":"540e43aea993ada0c9b4b50ae5843494d8b7cc28","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/material-design-icons/Material-Design-Icons.woff2","hash":"2355cb4f824d070bc42c4ce6b97cab71af1f4ca2","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/banner/1.jpg","hash":"c3d5ab183b39a7140941b8375e29498f9d24f343","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/material-design-icons/Material-Design-Icons.ttf","hash":"2cb66ac73a2d32ae8d2f807f705eff26fcf93323","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/material-design-icons/Material-Design-Icons.woff","hash":"ee77184556f7b66fcb8ee9496f81ac62f792d7dc","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/js/materialize.min.js","hash":"900e478fb609e18a4f785164fc6f6b0442e8a94e","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/css/materialize.min.css","hash":"ca9b5271c307593264daad9753b962a0a8db1cef","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/material-design-icons/Material-Design-Icons.eot","hash":"fc1bc1337f3313ead42b22a67a142d4e0d356b3a","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/medias/banner/4.jpg","hash":"56850c3139cbd72a0eff0c35d8fac32c9c66dd6a","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/materialize/font/material-design-icons/Material-Design-Icons.svg","hash":"757d54367f0df16a783769eec0ba974f42bd7dce","modified":1550616946000},{"_id":"themes/hexo-theme-matery-1.0.1/source/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1550616946000}],"Category":[{"name":"Diary","_id":"cjsogf10700035l26hzmll07i"},{"name":"技术","_id":"cjsogf10k000d5l26zhhho7x3"},{"name":"hexo","_id":"cjsogf120001m5l26ay2wwaxe"}],"Data":[{"_id":"friends","data":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}],"Page":[{"title":"留言板","date":"2018-09-18T05:22:13.000Z","type":"about","layout":"about","comment":true,"_content":"","source":"about/index.md","raw":"---\ntitle: 留言板\ndate: 2018-09-18 13:22:13\ntype: \"about\"\nlayout: \"about\"\ncomment: true\n---\n","updated":"2019-02-28T06:03:18.736Z","path":"about/index.html","comments":1,"_id":"cjsogf11t00165l26ycqjibmo","content":"","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"categories","date":"2018-09-18T05:30:48.000Z","type":"categories","layout":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-09-18 13:30:48\ntype: \"categories\"\nlayout: \"categories\"\ncomments: false\n---\n","updated":"2019-02-28T05:56:52.656Z","path":"categories/index.html","_id":"cjsogf11u00185l2667rhnt6s","content":"","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"tags","date":"2018-09-17T08:17:08.000Z","type":"tags","layout":"tags","_content":"\n","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-09-17 16:17:08\ntype: \"tags\"\nlayout: \"tags\"\n---\n\n","updated":"2019-02-28T06:03:36.951Z","path":"tags/index.html","comments":1,"_id":"cjsogf11v001b5l26c6p98py7","content":"","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"好基友s","date":"2018-10-10T11:01:42.000Z","type":"friends","layout":"friends","_content":"\n<hr>\n\n\n\n* [Healejean的梦想博客](http://blog.healerjean.com/)\n\n### 欢迎互换友链，敬请留言，!~\n\n#### ~✽-(ˆ▽ˆ)/✽✽\\(ˆ▽ˆ)-✽ \n","source":"friends/index.md","raw":"---\ntitle:  好基友s\ndate: 2018-10-10 19:01:42\ntype: \"friends\"\nlayout: \"friends\"\n---\n\n<hr>\n\n\n\n* [Healejean的梦想博客](http://blog.healerjean.com/)\n\n### 欢迎互换友链，敬请留言，!~\n\n#### ~✽-(ˆ▽ˆ)/✽✽\\(ˆ▽ˆ)-✽ \n","updated":"2019-02-28T06:00:01.179Z","path":"friends/index.html","comments":1,"_id":"cjsogf11x001f5l26iwffucit","content":"<hr>\n\n\n\n<ul>\n<li><a href=\"http://blog.healerjean.com/\" target=\"_blank\" rel=\"noopener\">Healejean的梦想博客</a></li>\n</ul>\n<h3 id=\"欢迎互换友链，敬请留言，\"><a href=\"#欢迎互换友链，敬请留言，\" class=\"headerlink\" title=\"欢迎互换友链，敬请留言，!~\"></a>欢迎互换友链，敬请留言，!~</h3><h4 id=\"✽-ˆ▽ˆ-✽✽-ˆ▽ˆ-✽\"><a href=\"#✽-ˆ▽ˆ-✽✽-ˆ▽ˆ-✽\" class=\"headerlink\" title=\"~✽-(ˆ▽ˆ)/✽✽(ˆ▽ˆ)-✽\"></a>~✽-(ˆ▽ˆ)/✽✽(ˆ▽ˆ)-✽</h4>","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"","more":"<hr>\n\n\n\n<ul>\n<li><a href=\"http://blog.healerjean.com/\" target=\"_blank\" rel=\"noopener\">Healejean的梦想博客</a></li>\n</ul>\n<h3 id=\"欢迎互换友链，敬请留言，\"><a href=\"#欢迎互换友链，敬请留言，\" class=\"headerlink\" title=\"欢迎互换友链，敬请留言，!~\"></a>欢迎互换友链，敬请留言，!~</h3><h4 id=\"✽-ˆ▽ˆ-✽✽-ˆ▽ˆ-✽\"><a href=\"#✽-ˆ▽ˆ-✽✽-ˆ▽ˆ-✽\" class=\"headerlink\" title=\"~✽-(ˆ▽ˆ)/✽✽(ˆ▽ˆ)-✽\"></a>~✽-(ˆ▽ˆ)/✽✽(ˆ▽ˆ)-✽</h4>"}],"Post":[{"_content":"","source":"_posts/English.md","raw":"","slug":"English","published":1,"date":"2019-02-20T10:38:27.809Z","updated":"2019-02-27T10:20:39.659Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf0z800005l269r5hc0vi","content":"","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"2018-10-22 随笔","date":"2018-10-22T11:07:17.000Z","_content":"\n\n人与人的差距归根结底是阶级的差距，昨天舍友对我说了一句话“我们现在干的工作与在社会上乞讨的人有什么不同啊”。这句话虽然有点偏激了，但是不得不能说明一个问题，我们俩这样工作是整个社会最基层的工作，甚至可以衍生出给人打工的这一件事情上，终归是整个公司的最底层，也许有人可以做到小主管，小总监的位置，但是本质上还是为老板打工，只不过是相较于其手下的员工稍微搞一个小层级，但是任然摆脱不了处于社会金字塔的最底层。这样我就想问了，到底怎么样才能让自己的阶级上去一层呢？我们处于社会的最底层，和古代的奴隶制也没有什么分别，可能只不过是，现在的奴隶或者说员工可以选择自己“服侍”的地主而已。我们都知道北京人有钱，这一点不可否认，但是房子这东西是祖上留下来的，大清时候天子脚下，阶级当然不同于偏远的穷乡僻壤。就靠祖上留下的房子、地产就可以在这个社会上吃喝无忧，处于金字塔的中层，虽然同在一个星球上，但是不得不说中层和底层完全就是两个世界。\n","source":"_posts/1022.md","raw":"---\ntitle: 2018-10-22 随笔\ndate: 2018-10-22 19:07:17\ncategories: Diary\ntag : diary\n---\n\n\n人与人的差距归根结底是阶级的差距，昨天舍友对我说了一句话“我们现在干的工作与在社会上乞讨的人有什么不同啊”。这句话虽然有点偏激了，但是不得不能说明一个问题，我们俩这样工作是整个社会最基层的工作，甚至可以衍生出给人打工的这一件事情上，终归是整个公司的最底层，也许有人可以做到小主管，小总监的位置，但是本质上还是为老板打工，只不过是相较于其手下的员工稍微搞一个小层级，但是任然摆脱不了处于社会金字塔的最底层。这样我就想问了，到底怎么样才能让自己的阶级上去一层呢？我们处于社会的最底层，和古代的奴隶制也没有什么分别，可能只不过是，现在的奴隶或者说员工可以选择自己“服侍”的地主而已。我们都知道北京人有钱，这一点不可否认，但是房子这东西是祖上留下来的，大清时候天子脚下，阶级当然不同于偏远的穷乡僻壤。就靠祖上留下的房子、地产就可以在这个社会上吃喝无忧，处于金字塔的中层，虽然同在一个星球上，但是不得不说中层和底层完全就是两个世界。\n","slug":"1022","published":1,"updated":"2019-02-28T09:04:51.906Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf10300015l26ub8sahek","content":"<p>人与人的差距归根结底是阶级的差距，昨天舍友对我说了一句话“我们现在干的工作与在社会上乞讨的人有什么不同啊”。这句话虽然有点偏激了，但是不得不能说明一个问题，我们俩这样工作是整个社会最基层的工作，甚至可以衍生出给人打工的这一件事情上，终归是整个公司的最底层，也许有人可以做到小主管，小总监的位置，但是本质上还是为老板打工，只不过是相较于其手下的员工稍微搞一个小层级，但是任然摆脱不了处于社会金字塔的最底层。这样我就想问了，到底怎么样才能让自己的阶级上去一层呢？我们处于社会的最底层，和古代的奴隶制也没有什么分别，可能只不过是，现在的奴隶或者说员工可以选择自己“服侍”的地主而已。我们都知道北京人有钱，这一点不可否认，但是房子这东西是祖上留下来的，大清时候天子脚下，阶级当然不同于偏远的穷乡僻壤。就靠祖上留下的房子、地产就可以在这个社会上吃喝无忧，处于金字塔的中层，虽然同在一个星球上，但是不得不说中层和底层完全就是两个世界。</p>\n","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"","more":"<p>人与人的差距归根结底是阶级的差距，昨天舍友对我说了一句话“我们现在干的工作与在社会上乞讨的人有什么不同啊”。这句话虽然有点偏激了，但是不得不能说明一个问题，我们俩这样工作是整个社会最基层的工作，甚至可以衍生出给人打工的这一件事情上，终归是整个公司的最底层，也许有人可以做到小主管，小总监的位置，但是本质上还是为老板打工，只不过是相较于其手下的员工稍微搞一个小层级，但是任然摆脱不了处于社会金字塔的最底层。这样我就想问了，到底怎么样才能让自己的阶级上去一层呢？我们处于社会的最底层，和古代的奴隶制也没有什么分别，可能只不过是，现在的奴隶或者说员工可以选择自己“服侍”的地主而已。我们都知道北京人有钱，这一点不可否认，但是房子这东西是祖上留下来的，大清时候天子脚下，阶级当然不同于偏远的穷乡僻壤。就靠祖上留下的房子、地产就可以在这个社会上吃喝无忧，处于金字塔的中层，虽然同在一个星球上，但是不得不说中层和底层完全就是两个世界。</p>\n"},{"title":"2018.9.21 秋高气爽","date":"2018-09-21T02:53:02.000Z","_content":"<blockquote class=\"blockquote-center\">\n#### 你给别人的是善意，照亮的确实你自己\n</blockquote>\n","source":"_posts/2018-9-21-秋高气爽.md","raw":"---\ntitle: 2018.9.21 秋高气爽\ndate: 2018-09-21 10:53:02\ncategories: Diary\ntag: diary\n\n---\n<blockquote class=\"blockquote-center\">\n#### 你给别人的是善意，照亮的确实你自己\n</blockquote>\n","slug":"2018-9-21-秋高气爽","published":1,"updated":"2019-02-28T09:05:10.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf10500025l26dj0b4d3y","content":"<blockquote class=\"blockquote-center\"><br>#### 你给别人的是善意，照亮的确实你自己<br></blockquote>\n","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"","more":"<blockquote class=\"blockquote-center\"><br>#### 你给别人的是善意，照亮的确实你自己<br></blockquote>\n"},{"title":"Android疑难问题总结","date":"2019-01-03T08:46:29.000Z","_content":"\n### Android疑难问题总结\n***\n\n使用WindowManager的时候 我们在`removeView(view)`的时候 会事先判断`view.isAttachedToWindow`  而我遇到的问题是，我再`removeView(view)`之后再去判断`view.isAttachedToWindow` 其值仍然为**true** ,这就令我很是费解。  \n##### 解决方法：\n`windowManager.removeViewImmediate(view)`之后我们再去判断`view.isAttachedToWindow` 其值就变成了**false**\n\n***\n<!--more-->\n\n### 一个topActivity解决了多少问题\n\n很多时候再很多的情况下我们想要去操作我们的 **输入法显示或者隐藏** \n但是有时在`fragment` 或者 `dialog` 等情况下，普通的形式根本不生效。  \n这里我的处理方式是，在任情况下，都去调用`topActivity.hideSoft()`方法。\n而不是去`dialog.hideSoft()` 或者 `fragment.hideSoft()`\n\n持续更新...\n","source":"_posts/AndroidProblem.md","raw":"---\ntitle: Android疑难问题总结\ndate: 2019-01-03 16:46:29\ntags: android\ncategories : 技术\n---\n\n### Android疑难问题总结\n***\n\n使用WindowManager的时候 我们在`removeView(view)`的时候 会事先判断`view.isAttachedToWindow`  而我遇到的问题是，我再`removeView(view)`之后再去判断`view.isAttachedToWindow` 其值仍然为**true** ,这就令我很是费解。  \n##### 解决方法：\n`windowManager.removeViewImmediate(view)`之后我们再去判断`view.isAttachedToWindow` 其值就变成了**false**\n\n***\n<!--more-->\n\n### 一个topActivity解决了多少问题\n\n很多时候再很多的情况下我们想要去操作我们的 **输入法显示或者隐藏** \n但是有时在`fragment` 或者 `dialog` 等情况下，普通的形式根本不生效。  \n这里我的处理方式是，在任情况下，都去调用`topActivity.hideSoft()`方法。\n而不是去`dialog.hideSoft()` 或者 `fragment.hideSoft()`\n\n持续更新...\n","slug":"AndroidProblem","published":1,"updated":"2019-02-28T09:06:10.239Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf10a00055l265nh7sie1","content":"<h3 id=\"Android疑难问题总结\"><a href=\"#Android疑难问题总结\" class=\"headerlink\" title=\"Android疑难问题总结\"></a>Android疑难问题总结</h3><hr>\n<p>使用WindowManager的时候 我们在<code>removeView(view)</code>的时候 会事先判断<code>view.isAttachedToWindow</code>  而我遇到的问题是，我再<code>removeView(view)</code>之后再去判断<code>view.isAttachedToWindow</code> 其值仍然为<strong>true</strong> ,这就令我很是费解。  </p>\n<h5 id=\"解决方法：\"><a href=\"#解决方法：\" class=\"headerlink\" title=\"解决方法：\"></a>解决方法：</h5><p><code>windowManager.removeViewImmediate(view)</code>之后我们再去判断<code>view.isAttachedToWindow</code> 其值就变成了<strong>false</strong></p>\n<hr>\n<a id=\"more\"></a>\n<h3 id=\"一个topActivity解决了多少问题\"><a href=\"#一个topActivity解决了多少问题\" class=\"headerlink\" title=\"一个topActivity解决了多少问题\"></a>一个topActivity解决了多少问题</h3><p>很多时候再很多的情况下我们想要去操作我们的 <strong>输入法显示或者隐藏</strong><br>但是有时在<code>fragment</code> 或者 <code>dialog</code> 等情况下，普通的形式根本不生效。<br>这里我的处理方式是，在任情况下，都去调用<code>topActivity.hideSoft()</code>方法。<br>而不是去<code>dialog.hideSoft()</code> 或者 <code>fragment.hideSoft()</code></p>\n<p>持续更新…</p>\n","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"<h3 id=\"Android疑难问题总结\"><a href=\"#Android疑难问题总结\" class=\"headerlink\" title=\"Android疑难问题总结\"></a>Android疑难问题总结</h3><hr>\n<p>使用WindowManager的时候 我们在<code>removeView(view)</code>的时候 会事先判断<code>view.isAttachedToWindow</code>  而我遇到的问题是，我再<code>removeView(view)</code>之后再去判断<code>view.isAttachedToWindow</code> 其值仍然为<strong>true</strong> ,这就令我很是费解。  </p>\n<h5 id=\"解决方法：\"><a href=\"#解决方法：\" class=\"headerlink\" title=\"解决方法：\"></a>解决方法：</h5><p><code>windowManager.removeViewImmediate(view)</code>之后我们再去判断<code>view.isAttachedToWindow</code> 其值就变成了<strong>false</strong></p>\n<hr>","more":"<h3 id=\"一个topActivity解决了多少问题\"><a href=\"#一个topActivity解决了多少问题\" class=\"headerlink\" title=\"一个topActivity解决了多少问题\"></a>一个topActivity解决了多少问题</h3><p>很多时候再很多的情况下我们想要去操作我们的 <strong>输入法显示或者隐藏</strong><br>但是有时在<code>fragment</code> 或者 <code>dialog</code> 等情况下，普通的形式根本不生效。<br>这里我的处理方式是，在任情况下，都去调用<code>topActivity.hideSoft()</code>方法。<br>而不是去<code>dialog.hideSoft()</code> 或者 <code>fragment.hideSoft()</code></p>\n<p>持续更新…</p>"},{"_content":"RxJava tips\n\n## Cold Observable\n我们常见的工厂方法提供的都是ColdObservable,包括`just(),fromXX,create(),interval(),defer()`。 他们的共同点是当你有多个Subscriber的时候，他们的事件是独立的，就是说发给每个订阅者的时间都是新的，不共用且互不干扰。\n\n## Hot Observable\n\nHot Observable是共享数据的，订阅者在同一时刻收到相同的数据。\n\n## Observable.create\n\n* 返回的是**`ObservableCreate`** 对象\n* ObservableCreate本身就是Observable的子类，因此Observable.create()实际上就是创建并返回一个ObservableCreate对象\n* 在ObservableCreate的构造函数中，实际上是将create()方法中的参数ObservableOnSubscribe依赖注入ObservableCreate中并保存 **`this.source = source;`**\n* subscribeActual()方法是在Observable.subscribe()**订阅后**才执行的\n\n### 实现订阅\n\n\n","source":"_posts/Cold Observable.md","raw":"RxJava tips\n\n## Cold Observable\n我们常见的工厂方法提供的都是ColdObservable,包括`just(),fromXX,create(),interval(),defer()`。 他们的共同点是当你有多个Subscriber的时候，他们的事件是独立的，就是说发给每个订阅者的时间都是新的，不共用且互不干扰。\n\n## Hot Observable\n\nHot Observable是共享数据的，订阅者在同一时刻收到相同的数据。\n\n## Observable.create\n\n* 返回的是**`ObservableCreate`** 对象\n* ObservableCreate本身就是Observable的子类，因此Observable.create()实际上就是创建并返回一个ObservableCreate对象\n* 在ObservableCreate的构造函数中，实际上是将create()方法中的参数ObservableOnSubscribe依赖注入ObservableCreate中并保存 **`this.source = source;`**\n* subscribeActual()方法是在Observable.subscribe()**订阅后**才执行的\n\n### 实现订阅\n\n\n","slug":"Cold Observable","published":1,"date":"2019-02-20T10:38:24.521Z","updated":"2019-02-20T10:38:24.521Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf10c00065l26k40bd4bm","content":"<p>RxJava tips</p>\n<h2 id=\"Cold-Observable\"><a href=\"#Cold-Observable\" class=\"headerlink\" title=\"Cold Observable\"></a>Cold Observable</h2><p>我们常见的工厂方法提供的都是ColdObservable,包括<code>just(),fromXX,create(),interval(),defer()</code>。 他们的共同点是当你有多个Subscriber的时候，他们的事件是独立的，就是说发给每个订阅者的时间都是新的，不共用且互不干扰。</p>\n<h2 id=\"Hot-Observable\"><a href=\"#Hot-Observable\" class=\"headerlink\" title=\"Hot Observable\"></a>Hot Observable</h2><p>Hot Observable是共享数据的，订阅者在同一时刻收到相同的数据。</p>\n<h2 id=\"Observable-create\"><a href=\"#Observable-create\" class=\"headerlink\" title=\"Observable.create\"></a>Observable.create</h2><ul>\n<li>返回的是<strong><code>ObservableCreate</code></strong> 对象</li>\n<li>ObservableCreate本身就是Observable的子类，因此Observable.create()实际上就是创建并返回一个ObservableCreate对象</li>\n<li>在ObservableCreate的构造函数中，实际上是将create()方法中的参数ObservableOnSubscribe依赖注入ObservableCreate中并保存 <strong><code>this.source = source;</code></strong></li>\n<li>subscribeActual()方法是在Observable.subscribe()<strong>订阅后</strong>才执行的</li>\n</ul>\n<h3 id=\"实现订阅\"><a href=\"#实现订阅\" class=\"headerlink\" title=\"实现订阅\"></a>实现订阅</h3>","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"","more":"<p>RxJava tips</p>\n<h2 id=\"Cold-Observable\"><a href=\"#Cold-Observable\" class=\"headerlink\" title=\"Cold Observable\"></a>Cold Observable</h2><p>我们常见的工厂方法提供的都是ColdObservable,包括<code>just(),fromXX,create(),interval(),defer()</code>。 他们的共同点是当你有多个Subscriber的时候，他们的事件是独立的，就是说发给每个订阅者的时间都是新的，不共用且互不干扰。</p>\n<h2 id=\"Hot-Observable\"><a href=\"#Hot-Observable\" class=\"headerlink\" title=\"Hot Observable\"></a>Hot Observable</h2><p>Hot Observable是共享数据的，订阅者在同一时刻收到相同的数据。</p>\n<h2 id=\"Observable-create\"><a href=\"#Observable-create\" class=\"headerlink\" title=\"Observable.create\"></a>Observable.create</h2><ul>\n<li>返回的是<strong><code>ObservableCreate</code></strong> 对象</li>\n<li>ObservableCreate本身就是Observable的子类，因此Observable.create()实际上就是创建并返回一个ObservableCreate对象</li>\n<li>在ObservableCreate的构造函数中，实际上是将create()方法中的参数ObservableOnSubscribe依赖注入ObservableCreate中并保存 <strong><code>this.source = source;</code></strong></li>\n<li>subscribeActual()方法是在Observable.subscribe()<strong>订阅后</strong>才执行的</li>\n</ul>\n<h3 id=\"实现订阅\"><a href=\"#实现订阅\" class=\"headerlink\" title=\"实现订阅\"></a>实现订阅</h3>"},{"_content":"# Kodein \n\n## dependency\n```\ncompile 'org.kodein.di:kodein-di-generic-jvm:5.2.0'\ncompile 'org.kodein.di:kodein-di-framework-android-???:5.2.0'\n```\n其中这个问号根据项目的不同可以填写。我用的是AndroidX \n\nKodein offers support for:\n\nAndroid only\n\n> kodein-di-framework-android-core\n\nAndroid + Support library\n\n> kodein-di-framework-android-support\n\nAndroid + AndroidX library\n\n> kodein-di-framework-android-x\n\n","source":"_posts/Kodein .md","raw":"# Kodein \n\n## dependency\n```\ncompile 'org.kodein.di:kodein-di-generic-jvm:5.2.0'\ncompile 'org.kodein.di:kodein-di-framework-android-???:5.2.0'\n```\n其中这个问号根据项目的不同可以填写。我用的是AndroidX \n\nKodein offers support for:\n\nAndroid only\n\n> kodein-di-framework-android-core\n\nAndroid + Support library\n\n> kodein-di-framework-android-support\n\nAndroid + AndroidX library\n\n> kodein-di-framework-android-x\n\n","slug":"Kodein ","published":1,"date":"2019-02-27T10:20:13.657Z","updated":"2019-02-27T10:20:13.657Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf10e00075l26ggk4gntk","content":"<h1 id=\"Kodein\"><a href=\"#Kodein\" class=\"headerlink\" title=\"Kodein\"></a>Kodein</h1><h2 id=\"dependency\"><a href=\"#dependency\" class=\"headerlink\" title=\"dependency\"></a>dependency</h2><pre><code>compile &#39;org.kodein.di:kodein-di-generic-jvm:5.2.0&#39;\ncompile &#39;org.kodein.di:kodein-di-framework-android-???:5.2.0&#39;\n</code></pre><p>其中这个问号根据项目的不同可以填写。我用的是AndroidX </p>\n<p>Kodein offers support for:</p>\n<p>Android only</p>\n<blockquote>\n<p>kodein-di-framework-android-core</p>\n</blockquote>\n<p>Android + Support library</p>\n<blockquote>\n<p>kodein-di-framework-android-support</p>\n</blockquote>\n<p>Android + AndroidX library</p>\n<blockquote>\n<p>kodein-di-framework-android-x</p>\n</blockquote>\n","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"","more":"<h1 id=\"Kodein\"><a href=\"#Kodein\" class=\"headerlink\" title=\"Kodein\"></a>Kodein</h1><h2 id=\"dependency\"><a href=\"#dependency\" class=\"headerlink\" title=\"dependency\"></a>dependency</h2><pre><code>compile &#39;org.kodein.di:kodein-di-generic-jvm:5.2.0&#39;\ncompile &#39;org.kodein.di:kodein-di-framework-android-???:5.2.0&#39;\n</code></pre><p>其中这个问号根据项目的不同可以填写。我用的是AndroidX </p>\n<p>Kodein offers support for:</p>\n<p>Android only</p>\n<blockquote>\n<p>kodein-di-framework-android-core</p>\n</blockquote>\n<p>Android + Support library</p>\n<blockquote>\n<p>kodein-di-framework-android-support</p>\n</blockquote>\n<p>Android + AndroidX library</p>\n<blockquote>\n<p>kodein-di-framework-android-x</p>\n</blockquote>\n"},{"title":"Jetpack Navigation","date":"2019-02-13T07:28:38.000Z","_content":"\n### Navigation\n\n先介绍概念在举一个栗子\n\n#### 优势\n\n* 自动处理fragment transactions\n* 正确处理 **up** and **back**\n* 动画和过度的默认行为\n* Deep linking as a first class operation // 咋翻译啊？\n* 仅用少量代码实现 navigation UI patterns (like navigation drawers and bottom nav)\n* 导航时安全的传递信息\n* 在Android Studio中支持可视化编辑导航\n\n#### 主要由三部分组成\n\n**`NavGraphFragment`** 导航界面的容器，首先要展示一个fragment必须要有一个容器来承载它，之前可能是framelayout或者RelativeLayout 而现在换成了是 NavGraphFragment 这些个fragment都展示在NavGraphFragment上面\n\n* app:defaultNavHost=\"true\"这个属性意味着你的NavGraphFragment将会 拦截系统Back键的点击事件 \n* 同时 必须重写 Activity的 onSupportNavigateUp() 方法\n* \n```\noverride fun onSupportNavigateUp()\n        = findNavController(R.id.nav_host_fragment).navigateUp()\n```\n\n* app:navGraph=\"@navigation/nav_graph_main\"这个属性就很好理解了，它会指向一个navigation_graph的xml文件，NavGraphFragment就会 导航并展示对应的Fragment。\n\n**`Navigation Graph (New XML resource) `** 用于声明导航结构图，包含有fragment的动作，携带的参数等\n\n**`NavController (Kotlin/Java object)`** 发起动作，导航你想导航到的任何位置\n\n#### 获取NavController的三种方式：\n\n* Fragment.findNavController()\n* View.findNavController()\n* Activity.findNavController(viewId: Int)\n\n#### 导航时添加转场动画\n 这里面用的是DSL形式，得意~~\n\n```\nval options = navOptions {\n    anim {\n        enter = R.anim.slide_in_right\n        exit = R.anim.slide_out_left\n        popEnter = R.anim.slide_in_left\n        popExit = R.anim.slide_out_right\n    }\n}\nview.findViewById<Button>(R.id.navigate_destination_button)?.setOnClickListener {\n    findNavController().navigate(R.id.flow_step_one_dest, null, options)\n}\n```\n或者写在Action标签里面\n\n```\n<action android:id=\"@+id/next_action\"\n        app:destination=\"@+id/flow_step_one\"\n        app:enterAnim=\"@anim/slide_in_right\"\n        app:exitAnim=\"@anim/slide_out_left\"\n        app:popEnterAnim=\"@anim/slide_in_left\"\n        app:popExitAnim=\"@anim/slide_out_right\" />\n```\n\n#### 安全的获取参数\n\n在fragment标签下增加参数\n\n```\n<argument\n        android:name=\"flowStepNumber\"\n        app:argType=\"integer\"\n        android:defaultValue=\"1\"/>\n```\n\n相比于之前在fragment中获取参数的这种非类型安全（type safe）的形式\n\n```\nval username = arguments?.getString(\"usernameKey\")\n```\n\nNavigation提供了一种安全形式\n\n如果声明了argument 那么会自动生成一些代码供开发者使用\n\n```\nval safeArgs = FlowStepFragmentArgs.fromBundle(arguments)\nval flowStepNumber = safeArgs.flowStepNumber\n```\n\n","source":"_posts/Navigation.md","raw":"---\ntitle: Jetpack Navigation\ndate: 2019-02-13 15:28:38\ntags: jetpack\ncategories: 技术\n---\n\n### Navigation\n\n先介绍概念在举一个栗子\n\n#### 优势\n\n* 自动处理fragment transactions\n* 正确处理 **up** and **back**\n* 动画和过度的默认行为\n* Deep linking as a first class operation // 咋翻译啊？\n* 仅用少量代码实现 navigation UI patterns (like navigation drawers and bottom nav)\n* 导航时安全的传递信息\n* 在Android Studio中支持可视化编辑导航\n\n#### 主要由三部分组成\n\n**`NavGraphFragment`** 导航界面的容器，首先要展示一个fragment必须要有一个容器来承载它，之前可能是framelayout或者RelativeLayout 而现在换成了是 NavGraphFragment 这些个fragment都展示在NavGraphFragment上面\n\n* app:defaultNavHost=\"true\"这个属性意味着你的NavGraphFragment将会 拦截系统Back键的点击事件 \n* 同时 必须重写 Activity的 onSupportNavigateUp() 方法\n* \n```\noverride fun onSupportNavigateUp()\n        = findNavController(R.id.nav_host_fragment).navigateUp()\n```\n\n* app:navGraph=\"@navigation/nav_graph_main\"这个属性就很好理解了，它会指向一个navigation_graph的xml文件，NavGraphFragment就会 导航并展示对应的Fragment。\n\n**`Navigation Graph (New XML resource) `** 用于声明导航结构图，包含有fragment的动作，携带的参数等\n\n**`NavController (Kotlin/Java object)`** 发起动作，导航你想导航到的任何位置\n\n#### 获取NavController的三种方式：\n\n* Fragment.findNavController()\n* View.findNavController()\n* Activity.findNavController(viewId: Int)\n\n#### 导航时添加转场动画\n 这里面用的是DSL形式，得意~~\n\n```\nval options = navOptions {\n    anim {\n        enter = R.anim.slide_in_right\n        exit = R.anim.slide_out_left\n        popEnter = R.anim.slide_in_left\n        popExit = R.anim.slide_out_right\n    }\n}\nview.findViewById<Button>(R.id.navigate_destination_button)?.setOnClickListener {\n    findNavController().navigate(R.id.flow_step_one_dest, null, options)\n}\n```\n或者写在Action标签里面\n\n```\n<action android:id=\"@+id/next_action\"\n        app:destination=\"@+id/flow_step_one\"\n        app:enterAnim=\"@anim/slide_in_right\"\n        app:exitAnim=\"@anim/slide_out_left\"\n        app:popEnterAnim=\"@anim/slide_in_left\"\n        app:popExitAnim=\"@anim/slide_out_right\" />\n```\n\n#### 安全的获取参数\n\n在fragment标签下增加参数\n\n```\n<argument\n        android:name=\"flowStepNumber\"\n        app:argType=\"integer\"\n        android:defaultValue=\"1\"/>\n```\n\n相比于之前在fragment中获取参数的这种非类型安全（type safe）的形式\n\n```\nval username = arguments?.getString(\"usernameKey\")\n```\n\nNavigation提供了一种安全形式\n\n如果声明了argument 那么会自动生成一些代码供开发者使用\n\n```\nval safeArgs = FlowStepFragmentArgs.fromBundle(arguments)\nval flowStepNumber = safeArgs.flowStepNumber\n```\n\n","slug":"Navigation","published":1,"updated":"2019-02-28T09:08:15.152Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf10h000b5l26zu0zmzyw","content":"<h3 id=\"Navigation\"><a href=\"#Navigation\" class=\"headerlink\" title=\"Navigation\"></a>Navigation</h3><p>先介绍概念在举一个栗子</p>\n<h4 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h4><ul>\n<li>自动处理fragment transactions</li>\n<li>正确处理 <strong>up</strong> and <strong>back</strong></li>\n<li>动画和过度的默认行为</li>\n<li>Deep linking as a first class operation // 咋翻译啊？</li>\n<li>仅用少量代码实现 navigation UI patterns (like navigation drawers and bottom nav)</li>\n<li>导航时安全的传递信息</li>\n<li>在Android Studio中支持可视化编辑导航</li>\n</ul>\n<h4 id=\"主要由三部分组成\"><a href=\"#主要由三部分组成\" class=\"headerlink\" title=\"主要由三部分组成\"></a>主要由三部分组成</h4><p><strong><code>NavGraphFragment</code></strong> 导航界面的容器，首先要展示一个fragment必须要有一个容器来承载它，之前可能是framelayout或者RelativeLayout 而现在换成了是 NavGraphFragment 这些个fragment都展示在NavGraphFragment上面</p>\n<ul>\n<li>app:defaultNavHost=”true”这个属性意味着你的NavGraphFragment将会 拦截系统Back键的点击事件 </li>\n<li>同时 必须重写 Activity的 onSupportNavigateUp() 方法</li>\n<li><pre><code>override fun onSupportNavigateUp()\n      = findNavController(R.id.nav_host_fragment).navigateUp()\n</code></pre></li>\n<li><p>app:navGraph=”@navigation/nav_graph_main”这个属性就很好理解了，它会指向一个navigation_graph的xml文件，NavGraphFragment就会 导航并展示对应的Fragment。</p>\n</li>\n</ul>\n<p><strong><code>Navigation Graph (New XML resource)</code></strong> 用于声明导航结构图，包含有fragment的动作，携带的参数等</p>\n<p><strong><code>NavController (Kotlin/Java object)</code></strong> 发起动作，导航你想导航到的任何位置</p>\n<h4 id=\"获取NavController的三种方式：\"><a href=\"#获取NavController的三种方式：\" class=\"headerlink\" title=\"获取NavController的三种方式：\"></a>获取NavController的三种方式：</h4><ul>\n<li>Fragment.findNavController()</li>\n<li>View.findNavController()</li>\n<li>Activity.findNavController(viewId: Int)</li>\n</ul>\n<h4 id=\"导航时添加转场动画\"><a href=\"#导航时添加转场动画\" class=\"headerlink\" title=\"导航时添加转场动画\"></a>导航时添加转场动画</h4><p> 这里面用的是DSL形式，得意~~</p>\n<pre><code>val options = navOptions {\n    anim {\n        enter = R.anim.slide_in_right\n        exit = R.anim.slide_out_left\n        popEnter = R.anim.slide_in_left\n        popExit = R.anim.slide_out_right\n    }\n}\nview.findViewById&lt;Button&gt;(R.id.navigate_destination_button)?.setOnClickListener {\n    findNavController().navigate(R.id.flow_step_one_dest, null, options)\n}\n</code></pre><p>或者写在Action标签里面</p>\n<pre><code>&lt;action android:id=&quot;@+id/next_action&quot;\n        app:destination=&quot;@+id/flow_step_one&quot;\n        app:enterAnim=&quot;@anim/slide_in_right&quot;\n        app:exitAnim=&quot;@anim/slide_out_left&quot;\n        app:popEnterAnim=&quot;@anim/slide_in_left&quot;\n        app:popExitAnim=&quot;@anim/slide_out_right&quot; /&gt;\n</code></pre><h4 id=\"安全的获取参数\"><a href=\"#安全的获取参数\" class=\"headerlink\" title=\"安全的获取参数\"></a>安全的获取参数</h4><p>在fragment标签下增加参数</p>\n<pre><code>&lt;argument\n        android:name=&quot;flowStepNumber&quot;\n        app:argType=&quot;integer&quot;\n        android:defaultValue=&quot;1&quot;/&gt;\n</code></pre><p>相比于之前在fragment中获取参数的这种非类型安全（type safe）的形式</p>\n<pre><code>val username = arguments?.getString(&quot;usernameKey&quot;)\n</code></pre><p>Navigation提供了一种安全形式</p>\n<p>如果声明了argument 那么会自动生成一些代码供开发者使用</p>\n<pre><code>val safeArgs = FlowStepFragmentArgs.fromBundle(arguments)\nval flowStepNumber = safeArgs.flowStepNumber\n</code></pre>","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"","more":"<h3 id=\"Navigation\"><a href=\"#Navigation\" class=\"headerlink\" title=\"Navigation\"></a>Navigation</h3><p>先介绍概念在举一个栗子</p>\n<h4 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h4><ul>\n<li>自动处理fragment transactions</li>\n<li>正确处理 <strong>up</strong> and <strong>back</strong></li>\n<li>动画和过度的默认行为</li>\n<li>Deep linking as a first class operation // 咋翻译啊？</li>\n<li>仅用少量代码实现 navigation UI patterns (like navigation drawers and bottom nav)</li>\n<li>导航时安全的传递信息</li>\n<li>在Android Studio中支持可视化编辑导航</li>\n</ul>\n<h4 id=\"主要由三部分组成\"><a href=\"#主要由三部分组成\" class=\"headerlink\" title=\"主要由三部分组成\"></a>主要由三部分组成</h4><p><strong><code>NavGraphFragment</code></strong> 导航界面的容器，首先要展示一个fragment必须要有一个容器来承载它，之前可能是framelayout或者RelativeLayout 而现在换成了是 NavGraphFragment 这些个fragment都展示在NavGraphFragment上面</p>\n<ul>\n<li>app:defaultNavHost=”true”这个属性意味着你的NavGraphFragment将会 拦截系统Back键的点击事件 </li>\n<li>同时 必须重写 Activity的 onSupportNavigateUp() 方法</li>\n<li><pre><code>override fun onSupportNavigateUp()\n      = findNavController(R.id.nav_host_fragment).navigateUp()\n</code></pre></li>\n<li><p>app:navGraph=”@navigation/nav_graph_main”这个属性就很好理解了，它会指向一个navigation_graph的xml文件，NavGraphFragment就会 导航并展示对应的Fragment。</p>\n</li>\n</ul>\n<p><strong><code>Navigation Graph (New XML resource)</code></strong> 用于声明导航结构图，包含有fragment的动作，携带的参数等</p>\n<p><strong><code>NavController (Kotlin/Java object)</code></strong> 发起动作，导航你想导航到的任何位置</p>\n<h4 id=\"获取NavController的三种方式：\"><a href=\"#获取NavController的三种方式：\" class=\"headerlink\" title=\"获取NavController的三种方式：\"></a>获取NavController的三种方式：</h4><ul>\n<li>Fragment.findNavController()</li>\n<li>View.findNavController()</li>\n<li>Activity.findNavController(viewId: Int)</li>\n</ul>\n<h4 id=\"导航时添加转场动画\"><a href=\"#导航时添加转场动画\" class=\"headerlink\" title=\"导航时添加转场动画\"></a>导航时添加转场动画</h4><p> 这里面用的是DSL形式，得意~~</p>\n<pre><code>val options = navOptions {\n    anim {\n        enter = R.anim.slide_in_right\n        exit = R.anim.slide_out_left\n        popEnter = R.anim.slide_in_left\n        popExit = R.anim.slide_out_right\n    }\n}\nview.findViewById&lt;Button&gt;(R.id.navigate_destination_button)?.setOnClickListener {\n    findNavController().navigate(R.id.flow_step_one_dest, null, options)\n}\n</code></pre><p>或者写在Action标签里面</p>\n<pre><code>&lt;action android:id=&quot;@+id/next_action&quot;\n        app:destination=&quot;@+id/flow_step_one&quot;\n        app:enterAnim=&quot;@anim/slide_in_right&quot;\n        app:exitAnim=&quot;@anim/slide_out_left&quot;\n        app:popEnterAnim=&quot;@anim/slide_in_left&quot;\n        app:popExitAnim=&quot;@anim/slide_out_right&quot; /&gt;\n</code></pre><h4 id=\"安全的获取参数\"><a href=\"#安全的获取参数\" class=\"headerlink\" title=\"安全的获取参数\"></a>安全的获取参数</h4><p>在fragment标签下增加参数</p>\n<pre><code>&lt;argument\n        android:name=&quot;flowStepNumber&quot;\n        app:argType=&quot;integer&quot;\n        android:defaultValue=&quot;1&quot;/&gt;\n</code></pre><p>相比于之前在fragment中获取参数的这种非类型安全（type safe）的形式</p>\n<pre><code>val username = arguments?.getString(&quot;usernameKey&quot;)\n</code></pre><p>Navigation提供了一种安全形式</p>\n<p>如果声明了argument 那么会自动生成一些代码供开发者使用</p>\n<pre><code>val safeArgs = FlowStepFragmentArgs.fromBundle(arguments)\nval flowStepNumber = safeArgs.flowStepNumber\n</code></pre>"},{"title":"观察者模式简述","date":"2018-10-09T09:33:19.000Z","_content":"### 观察者模式简述\n点击查看理论知识…（⊙＿⊙；）…\n<details>\n观察者模式是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。\n观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。\n**观察者模式所涉及的角色有**  \n**抽象主题角色：**抽象主题角色吧所有对观察者对象的引用保存在一个聚集里面。每个主题都可以有任何数量的观察者。抽象主题提供一个借口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者（Observable）角色。  \n**具体主题角色**：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。  \n**抽象观察者：**为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。  \n**具体观察者：**存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态 像协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。  \n</details>\n<!--more-->\n#### 简易的例子\n上面的全都是理论，读起来绕嘴都 。。。\n\n1. 创建观察者\n2. 创建被观察者\n3. 被观察者的状态改变，进而通知观察者改变状态。所以，被观察者里面有一个装有所有观察者的集合，被观察者状态改变的时候，遍历被观察者所拥有的这个集合，通知（调用）观察者中的更新状态方法。\n\n```\n/**\n* @author:       zhaochunyu\n* @description:  被观察者的抽象\n* @date:         2018/10/9\n*/\nabstract class Subject {\nprivate val list = mutableListOf<MyObserver>()\n\n\nfun attach(observer: MyObserver) {\nlist.add(observer)\nprintln(\"Attached an observer\")\n}\n\nfun detach(observer: MyObserver) {\nlist.remove(observer)\nprintln(\"detach an observer\")\n}\n\nfun notifyObservers(newState: String) {\nlist.forEach {\nit.update(newState)\n}\n}\n\n}\n```\n```\n/**\n* @author:       zhaochunyu\n* @description:  实际被观察者\n* @date:         2018/10/9\n*/\nclass ActualSubject : Subject() {\n\nfun change(newString: String) {\nprintln(\"被观察者的状态改变为：\" + newString)\nnotifyObservers(newString)\n}\n}\n```\n\n```\n/**\n* @author:       zhaochunyu\n* @description:  观察者的抽象\n* @date:         2018/10/9\n*/\ninterface MyObserver {\n\nfun update(newState: String)\n\n}\n```\n```\n/**\n* @author:       zhaochunyu\n* @description:  观察者\n* @date:         2018/10/9\n*/\nclass ActualObserver : MyObserver {\n\noverride fun update(newState: String) {\nprintln(\"观察者状态改变为：\"+ newState)\n}\n}\n```\n我们得到在创建了实际观察者与实际被观察者对象之后，进行Attach(也就是将观察者注册到被观察者的集合中)，然后改变被观察者状态。验证观察者更新状态。\n\n```\nclass MainActivity : AppCompatActivity() {\n\noverride fun onCreate(savedInstanceState: Bundle?) {\nsuper.onCreate(savedInstanceState)\nsetContentView(R.layout.activity_main)\n\nval actualSubject = ActualSubject()\nval actualObserver = ActualObserver()\n// 注册\nactualSubject.attach(actualObserver)\n\nactualSubject.change(\"new state\")\n\n}\n}\n```\n#### 推模型VS拉模型\n<details>\n在观察者模式中，又分为推模型和拉模型两种方式。  \n**推模型**  \n主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。  \n**拉模型**  \n主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。  \n**两种模式的比较**  \n　　■　　推模型是假定主题对象知道观察者需要的数据；而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。\n　　■　　推模型可能会使得观察者对象难以复用，因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者；而拉模型就不会造成这样的情况，因为拉模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。\n</details>\n实际就是传一个具体的类型，例如String,还是传入一个被观察者对象的区别。方便使用吧o((⊙﹏⊙))o.\n","source":"_posts/Observer.md","raw":"---\ntitle: 观察者模式简述\ndate: 2018-10-09 17:33:19\ncategories: 技术\ntag: kotlin\n---\n### 观察者模式简述\n点击查看理论知识…（⊙＿⊙；）…\n<details>\n观察者模式是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。\n观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。\n**观察者模式所涉及的角色有**  \n**抽象主题角色：**抽象主题角色吧所有对观察者对象的引用保存在一个聚集里面。每个主题都可以有任何数量的观察者。抽象主题提供一个借口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者（Observable）角色。  \n**具体主题角色**：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。  \n**抽象观察者：**为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。  \n**具体观察者：**存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态 像协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。  \n</details>\n<!--more-->\n#### 简易的例子\n上面的全都是理论，读起来绕嘴都 。。。\n\n1. 创建观察者\n2. 创建被观察者\n3. 被观察者的状态改变，进而通知观察者改变状态。所以，被观察者里面有一个装有所有观察者的集合，被观察者状态改变的时候，遍历被观察者所拥有的这个集合，通知（调用）观察者中的更新状态方法。\n\n```\n/**\n* @author:       zhaochunyu\n* @description:  被观察者的抽象\n* @date:         2018/10/9\n*/\nabstract class Subject {\nprivate val list = mutableListOf<MyObserver>()\n\n\nfun attach(observer: MyObserver) {\nlist.add(observer)\nprintln(\"Attached an observer\")\n}\n\nfun detach(observer: MyObserver) {\nlist.remove(observer)\nprintln(\"detach an observer\")\n}\n\nfun notifyObservers(newState: String) {\nlist.forEach {\nit.update(newState)\n}\n}\n\n}\n```\n```\n/**\n* @author:       zhaochunyu\n* @description:  实际被观察者\n* @date:         2018/10/9\n*/\nclass ActualSubject : Subject() {\n\nfun change(newString: String) {\nprintln(\"被观察者的状态改变为：\" + newString)\nnotifyObservers(newString)\n}\n}\n```\n\n```\n/**\n* @author:       zhaochunyu\n* @description:  观察者的抽象\n* @date:         2018/10/9\n*/\ninterface MyObserver {\n\nfun update(newState: String)\n\n}\n```\n```\n/**\n* @author:       zhaochunyu\n* @description:  观察者\n* @date:         2018/10/9\n*/\nclass ActualObserver : MyObserver {\n\noverride fun update(newState: String) {\nprintln(\"观察者状态改变为：\"+ newState)\n}\n}\n```\n我们得到在创建了实际观察者与实际被观察者对象之后，进行Attach(也就是将观察者注册到被观察者的集合中)，然后改变被观察者状态。验证观察者更新状态。\n\n```\nclass MainActivity : AppCompatActivity() {\n\noverride fun onCreate(savedInstanceState: Bundle?) {\nsuper.onCreate(savedInstanceState)\nsetContentView(R.layout.activity_main)\n\nval actualSubject = ActualSubject()\nval actualObserver = ActualObserver()\n// 注册\nactualSubject.attach(actualObserver)\n\nactualSubject.change(\"new state\")\n\n}\n}\n```\n#### 推模型VS拉模型\n<details>\n在观察者模式中，又分为推模型和拉模型两种方式。  \n**推模型**  \n主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。  \n**拉模型**  \n主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。  \n**两种模式的比较**  \n　　■　　推模型是假定主题对象知道观察者需要的数据；而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。\n　　■　　推模型可能会使得观察者对象难以复用，因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者；而拉模型就不会造成这样的情况，因为拉模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。\n</details>\n实际就是传一个具体的类型，例如String,还是传入一个被观察者对象的区别。方便使用吧o((⊙﹏⊙))o.\n","slug":"Observer","published":1,"updated":"2019-02-28T09:08:38.911Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf10j000c5l26eg054d1m","content":"<h3 id=\"观察者模式简述\"><a href=\"#观察者模式简述\" class=\"headerlink\" title=\"观察者模式简述\"></a>观察者模式简述</h3><p>点击查看理论知识…（⊙＿⊙；）…</p>\n<p><details><br>观察者模式是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。<br>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。<br><strong>观察者模式所涉及的角色有</strong><br><strong>抽象主题角色：</strong>抽象主题角色吧所有对观察者对象的引用保存在一个聚集里面。每个主题都可以有任何数量的观察者。抽象主题提供一个借口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者（Observable）角色。<br><strong>具体主题角色</strong>：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。<br><strong>抽象观察者：</strong>为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。<br><strong>具体观察者：</strong>存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态 像协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。<br></details><br><a id=\"more\"></a></p>\n<h4 id=\"简易的例子\"><a href=\"#简易的例子\" class=\"headerlink\" title=\"简易的例子\"></a>简易的例子</h4><p>上面的全都是理论，读起来绕嘴都 。。。</p>\n<ol>\n<li>创建观察者</li>\n<li>创建被观察者</li>\n<li>被观察者的状态改变，进而通知观察者改变状态。所以，被观察者里面有一个装有所有观察者的集合，被观察者状态改变的时候，遍历被观察者所拥有的这个集合，通知（调用）观察者中的更新状态方法。</li>\n</ol>\n<pre><code>/**\n* @author:       zhaochunyu\n* @description:  被观察者的抽象\n* @date:         2018/10/9\n*/\nabstract class Subject {\nprivate val list = mutableListOf&lt;MyObserver&gt;()\n\n\nfun attach(observer: MyObserver) {\nlist.add(observer)\nprintln(&quot;Attached an observer&quot;)\n}\n\nfun detach(observer: MyObserver) {\nlist.remove(observer)\nprintln(&quot;detach an observer&quot;)\n}\n\nfun notifyObservers(newState: String) {\nlist.forEach {\nit.update(newState)\n}\n}\n\n}\n</code></pre><pre><code>/**\n* @author:       zhaochunyu\n* @description:  实际被观察者\n* @date:         2018/10/9\n*/\nclass ActualSubject : Subject() {\n\nfun change(newString: String) {\nprintln(&quot;被观察者的状态改变为：&quot; + newString)\nnotifyObservers(newString)\n}\n}\n</code></pre><pre><code>/**\n* @author:       zhaochunyu\n* @description:  观察者的抽象\n* @date:         2018/10/9\n*/\ninterface MyObserver {\n\nfun update(newState: String)\n\n}\n</code></pre><pre><code>/**\n* @author:       zhaochunyu\n* @description:  观察者\n* @date:         2018/10/9\n*/\nclass ActualObserver : MyObserver {\n\noverride fun update(newState: String) {\nprintln(&quot;观察者状态改变为：&quot;+ newState)\n}\n}\n</code></pre><p>我们得到在创建了实际观察者与实际被观察者对象之后，进行Attach(也就是将观察者注册到被观察者的集合中)，然后改变被观察者状态。验证观察者更新状态。</p>\n<pre><code>class MainActivity : AppCompatActivity() {\n\noverride fun onCreate(savedInstanceState: Bundle?) {\nsuper.onCreate(savedInstanceState)\nsetContentView(R.layout.activity_main)\n\nval actualSubject = ActualSubject()\nval actualObserver = ActualObserver()\n// 注册\nactualSubject.attach(actualObserver)\n\nactualSubject.change(&quot;new state&quot;)\n\n}\n}\n</code></pre><h4 id=\"推模型VS拉模型\"><a href=\"#推模型VS拉模型\" class=\"headerlink\" title=\"推模型VS拉模型\"></a>推模型VS拉模型</h4><p><details><br>在观察者模式中，又分为推模型和拉模型两种方式。<br><strong>推模型</strong><br>主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。<br><strong>拉模型</strong><br>主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。<br><strong>两种模式的比较</strong><br>　　■　　推模型是假定主题对象知道观察者需要的数据；而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。<br>　　■　　推模型可能会使得观察者对象难以复用，因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者；而拉模型就不会造成这样的情况，因为拉模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。<br></details><br>实际就是传一个具体的类型，例如String,还是传入一个被观察者对象的区别。方便使用吧o((⊙﹏⊙))o.</p>\n","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"<h3 id=\"观察者模式简述\"><a href=\"#观察者模式简述\" class=\"headerlink\" title=\"观察者模式简述\"></a>观察者模式简述</h3><p>点击查看理论知识…（⊙＿⊙；）…</p>\n<p><details><br>观察者模式是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。<br>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。<br><strong>观察者模式所涉及的角色有</strong><br><strong>抽象主题角色：</strong>抽象主题角色吧所有对观察者对象的引用保存在一个聚集里面。每个主题都可以有任何数量的观察者。抽象主题提供一个借口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者（Observable）角色。<br><strong>具体主题角色</strong>：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。<br><strong>抽象观察者：</strong>为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。<br><strong>具体观察者：</strong>存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态 像协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。<br></details><br>","more":"</p>\n<h4 id=\"简易的例子\"><a href=\"#简易的例子\" class=\"headerlink\" title=\"简易的例子\"></a>简易的例子</h4><p>上面的全都是理论，读起来绕嘴都 。。。</p>\n<ol>\n<li>创建观察者</li>\n<li>创建被观察者</li>\n<li>被观察者的状态改变，进而通知观察者改变状态。所以，被观察者里面有一个装有所有观察者的集合，被观察者状态改变的时候，遍历被观察者所拥有的这个集合，通知（调用）观察者中的更新状态方法。</li>\n</ol>\n<pre><code>/**\n* @author:       zhaochunyu\n* @description:  被观察者的抽象\n* @date:         2018/10/9\n*/\nabstract class Subject {\nprivate val list = mutableListOf&lt;MyObserver&gt;()\n\n\nfun attach(observer: MyObserver) {\nlist.add(observer)\nprintln(&quot;Attached an observer&quot;)\n}\n\nfun detach(observer: MyObserver) {\nlist.remove(observer)\nprintln(&quot;detach an observer&quot;)\n}\n\nfun notifyObservers(newState: String) {\nlist.forEach {\nit.update(newState)\n}\n}\n\n}\n</code></pre><pre><code>/**\n* @author:       zhaochunyu\n* @description:  实际被观察者\n* @date:         2018/10/9\n*/\nclass ActualSubject : Subject() {\n\nfun change(newString: String) {\nprintln(&quot;被观察者的状态改变为：&quot; + newString)\nnotifyObservers(newString)\n}\n}\n</code></pre><pre><code>/**\n* @author:       zhaochunyu\n* @description:  观察者的抽象\n* @date:         2018/10/9\n*/\ninterface MyObserver {\n\nfun update(newState: String)\n\n}\n</code></pre><pre><code>/**\n* @author:       zhaochunyu\n* @description:  观察者\n* @date:         2018/10/9\n*/\nclass ActualObserver : MyObserver {\n\noverride fun update(newState: String) {\nprintln(&quot;观察者状态改变为：&quot;+ newState)\n}\n}\n</code></pre><p>我们得到在创建了实际观察者与实际被观察者对象之后，进行Attach(也就是将观察者注册到被观察者的集合中)，然后改变被观察者状态。验证观察者更新状态。</p>\n<pre><code>class MainActivity : AppCompatActivity() {\n\noverride fun onCreate(savedInstanceState: Bundle?) {\nsuper.onCreate(savedInstanceState)\nsetContentView(R.layout.activity_main)\n\nval actualSubject = ActualSubject()\nval actualObserver = ActualObserver()\n// 注册\nactualSubject.attach(actualObserver)\n\nactualSubject.change(&quot;new state&quot;)\n\n}\n}\n</code></pre><h4 id=\"推模型VS拉模型\"><a href=\"#推模型VS拉模型\" class=\"headerlink\" title=\"推模型VS拉模型\"></a>推模型VS拉模型</h4><p><details><br>在观察者模式中，又分为推模型和拉模型两种方式。<br><strong>推模型</strong><br>主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。<br><strong>拉模型</strong><br>主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。<br><strong>两种模式的比较</strong><br>　　■　　推模型是假定主题对象知道观察者需要的数据；而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。<br>　　■　　推模型可能会使得观察者对象难以复用，因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者；而拉模型就不会造成这样的情况，因为拉模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。<br></details><br>实际就是传一个具体的类型，例如String,还是传入一个被观察者对象的区别。方便使用吧o((⊙﹏⊙))o.</p>"},{"title":"Personal introduction","date":"2018-10-03T08:43:09.000Z","_content":"想要写点什么，但是不知道写点什么，反正就随便写点什么。\n<!--more-->\n就从我是一个什么样的人介绍开始吧，我出生于1994年，到2018年就是24周岁，今年是我再北京的第二个年头，没取得什么成就，反正就是勉强度日。\n我这个人性格善良，还有emmm。。。\n\n好了\n","source":"_posts/Personal-introduction.md","raw":"---\ntitle: Personal introduction\ndate: 2018-10-03 16:43:09\ncategories: Diary\n---\n想要写点什么，但是不知道写点什么，反正就随便写点什么。\n<!--more-->\n就从我是一个什么样的人介绍开始吧，我出生于1994年，到2018年就是24周岁，今年是我再北京的第二个年头，没取得什么成就，反正就是勉强度日。\n我这个人性格善良，还有emmm。。。\n\n好了\n","slug":"Personal-introduction","published":1,"updated":"2018-10-03T08:44:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf10l000h5l26thn3rp5u","content":"<p>想要写点什么，但是不知道写点什么，反正就随便写点什么。<br><a id=\"more\"></a><br>就从我是一个什么样的人介绍开始吧，我出生于1994年，到2018年就是24周岁，今年是我再北京的第二个年头，没取得什么成就，反正就是勉强度日。<br>我这个人性格善良，还有emmm。。。</p>\n<p>好了</p>\n","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"<p>想要写点什么，但是不知道写点什么，反正就随便写点什么。<br>","more":"<br>就从我是一个什么样的人介绍开始吧，我出生于1994年，到2018年就是24周岁，今年是我再北京的第二个年头，没取得什么成就，反正就是勉强度日。<br>我这个人性格善良，还有emmm。。。</p>\n<p>好了</p>"},{"title":"Android上的弹窗及其层级关系协调","date":"2018-12-21T07:25:19.000Z","_content":"\n## Alert弹窗 的一种解决方案\n需求：在屏幕的最上方弹出一个横条Alert（警告框） 居于StateBar（状态栏）之下\n\n初始的解决方案是直接修改系统的Toast，可以通过反射字段来达到Toast可以交互的目的。但是在Android8.0以上的手机，Toast 的Animation被固定为了淡入淡出，不可以是上滑下滑的动画效果，所以PASS。  \n\nAndroid上的**Alert**（警告）弹窗，**本质上**就是一个**View**。 既然是一个View那么我们完全可以自定义与它的交互效果。  \n\n下面说几种我想到的解决方案\n<!--more-->\n### 1. 普通Alerta\n此时只有Activity一个Window，所以不存在层级之间的覆盖关系。  \n直接在**Activity的DecorView上添加AlertView**\n\n### 2. Activity中存在Dialog的时候\n如果用上面的方法的话，会出现一个问题，Dialog的阴影把我们的Alert弹窗覆盖上了，针对这个问题我们分析一下   \n\n由于Dialog所属的Window层级为System级别，所以显示优先级高于Activity的Window层级Application\n\n### 3. 直男解决办法\n经过观察发现，可以通过`dialog.window.decorView`来获取到dialog的DecorView，那么我们是不是可以将我们的AlertView添加到这个decorView之上呢？\n事实证明是可以的，不过Dialog的Window大小需要调整，此时就遇到了另一个问题。如何将Dialog全屏，以便于Alert可以显示在屏幕的最上方。\n\n下面粘贴了关键代码（详见`BaseFullScreenDialog`） + XML布局 双match_parent\n\n```\nwindow?.requestFeature(Window.FEATURE_NO_TITLE)\nwindow?.setLayout(WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.MATCH_PARENT)\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n    window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS)\n}\n\ndialog = newDialog()// 创建出dialog对象\ndialog.setContentView(view, ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))\ndialog.window.setBackgroundDrawableResource(android.R.color.transparent)\n```\n这样Dialog全屏的时候我们的Alert果然就显示在了屏幕的最上方！\n\n不过 **又双叒叕** 引申出另一个问题，如果Dialog中存在输入框，需要弹出输入法，我们知道，默认的dialog在输入法弹出的时候会自动被推上去一段距离，可是我们的dialog已经全屏了啊，此时我又写了一个通用扩展方法`dialog.pushDialogAboveSoftInput(root, content)`其中计算了输入法高度以及NavigationBar高度，来将Dialog xml布局中的**内容view**手动的推上去一段距离。这才勉强算是完成了需求。擦汗...... \n\n又双叒叕引申出一些关于NavigationBar的坑就不太好处理了\n\n### 4 奇技淫巧解决办法\n我们回归问题的原始，又回到最初的起点......   \n\n是因为dialog的阴影挡住了我们的Alert所以才要将Alert添加到Dialog的Window上去。那么我们可不可以将Dialog的阴影去掉，换成改变Activity的透明度。岂不是绕过了上面的所有问题。☆´∀｀☆\n\n首先应该设置dialog弹出时候背景不变黑\n\n```\n dialog.window.setDimAmount(0F)\n```\n\n分别在dialog的show 和 dismiss方法中去改变Activity的透明度。\n\n```\n// 黑暗 0.0F ~ 1.0F 透明\nfun Context.setBackgroundAlpha(alpha: Float) {\n    val act = this as? Activity ?: return\n    val attributes = act.window.attributes\n    attributes.alpha = alpha\n    act.window.attributes = attributes\n}\n```\n这样就把问题控制在了AlertView的层级上了，只需要配合WindowManager，就可以实现Alert不会被背景阴影挡住了。\n\n### 5. WindowManager 设置Alert层级\n(╥﹏╥...) \n  \n我们知道Window的显示是有层级顺序的，层级高的覆盖在层级低的Window之上。  \nActivity的层级为 `TYPE_APPLICATION`\nPopupWindow的层级为`TYPE_APPLICATION_PANEL`\n而我们只需要添加一个层级为`TYPE_APPLICATION_SUB_PANEL`的View到Window上面即可\n\n> These windows are displayed on top their attached window and any{@link #TYPE_APPLICATION_PANEL} panels.\n\n关于层级顺序详见SDK WindowManager.java\n\n**注!!!**  \n使用WindowManager如果是在**层级为2000`FIRST_SYSTEM_WINDOW`**以下的是**不需要**申请弹窗权限的。\n\n而这种创建出来的Window是依附于Activity的，如果界面被销毁，或者还没有初始化就去使用WindowManager来`addView`或者`removeView`会报异常`view not attached to window`\n\n针对这个问题，做如下控制\n\n```\nif ((act as? Activity)?.isFinishing == true) {\n    return\n}\n\nwindowManager.addView(root, layoutParams)\n```\n```\nHandler().postDelayed({\n    if (root.isAttachedToWindow && act?.isFinishing != true) {\n        windowManager.removeView(root)\n    }\n}, DURATION_ANIM)\n\n```\n以及关联Application 的 `registerActivityLifecycleCallbacks`生命周期\n\n```\noverride fun onActivityDestroyed(activity: Activity?) {\n    if (root.isAttachedToWindow) {\n        windowManager.removeView(root)\n    }\n}\n```\n\n### 6 特殊问题\n在one plus 的 9.0 系统上面 windowManager添加顶部Alert会**被statebar遮挡一部分**  \n\n解决办法：给WindowManager.LayoutParams添加如下FLAG\n\n```\nlayoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or // 不获取焦点，以便于在弹出的时候 下层界面仍然可以进行操作\n        WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN or\n        WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR // 确保你的内容不会被装饰物(如状态栏)掩盖.\n\n```\n\n### 干脆Dialog都不用了直接用PopupWindow\n我们知道popWindow是与Activity共用同一个Window的，这一点上来讲，非常好控制，配合WindowManager 完全可以实现需求。\n\n[代码](https://github.com/o0o0oo00/NewToast)","source":"_posts/alert.md","raw":"---\ntitle: Android上的弹窗及其层级关系协调\ndate: 2018-12-21 15:25:19\ntags: alert\ncategories: 技术\n---\n\n## Alert弹窗 的一种解决方案\n需求：在屏幕的最上方弹出一个横条Alert（警告框） 居于StateBar（状态栏）之下\n\n初始的解决方案是直接修改系统的Toast，可以通过反射字段来达到Toast可以交互的目的。但是在Android8.0以上的手机，Toast 的Animation被固定为了淡入淡出，不可以是上滑下滑的动画效果，所以PASS。  \n\nAndroid上的**Alert**（警告）弹窗，**本质上**就是一个**View**。 既然是一个View那么我们完全可以自定义与它的交互效果。  \n\n下面说几种我想到的解决方案\n<!--more-->\n### 1. 普通Alerta\n此时只有Activity一个Window，所以不存在层级之间的覆盖关系。  \n直接在**Activity的DecorView上添加AlertView**\n\n### 2. Activity中存在Dialog的时候\n如果用上面的方法的话，会出现一个问题，Dialog的阴影把我们的Alert弹窗覆盖上了，针对这个问题我们分析一下   \n\n由于Dialog所属的Window层级为System级别，所以显示优先级高于Activity的Window层级Application\n\n### 3. 直男解决办法\n经过观察发现，可以通过`dialog.window.decorView`来获取到dialog的DecorView，那么我们是不是可以将我们的AlertView添加到这个decorView之上呢？\n事实证明是可以的，不过Dialog的Window大小需要调整，此时就遇到了另一个问题。如何将Dialog全屏，以便于Alert可以显示在屏幕的最上方。\n\n下面粘贴了关键代码（详见`BaseFullScreenDialog`） + XML布局 双match_parent\n\n```\nwindow?.requestFeature(Window.FEATURE_NO_TITLE)\nwindow?.setLayout(WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.MATCH_PARENT)\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n    window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS)\n}\n\ndialog = newDialog()// 创建出dialog对象\ndialog.setContentView(view, ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))\ndialog.window.setBackgroundDrawableResource(android.R.color.transparent)\n```\n这样Dialog全屏的时候我们的Alert果然就显示在了屏幕的最上方！\n\n不过 **又双叒叕** 引申出另一个问题，如果Dialog中存在输入框，需要弹出输入法，我们知道，默认的dialog在输入法弹出的时候会自动被推上去一段距离，可是我们的dialog已经全屏了啊，此时我又写了一个通用扩展方法`dialog.pushDialogAboveSoftInput(root, content)`其中计算了输入法高度以及NavigationBar高度，来将Dialog xml布局中的**内容view**手动的推上去一段距离。这才勉强算是完成了需求。擦汗...... \n\n又双叒叕引申出一些关于NavigationBar的坑就不太好处理了\n\n### 4 奇技淫巧解决办法\n我们回归问题的原始，又回到最初的起点......   \n\n是因为dialog的阴影挡住了我们的Alert所以才要将Alert添加到Dialog的Window上去。那么我们可不可以将Dialog的阴影去掉，换成改变Activity的透明度。岂不是绕过了上面的所有问题。☆´∀｀☆\n\n首先应该设置dialog弹出时候背景不变黑\n\n```\n dialog.window.setDimAmount(0F)\n```\n\n分别在dialog的show 和 dismiss方法中去改变Activity的透明度。\n\n```\n// 黑暗 0.0F ~ 1.0F 透明\nfun Context.setBackgroundAlpha(alpha: Float) {\n    val act = this as? Activity ?: return\n    val attributes = act.window.attributes\n    attributes.alpha = alpha\n    act.window.attributes = attributes\n}\n```\n这样就把问题控制在了AlertView的层级上了，只需要配合WindowManager，就可以实现Alert不会被背景阴影挡住了。\n\n### 5. WindowManager 设置Alert层级\n(╥﹏╥...) \n  \n我们知道Window的显示是有层级顺序的，层级高的覆盖在层级低的Window之上。  \nActivity的层级为 `TYPE_APPLICATION`\nPopupWindow的层级为`TYPE_APPLICATION_PANEL`\n而我们只需要添加一个层级为`TYPE_APPLICATION_SUB_PANEL`的View到Window上面即可\n\n> These windows are displayed on top their attached window and any{@link #TYPE_APPLICATION_PANEL} panels.\n\n关于层级顺序详见SDK WindowManager.java\n\n**注!!!**  \n使用WindowManager如果是在**层级为2000`FIRST_SYSTEM_WINDOW`**以下的是**不需要**申请弹窗权限的。\n\n而这种创建出来的Window是依附于Activity的，如果界面被销毁，或者还没有初始化就去使用WindowManager来`addView`或者`removeView`会报异常`view not attached to window`\n\n针对这个问题，做如下控制\n\n```\nif ((act as? Activity)?.isFinishing == true) {\n    return\n}\n\nwindowManager.addView(root, layoutParams)\n```\n```\nHandler().postDelayed({\n    if (root.isAttachedToWindow && act?.isFinishing != true) {\n        windowManager.removeView(root)\n    }\n}, DURATION_ANIM)\n\n```\n以及关联Application 的 `registerActivityLifecycleCallbacks`生命周期\n\n```\noverride fun onActivityDestroyed(activity: Activity?) {\n    if (root.isAttachedToWindow) {\n        windowManager.removeView(root)\n    }\n}\n```\n\n### 6 特殊问题\n在one plus 的 9.0 系统上面 windowManager添加顶部Alert会**被statebar遮挡一部分**  \n\n解决办法：给WindowManager.LayoutParams添加如下FLAG\n\n```\nlayoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or // 不获取焦点，以便于在弹出的时候 下层界面仍然可以进行操作\n        WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN or\n        WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR // 确保你的内容不会被装饰物(如状态栏)掩盖.\n\n```\n\n### 干脆Dialog都不用了直接用PopupWindow\n我们知道popWindow是与Activity共用同一个Window的，这一点上来讲，非常好控制，配合WindowManager 完全可以实现需求。\n\n[代码](https://github.com/o0o0oo00/NewToast)","slug":"alert","published":1,"updated":"2019-02-28T09:06:01.233Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf10p000i5l26x5v5byut","content":"<h2 id=\"Alert弹窗-的一种解决方案\"><a href=\"#Alert弹窗-的一种解决方案\" class=\"headerlink\" title=\"Alert弹窗 的一种解决方案\"></a>Alert弹窗 的一种解决方案</h2><p>需求：在屏幕的最上方弹出一个横条Alert（警告框） 居于StateBar（状态栏）之下</p>\n<p>初始的解决方案是直接修改系统的Toast，可以通过反射字段来达到Toast可以交互的目的。但是在Android8.0以上的手机，Toast 的Animation被固定为了淡入淡出，不可以是上滑下滑的动画效果，所以PASS。  </p>\n<p>Android上的<strong>Alert</strong>（警告）弹窗，<strong>本质上</strong>就是一个<strong>View</strong>。 既然是一个View那么我们完全可以自定义与它的交互效果。  </p>\n<p>下面说几种我想到的解决方案<br><a id=\"more\"></a></p>\n<h3 id=\"1-普通Alerta\"><a href=\"#1-普通Alerta\" class=\"headerlink\" title=\"1. 普通Alerta\"></a>1. 普通Alerta</h3><p>此时只有Activity一个Window，所以不存在层级之间的覆盖关系。<br>直接在<strong>Activity的DecorView上添加AlertView</strong></p>\n<h3 id=\"2-Activity中存在Dialog的时候\"><a href=\"#2-Activity中存在Dialog的时候\" class=\"headerlink\" title=\"2. Activity中存在Dialog的时候\"></a>2. Activity中存在Dialog的时候</h3><p>如果用上面的方法的话，会出现一个问题，Dialog的阴影把我们的Alert弹窗覆盖上了，针对这个问题我们分析一下   </p>\n<p>由于Dialog所属的Window层级为System级别，所以显示优先级高于Activity的Window层级Application</p>\n<h3 id=\"3-直男解决办法\"><a href=\"#3-直男解决办法\" class=\"headerlink\" title=\"3. 直男解决办法\"></a>3. 直男解决办法</h3><p>经过观察发现，可以通过<code>dialog.window.decorView</code>来获取到dialog的DecorView，那么我们是不是可以将我们的AlertView添加到这个decorView之上呢？<br>事实证明是可以的，不过Dialog的Window大小需要调整，此时就遇到了另一个问题。如何将Dialog全屏，以便于Alert可以显示在屏幕的最上方。</p>\n<p>下面粘贴了关键代码（详见<code>BaseFullScreenDialog</code>） + XML布局 双match_parent</p>\n<pre><code>window?.requestFeature(Window.FEATURE_NO_TITLE)\nwindow?.setLayout(WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.MATCH_PARENT)\nif (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {\n    window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS)\n}\n\ndialog = newDialog()// 创建出dialog对象\ndialog.setContentView(view, ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))\ndialog.window.setBackgroundDrawableResource(android.R.color.transparent)\n</code></pre><p>这样Dialog全屏的时候我们的Alert果然就显示在了屏幕的最上方！</p>\n<p>不过 <strong>又双叒叕</strong> 引申出另一个问题，如果Dialog中存在输入框，需要弹出输入法，我们知道，默认的dialog在输入法弹出的时候会自动被推上去一段距离，可是我们的dialog已经全屏了啊，此时我又写了一个通用扩展方法<code>dialog.pushDialogAboveSoftInput(root, content)</code>其中计算了输入法高度以及NavigationBar高度，来将Dialog xml布局中的<strong>内容view</strong>手动的推上去一段距离。这才勉强算是完成了需求。擦汗…… </p>\n<p>又双叒叕引申出一些关于NavigationBar的坑就不太好处理了</p>\n<h3 id=\"4-奇技淫巧解决办法\"><a href=\"#4-奇技淫巧解决办法\" class=\"headerlink\" title=\"4 奇技淫巧解决办法\"></a>4 奇技淫巧解决办法</h3><p>我们回归问题的原始，又回到最初的起点……   </p>\n<p>是因为dialog的阴影挡住了我们的Alert所以才要将Alert添加到Dialog的Window上去。那么我们可不可以将Dialog的阴影去掉，换成改变Activity的透明度。岂不是绕过了上面的所有问题。☆´∀｀☆</p>\n<p>首先应该设置dialog弹出时候背景不变黑</p>\n<pre><code> dialog.window.setDimAmount(0F)\n</code></pre><p>分别在dialog的show 和 dismiss方法中去改变Activity的透明度。</p>\n<pre><code>// 黑暗 0.0F ~ 1.0F 透明\nfun Context.setBackgroundAlpha(alpha: Float) {\n    val act = this as? Activity ?: return\n    val attributes = act.window.attributes\n    attributes.alpha = alpha\n    act.window.attributes = attributes\n}\n</code></pre><p>这样就把问题控制在了AlertView的层级上了，只需要配合WindowManager，就可以实现Alert不会被背景阴影挡住了。</p>\n<h3 id=\"5-WindowManager-设置Alert层级\"><a href=\"#5-WindowManager-设置Alert层级\" class=\"headerlink\" title=\"5. WindowManager 设置Alert层级\"></a>5. WindowManager 设置Alert层级</h3><p>(╥﹏╥…) </p>\n<p>我们知道Window的显示是有层级顺序的，层级高的覆盖在层级低的Window之上。<br>Activity的层级为 <code>TYPE_APPLICATION</code><br>PopupWindow的层级为<code>TYPE_APPLICATION_PANEL</code><br>而我们只需要添加一个层级为<code>TYPE_APPLICATION_SUB_PANEL</code>的View到Window上面即可</p>\n<blockquote>\n<p>These windows are displayed on top their attached window and any{@link #TYPE_APPLICATION_PANEL} panels.</p>\n</blockquote>\n<p>关于层级顺序详见SDK WindowManager.java</p>\n<p><strong>注!!!</strong><br>使用WindowManager如果是在<strong>层级为2000<code>FIRST_SYSTEM_WINDOW</code></strong>以下的是<strong>不需要</strong>申请弹窗权限的。</p>\n<p>而这种创建出来的Window是依附于Activity的，如果界面被销毁，或者还没有初始化就去使用WindowManager来<code>addView</code>或者<code>removeView</code>会报异常<code>view not attached to window</code></p>\n<p>针对这个问题，做如下控制</p>\n<pre><code>if ((act as? Activity)?.isFinishing == true) {\n    return\n}\n\nwindowManager.addView(root, layoutParams)\n</code></pre><pre><code>Handler().postDelayed({\n    if (root.isAttachedToWindow &amp;&amp; act?.isFinishing != true) {\n        windowManager.removeView(root)\n    }\n}, DURATION_ANIM)\n\n</code></pre><p>以及关联Application 的 <code>registerActivityLifecycleCallbacks</code>生命周期</p>\n<pre><code>override fun onActivityDestroyed(activity: Activity?) {\n    if (root.isAttachedToWindow) {\n        windowManager.removeView(root)\n    }\n}\n</code></pre><h3 id=\"6-特殊问题\"><a href=\"#6-特殊问题\" class=\"headerlink\" title=\"6 特殊问题\"></a>6 特殊问题</h3><p>在one plus 的 9.0 系统上面 windowManager添加顶部Alert会<strong>被statebar遮挡一部分</strong>  </p>\n<p>解决办法：给WindowManager.LayoutParams添加如下FLAG</p>\n<pre><code>layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or // 不获取焦点，以便于在弹出的时候 下层界面仍然可以进行操作\n        WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN or\n        WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR // 确保你的内容不会被装饰物(如状态栏)掩盖.\n\n</code></pre><h3 id=\"干脆Dialog都不用了直接用PopupWindow\"><a href=\"#干脆Dialog都不用了直接用PopupWindow\" class=\"headerlink\" title=\"干脆Dialog都不用了直接用PopupWindow\"></a>干脆Dialog都不用了直接用PopupWindow</h3><p>我们知道popWindow是与Activity共用同一个Window的，这一点上来讲，非常好控制，配合WindowManager 完全可以实现需求。</p>\n<p><a href=\"https://github.com/o0o0oo00/NewToast\" target=\"_blank\" rel=\"noopener\">代码</a></p>\n","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"<h2 id=\"Alert弹窗-的一种解决方案\"><a href=\"#Alert弹窗-的一种解决方案\" class=\"headerlink\" title=\"Alert弹窗 的一种解决方案\"></a>Alert弹窗 的一种解决方案</h2><p>需求：在屏幕的最上方弹出一个横条Alert（警告框） 居于StateBar（状态栏）之下</p>\n<p>初始的解决方案是直接修改系统的Toast，可以通过反射字段来达到Toast可以交互的目的。但是在Android8.0以上的手机，Toast 的Animation被固定为了淡入淡出，不可以是上滑下滑的动画效果，所以PASS。  </p>\n<p>Android上的<strong>Alert</strong>（警告）弹窗，<strong>本质上</strong>就是一个<strong>View</strong>。 既然是一个View那么我们完全可以自定义与它的交互效果。  </p>\n<p>下面说几种我想到的解决方案<br>","more":"</p>\n<h3 id=\"1-普通Alerta\"><a href=\"#1-普通Alerta\" class=\"headerlink\" title=\"1. 普通Alerta\"></a>1. 普通Alerta</h3><p>此时只有Activity一个Window，所以不存在层级之间的覆盖关系。<br>直接在<strong>Activity的DecorView上添加AlertView</strong></p>\n<h3 id=\"2-Activity中存在Dialog的时候\"><a href=\"#2-Activity中存在Dialog的时候\" class=\"headerlink\" title=\"2. Activity中存在Dialog的时候\"></a>2. Activity中存在Dialog的时候</h3><p>如果用上面的方法的话，会出现一个问题，Dialog的阴影把我们的Alert弹窗覆盖上了，针对这个问题我们分析一下   </p>\n<p>由于Dialog所属的Window层级为System级别，所以显示优先级高于Activity的Window层级Application</p>\n<h3 id=\"3-直男解决办法\"><a href=\"#3-直男解决办法\" class=\"headerlink\" title=\"3. 直男解决办法\"></a>3. 直男解决办法</h3><p>经过观察发现，可以通过<code>dialog.window.decorView</code>来获取到dialog的DecorView，那么我们是不是可以将我们的AlertView添加到这个decorView之上呢？<br>事实证明是可以的，不过Dialog的Window大小需要调整，此时就遇到了另一个问题。如何将Dialog全屏，以便于Alert可以显示在屏幕的最上方。</p>\n<p>下面粘贴了关键代码（详见<code>BaseFullScreenDialog</code>） + XML布局 双match_parent</p>\n<pre><code>window?.requestFeature(Window.FEATURE_NO_TITLE)\nwindow?.setLayout(WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.MATCH_PARENT)\nif (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {\n    window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS)\n}\n\ndialog = newDialog()// 创建出dialog对象\ndialog.setContentView(view, ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))\ndialog.window.setBackgroundDrawableResource(android.R.color.transparent)\n</code></pre><p>这样Dialog全屏的时候我们的Alert果然就显示在了屏幕的最上方！</p>\n<p>不过 <strong>又双叒叕</strong> 引申出另一个问题，如果Dialog中存在输入框，需要弹出输入法，我们知道，默认的dialog在输入法弹出的时候会自动被推上去一段距离，可是我们的dialog已经全屏了啊，此时我又写了一个通用扩展方法<code>dialog.pushDialogAboveSoftInput(root, content)</code>其中计算了输入法高度以及NavigationBar高度，来将Dialog xml布局中的<strong>内容view</strong>手动的推上去一段距离。这才勉强算是完成了需求。擦汗…… </p>\n<p>又双叒叕引申出一些关于NavigationBar的坑就不太好处理了</p>\n<h3 id=\"4-奇技淫巧解决办法\"><a href=\"#4-奇技淫巧解决办法\" class=\"headerlink\" title=\"4 奇技淫巧解决办法\"></a>4 奇技淫巧解决办法</h3><p>我们回归问题的原始，又回到最初的起点……   </p>\n<p>是因为dialog的阴影挡住了我们的Alert所以才要将Alert添加到Dialog的Window上去。那么我们可不可以将Dialog的阴影去掉，换成改变Activity的透明度。岂不是绕过了上面的所有问题。☆´∀｀☆</p>\n<p>首先应该设置dialog弹出时候背景不变黑</p>\n<pre><code> dialog.window.setDimAmount(0F)\n</code></pre><p>分别在dialog的show 和 dismiss方法中去改变Activity的透明度。</p>\n<pre><code>// 黑暗 0.0F ~ 1.0F 透明\nfun Context.setBackgroundAlpha(alpha: Float) {\n    val act = this as? Activity ?: return\n    val attributes = act.window.attributes\n    attributes.alpha = alpha\n    act.window.attributes = attributes\n}\n</code></pre><p>这样就把问题控制在了AlertView的层级上了，只需要配合WindowManager，就可以实现Alert不会被背景阴影挡住了。</p>\n<h3 id=\"5-WindowManager-设置Alert层级\"><a href=\"#5-WindowManager-设置Alert层级\" class=\"headerlink\" title=\"5. WindowManager 设置Alert层级\"></a>5. WindowManager 设置Alert层级</h3><p>(╥﹏╥…) </p>\n<p>我们知道Window的显示是有层级顺序的，层级高的覆盖在层级低的Window之上。<br>Activity的层级为 <code>TYPE_APPLICATION</code><br>PopupWindow的层级为<code>TYPE_APPLICATION_PANEL</code><br>而我们只需要添加一个层级为<code>TYPE_APPLICATION_SUB_PANEL</code>的View到Window上面即可</p>\n<blockquote>\n<p>These windows are displayed on top their attached window and any{@link #TYPE_APPLICATION_PANEL} panels.</p>\n</blockquote>\n<p>关于层级顺序详见SDK WindowManager.java</p>\n<p><strong>注!!!</strong><br>使用WindowManager如果是在<strong>层级为2000<code>FIRST_SYSTEM_WINDOW</code></strong>以下的是<strong>不需要</strong>申请弹窗权限的。</p>\n<p>而这种创建出来的Window是依附于Activity的，如果界面被销毁，或者还没有初始化就去使用WindowManager来<code>addView</code>或者<code>removeView</code>会报异常<code>view not attached to window</code></p>\n<p>针对这个问题，做如下控制</p>\n<pre><code>if ((act as? Activity)?.isFinishing == true) {\n    return\n}\n\nwindowManager.addView(root, layoutParams)\n</code></pre><pre><code>Handler().postDelayed({\n    if (root.isAttachedToWindow &amp;&amp; act?.isFinishing != true) {\n        windowManager.removeView(root)\n    }\n}, DURATION_ANIM)\n\n</code></pre><p>以及关联Application 的 <code>registerActivityLifecycleCallbacks</code>生命周期</p>\n<pre><code>override fun onActivityDestroyed(activity: Activity?) {\n    if (root.isAttachedToWindow) {\n        windowManager.removeView(root)\n    }\n}\n</code></pre><h3 id=\"6-特殊问题\"><a href=\"#6-特殊问题\" class=\"headerlink\" title=\"6 特殊问题\"></a>6 特殊问题</h3><p>在one plus 的 9.0 系统上面 windowManager添加顶部Alert会<strong>被statebar遮挡一部分</strong>  </p>\n<p>解决办法：给WindowManager.LayoutParams添加如下FLAG</p>\n<pre><code>layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or // 不获取焦点，以便于在弹出的时候 下层界面仍然可以进行操作\n        WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN or\n        WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR // 确保你的内容不会被装饰物(如状态栏)掩盖.\n\n</code></pre><h3 id=\"干脆Dialog都不用了直接用PopupWindow\"><a href=\"#干脆Dialog都不用了直接用PopupWindow\" class=\"headerlink\" title=\"干脆Dialog都不用了直接用PopupWindow\"></a>干脆Dialog都不用了直接用PopupWindow</h3><p>我们知道popWindow是与Activity共用同一个Window的，这一点上来讲，非常好控制，配合WindowManager 完全可以实现需求。</p>\n<p><a href=\"https://github.com/o0o0oo00/NewToast\" target=\"_blank\" rel=\"noopener\">代码</a></p>"},{"title":"注解知识简述","date":"2018-10-10T08:22:24.000Z","_content":"### 注解知识点\n#### 概念\n注解是一种元数据形式，可以被添加到java源代码中，类、方法、变量、参数、包都可以被注解，注解对他们操作的代码没有直接的影响。\n<!--more-->\n#### 作用\n1. 标记，用于告诉编辑器一些信息\n2. 编译时动态处理，例如动态生成代码\n3. 运行时动态处理，例如得到注解信息  \n\n#### 自定义注解\n1. 通过@interface定义，注解名即为自定义注解名\n2. 注解配置参数名为注解类的方法名  \n1. 所有方法没有方法体，没有参数没有修饰符，实际只允许 public & abstract 修饰符，默认为 public，不允许抛异常  \n2. 方法返回值只能是基本类型，String, Class, annotation, enumeration 或者是他们的一维数组  \n3. 若只有一个默认属性，可直接用 value() 函数。一个属性都没有表示该 Annotation 为 Mark Annotation\n3. 可以加 default 表示默认值 \n\n```\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@Inherited\npublic @interface MethodInfo {\n\nString author() default \"o0o0oo00\";\n\nString date();\n\nint version() default 1;\n}\n```\n#### 元注解\n它是一种基本注解，用于应用到定义的注解上面\n\n* @Documented 是否会保存到 Javadoc 文档中\n* @Retention 保留时间，可选值 SOURCE（源码时），CLASS（编译时），RUNTIME（运行时），默认为 CLASS，SOURCE 大都为 Mark Annotation，这类 Annotation 大都用来校验，比如 Override, SuppressWarnings\n* @Target 可以用来修饰哪些程序元素  \n\n>\nElementType.ANNOTATION_TYPE  可以给一个注解进行注解\nElementType.CONSTRUCTOR  可以给构造方法进行注解\nElementType.FIELD  可以给属性进行注解\nElementType.LOCAL_VARIABLE  可以给局部变量进行注解\nElementType.METHOD   可以给方法进行注解\nElementType.PACKAGE  可以给一个包进行注解\nElementType.PARAMETER  可以给一个方法内的参数进行注解\nElementType.TYPE  可以给一个类型进行注解，比如类、接口、枚举\n\n未标注则表示可修饰所有\n\n* @Inherited 是否可以被继承，默认为 false。意思是说，老子是富豪，那么老子的儿子虽然没有明确的指明为是富豪，但他也是富豪。\n* @Repeatable 注解会多次应用，通常是注解的值可以同时取多个\n\n```\n@interface Persons {\nPerson[]  value();\n}\n\n@Repeatable(Persons.class)\n@interface Person{\nString role default \"goodman\";\n}\n\n@Person(role=\"motherfucker\")\n@Person(role=\"asshole\")\n@Person(role=\"bitch\")\npublic class SuperMan{\n\n}\n\n```\n**Attention!**  \n\n1. 如果只有一个名为value的属性时，在使用的时候可以省略命名参数直接填入\n2. 如果定义的时候一个属性都没有那么在使用的时候连括号都可以省略\n\n#### 运行时注解解析\n运行时 Annotation 指 @Retention 为 RUNTIME 的 Annotation，可手动调用下面常用 API 解析  \n> method.getAnnotation(AnnotationName.class);\nmethod.getAnnotations();  \nmethod.isAnnotationPresent(AnnotationName.class);是否应用了某个注解   \n\n```\npublic static void main (String[] args){\ntry {\nClass cls = Class.forName(\"com.zcy.nidavellir.javaworld.java.App\");\nfor (Method method : cls.getMethods()) {\nMethodInfo methodInfo = method.getAnnotation(MethodInfo.class);\nif (methodInfo != null) {\nSystem.out.println(\"method name:\" + method.getName());\nSystem.out.println(\"method author:\" + methodInfo.author());\nSystem.out.println(\"method version:\" + methodInfo.version());\nSystem.out.println(\"method date:\" + methodInfo.date());\n}\n}\n} catch (ClassNotFoundException e) {\ne.printStackTrace();\n}\n}\n```\n#### 编译时注解解析\n编译时 Annotation 指 @Retention 为 CLASS 的 Annotation，由编译器自动解析\n\n1. 自定义类集成自 AbstractProcessor\n2. 重写其中的 process 函数  \n\n实际是编译器在编译时自动查找所有继承自 AbstractProcessor 的类，然后调用他们的 process 方法去处理\n\n","source":"_posts/annotation.md","raw":"---\ntitle: 注解知识简述\ndate: 2018-10-10 16:22:24\ncategories: 技术\ntag: android\n\n---\n### 注解知识点\n#### 概念\n注解是一种元数据形式，可以被添加到java源代码中，类、方法、变量、参数、包都可以被注解，注解对他们操作的代码没有直接的影响。\n<!--more-->\n#### 作用\n1. 标记，用于告诉编辑器一些信息\n2. 编译时动态处理，例如动态生成代码\n3. 运行时动态处理，例如得到注解信息  \n\n#### 自定义注解\n1. 通过@interface定义，注解名即为自定义注解名\n2. 注解配置参数名为注解类的方法名  \n1. 所有方法没有方法体，没有参数没有修饰符，实际只允许 public & abstract 修饰符，默认为 public，不允许抛异常  \n2. 方法返回值只能是基本类型，String, Class, annotation, enumeration 或者是他们的一维数组  \n3. 若只有一个默认属性，可直接用 value() 函数。一个属性都没有表示该 Annotation 为 Mark Annotation\n3. 可以加 default 表示默认值 \n\n```\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@Inherited\npublic @interface MethodInfo {\n\nString author() default \"o0o0oo00\";\n\nString date();\n\nint version() default 1;\n}\n```\n#### 元注解\n它是一种基本注解，用于应用到定义的注解上面\n\n* @Documented 是否会保存到 Javadoc 文档中\n* @Retention 保留时间，可选值 SOURCE（源码时），CLASS（编译时），RUNTIME（运行时），默认为 CLASS，SOURCE 大都为 Mark Annotation，这类 Annotation 大都用来校验，比如 Override, SuppressWarnings\n* @Target 可以用来修饰哪些程序元素  \n\n>\nElementType.ANNOTATION_TYPE  可以给一个注解进行注解\nElementType.CONSTRUCTOR  可以给构造方法进行注解\nElementType.FIELD  可以给属性进行注解\nElementType.LOCAL_VARIABLE  可以给局部变量进行注解\nElementType.METHOD   可以给方法进行注解\nElementType.PACKAGE  可以给一个包进行注解\nElementType.PARAMETER  可以给一个方法内的参数进行注解\nElementType.TYPE  可以给一个类型进行注解，比如类、接口、枚举\n\n未标注则表示可修饰所有\n\n* @Inherited 是否可以被继承，默认为 false。意思是说，老子是富豪，那么老子的儿子虽然没有明确的指明为是富豪，但他也是富豪。\n* @Repeatable 注解会多次应用，通常是注解的值可以同时取多个\n\n```\n@interface Persons {\nPerson[]  value();\n}\n\n@Repeatable(Persons.class)\n@interface Person{\nString role default \"goodman\";\n}\n\n@Person(role=\"motherfucker\")\n@Person(role=\"asshole\")\n@Person(role=\"bitch\")\npublic class SuperMan{\n\n}\n\n```\n**Attention!**  \n\n1. 如果只有一个名为value的属性时，在使用的时候可以省略命名参数直接填入\n2. 如果定义的时候一个属性都没有那么在使用的时候连括号都可以省略\n\n#### 运行时注解解析\n运行时 Annotation 指 @Retention 为 RUNTIME 的 Annotation，可手动调用下面常用 API 解析  \n> method.getAnnotation(AnnotationName.class);\nmethod.getAnnotations();  \nmethod.isAnnotationPresent(AnnotationName.class);是否应用了某个注解   \n\n```\npublic static void main (String[] args){\ntry {\nClass cls = Class.forName(\"com.zcy.nidavellir.javaworld.java.App\");\nfor (Method method : cls.getMethods()) {\nMethodInfo methodInfo = method.getAnnotation(MethodInfo.class);\nif (methodInfo != null) {\nSystem.out.println(\"method name:\" + method.getName());\nSystem.out.println(\"method author:\" + methodInfo.author());\nSystem.out.println(\"method version:\" + methodInfo.version());\nSystem.out.println(\"method date:\" + methodInfo.date());\n}\n}\n} catch (ClassNotFoundException e) {\ne.printStackTrace();\n}\n}\n```\n#### 编译时注解解析\n编译时 Annotation 指 @Retention 为 CLASS 的 Annotation，由编译器自动解析\n\n1. 自定义类集成自 AbstractProcessor\n2. 重写其中的 process 函数  \n\n实际是编译器在编译时自动查找所有继承自 AbstractProcessor 的类，然后调用他们的 process 方法去处理\n\n","slug":"annotation","published":1,"updated":"2019-02-28T09:27:03.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf10s000m5l26abkmp14f","content":"<h3 id=\"注解知识点\"><a href=\"#注解知识点\" class=\"headerlink\" title=\"注解知识点\"></a>注解知识点</h3><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>注解是一种元数据形式，可以被添加到java源代码中，类、方法、变量、参数、包都可以被注解，注解对他们操作的代码没有直接的影响。<br><a id=\"more\"></a></p>\n<h4 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h4><ol>\n<li>标记，用于告诉编辑器一些信息</li>\n<li>编译时动态处理，例如动态生成代码</li>\n<li>运行时动态处理，例如得到注解信息  </li>\n</ol>\n<h4 id=\"自定义注解\"><a href=\"#自定义注解\" class=\"headerlink\" title=\"自定义注解\"></a>自定义注解</h4><ol>\n<li>通过@interface定义，注解名即为自定义注解名</li>\n<li>注解配置参数名为注解类的方法名  </li>\n<li>所有方法没有方法体，没有参数没有修饰符，实际只允许 public &amp; abstract 修饰符，默认为 public，不允许抛异常  </li>\n<li>方法返回值只能是基本类型，String, Class, annotation, enumeration 或者是他们的一维数组  </li>\n<li>若只有一个默认属性，可直接用 value() 函数。一个属性都没有表示该 Annotation 为 Mark Annotation</li>\n<li>可以加 default 表示默认值 </li>\n</ol>\n<pre><code>@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@Inherited\npublic @interface MethodInfo {\n\nString author() default &quot;o0o0oo00&quot;;\n\nString date();\n\nint version() default 1;\n}\n</code></pre><h4 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h4><p>它是一种基本注解，用于应用到定义的注解上面</p>\n<ul>\n<li>@Documented 是否会保存到 Javadoc 文档中</li>\n<li>@Retention 保留时间，可选值 SOURCE（源码时），CLASS（编译时），RUNTIME（运行时），默认为 CLASS，SOURCE 大都为 Mark Annotation，这类 Annotation 大都用来校验，比如 Override, SuppressWarnings</li>\n<li>@Target 可以用来修饰哪些程序元素  </li>\n</ul>\n<blockquote>\n</blockquote>\n<p>ElementType.ANNOTATION_TYPE  可以给一个注解进行注解<br>ElementType.CONSTRUCTOR  可以给构造方法进行注解<br>ElementType.FIELD  可以给属性进行注解<br>ElementType.LOCAL_VARIABLE  可以给局部变量进行注解<br>ElementType.METHOD   可以给方法进行注解<br>ElementType.PACKAGE  可以给一个包进行注解<br>ElementType.PARAMETER  可以给一个方法内的参数进行注解<br>ElementType.TYPE  可以给一个类型进行注解，比如类、接口、枚举</p>\n<p>未标注则表示可修饰所有</p>\n<ul>\n<li>@Inherited 是否可以被继承，默认为 false。意思是说，老子是富豪，那么老子的儿子虽然没有明确的指明为是富豪，但他也是富豪。</li>\n<li>@Repeatable 注解会多次应用，通常是注解的值可以同时取多个</li>\n</ul>\n<pre><code>@interface Persons {\nPerson[]  value();\n}\n\n@Repeatable(Persons.class)\n@interface Person{\nString role default &quot;goodman&quot;;\n}\n\n@Person(role=&quot;motherfucker&quot;)\n@Person(role=&quot;asshole&quot;)\n@Person(role=&quot;bitch&quot;)\npublic class SuperMan{\n\n}\n\n</code></pre><p><strong>Attention!</strong>  </p>\n<ol>\n<li>如果只有一个名为value的属性时，在使用的时候可以省略命名参数直接填入</li>\n<li>如果定义的时候一个属性都没有那么在使用的时候连括号都可以省略</li>\n</ol>\n<h4 id=\"运行时注解解析\"><a href=\"#运行时注解解析\" class=\"headerlink\" title=\"运行时注解解析\"></a>运行时注解解析</h4><p>运行时 Annotation 指 @Retention 为 RUNTIME 的 Annotation，可手动调用下面常用 API 解析  </p>\n<blockquote>\n<p>method.getAnnotation(AnnotationName.class);<br>method.getAnnotations();<br>method.isAnnotationPresent(AnnotationName.class);是否应用了某个注解   </p>\n</blockquote>\n<pre><code>public static void main (String[] args){\ntry {\nClass cls = Class.forName(&quot;com.zcy.nidavellir.javaworld.java.App&quot;);\nfor (Method method : cls.getMethods()) {\nMethodInfo methodInfo = method.getAnnotation(MethodInfo.class);\nif (methodInfo != null) {\nSystem.out.println(&quot;method name:&quot; + method.getName());\nSystem.out.println(&quot;method author:&quot; + methodInfo.author());\nSystem.out.println(&quot;method version:&quot; + methodInfo.version());\nSystem.out.println(&quot;method date:&quot; + methodInfo.date());\n}\n}\n} catch (ClassNotFoundException e) {\ne.printStackTrace();\n}\n}\n</code></pre><h4 id=\"编译时注解解析\"><a href=\"#编译时注解解析\" class=\"headerlink\" title=\"编译时注解解析\"></a>编译时注解解析</h4><p>编译时 Annotation 指 @Retention 为 CLASS 的 Annotation，由编译器自动解析</p>\n<ol>\n<li>自定义类集成自 AbstractProcessor</li>\n<li>重写其中的 process 函数  </li>\n</ol>\n<p>实际是编译器在编译时自动查找所有继承自 AbstractProcessor 的类，然后调用他们的 process 方法去处理</p>\n","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"<h3 id=\"注解知识点\"><a href=\"#注解知识点\" class=\"headerlink\" title=\"注解知识点\"></a>注解知识点</h3><h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>注解是一种元数据形式，可以被添加到java源代码中，类、方法、变量、参数、包都可以被注解，注解对他们操作的代码没有直接的影响。<br>","more":"</p>\n<h4 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h4><ol>\n<li>标记，用于告诉编辑器一些信息</li>\n<li>编译时动态处理，例如动态生成代码</li>\n<li>运行时动态处理，例如得到注解信息  </li>\n</ol>\n<h4 id=\"自定义注解\"><a href=\"#自定义注解\" class=\"headerlink\" title=\"自定义注解\"></a>自定义注解</h4><ol>\n<li>通过@interface定义，注解名即为自定义注解名</li>\n<li>注解配置参数名为注解类的方法名  </li>\n<li>所有方法没有方法体，没有参数没有修饰符，实际只允许 public &amp; abstract 修饰符，默认为 public，不允许抛异常  </li>\n<li>方法返回值只能是基本类型，String, Class, annotation, enumeration 或者是他们的一维数组  </li>\n<li>若只有一个默认属性，可直接用 value() 函数。一个属性都没有表示该 Annotation 为 Mark Annotation</li>\n<li>可以加 default 表示默认值 </li>\n</ol>\n<pre><code>@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\n@Inherited\npublic @interface MethodInfo {\n\nString author() default &quot;o0o0oo00&quot;;\n\nString date();\n\nint version() default 1;\n}\n</code></pre><h4 id=\"元注解\"><a href=\"#元注解\" class=\"headerlink\" title=\"元注解\"></a>元注解</h4><p>它是一种基本注解，用于应用到定义的注解上面</p>\n<ul>\n<li>@Documented 是否会保存到 Javadoc 文档中</li>\n<li>@Retention 保留时间，可选值 SOURCE（源码时），CLASS（编译时），RUNTIME（运行时），默认为 CLASS，SOURCE 大都为 Mark Annotation，这类 Annotation 大都用来校验，比如 Override, SuppressWarnings</li>\n<li>@Target 可以用来修饰哪些程序元素  </li>\n</ul>\n<blockquote>\n</blockquote>\n<p>ElementType.ANNOTATION_TYPE  可以给一个注解进行注解<br>ElementType.CONSTRUCTOR  可以给构造方法进行注解<br>ElementType.FIELD  可以给属性进行注解<br>ElementType.LOCAL_VARIABLE  可以给局部变量进行注解<br>ElementType.METHOD   可以给方法进行注解<br>ElementType.PACKAGE  可以给一个包进行注解<br>ElementType.PARAMETER  可以给一个方法内的参数进行注解<br>ElementType.TYPE  可以给一个类型进行注解，比如类、接口、枚举</p>\n<p>未标注则表示可修饰所有</p>\n<ul>\n<li>@Inherited 是否可以被继承，默认为 false。意思是说，老子是富豪，那么老子的儿子虽然没有明确的指明为是富豪，但他也是富豪。</li>\n<li>@Repeatable 注解会多次应用，通常是注解的值可以同时取多个</li>\n</ul>\n<pre><code>@interface Persons {\nPerson[]  value();\n}\n\n@Repeatable(Persons.class)\n@interface Person{\nString role default &quot;goodman&quot;;\n}\n\n@Person(role=&quot;motherfucker&quot;)\n@Person(role=&quot;asshole&quot;)\n@Person(role=&quot;bitch&quot;)\npublic class SuperMan{\n\n}\n\n</code></pre><p><strong>Attention!</strong>  </p>\n<ol>\n<li>如果只有一个名为value的属性时，在使用的时候可以省略命名参数直接填入</li>\n<li>如果定义的时候一个属性都没有那么在使用的时候连括号都可以省略</li>\n</ol>\n<h4 id=\"运行时注解解析\"><a href=\"#运行时注解解析\" class=\"headerlink\" title=\"运行时注解解析\"></a>运行时注解解析</h4><p>运行时 Annotation 指 @Retention 为 RUNTIME 的 Annotation，可手动调用下面常用 API 解析  </p>\n<blockquote>\n<p>method.getAnnotation(AnnotationName.class);<br>method.getAnnotations();<br>method.isAnnotationPresent(AnnotationName.class);是否应用了某个注解   </p>\n</blockquote>\n<pre><code>public static void main (String[] args){\ntry {\nClass cls = Class.forName(&quot;com.zcy.nidavellir.javaworld.java.App&quot;);\nfor (Method method : cls.getMethods()) {\nMethodInfo methodInfo = method.getAnnotation(MethodInfo.class);\nif (methodInfo != null) {\nSystem.out.println(&quot;method name:&quot; + method.getName());\nSystem.out.println(&quot;method author:&quot; + methodInfo.author());\nSystem.out.println(&quot;method version:&quot; + methodInfo.version());\nSystem.out.println(&quot;method date:&quot; + methodInfo.date());\n}\n}\n} catch (ClassNotFoundException e) {\ne.printStackTrace();\n}\n}\n</code></pre><h4 id=\"编译时注解解析\"><a href=\"#编译时注解解析\" class=\"headerlink\" title=\"编译时注解解析\"></a>编译时注解解析</h4><p>编译时 Annotation 指 @Retention 为 CLASS 的 Annotation，由编译器自动解析</p>\n<ol>\n<li>自定义类集成自 AbstractProcessor</li>\n<li>重写其中的 process 函数  </li>\n</ol>\n<p>实际是编译器在编译时自动查找所有继承自 AbstractProcessor 的类，然后调用他们的 process 方法去处理</p>"},{"title":"Use Dagger2 With Kotlin","date":"2019-02-26T05:52:21.000Z","_content":"\n## Use Dagger2 With Kotlin\n\n\n### 添加Dagger依赖\n\n```\ndependencies {\n    kapt 'com.google.dagger:dagger-compiler:2.16'\n    implementation 'com.google.dagger:dagger:2.16'\n```\n并且 要再文件的头部添加上apply\n\n```\napply plugin: 'kotlin-kapt'\n```\n\n这样就会在`/app/build/generated/source/kapt/debug/com/zcy/mydagger`下生成对应的代码来实现注入\n<!--more-->\n### 被注入对象\n#### 手写代码\n```\nclass Car @Inject constructor() {\n\n}\n```\n#### 生成的代码\n仔细阅读代码发现\n\n调用的顺序似乎是 `create(创建 INSTANCE )` -> `get()` -> `provideInstatnce()` -> `new Car()`\n\n来生产出一个 **Car** 对象\n\n```\npublic final class Car_Factory implements Factory<Car> {\n  private static final Car_Factory INSTANCE = new Car_Factory();\n\n  @Override\n  public Car get() {\n    return provideInstance();\n  }\n\n  public static Car provideInstance() {\n    return new Car();\n  }\n\n  public static Car_Factory create() {\n    return INSTANCE;\n  }\n\n  public static Car newCar() {\n    return new Car();\n  }\n}\n```\n\n### 使用被注入的对象\n在kotlin中 需要注入到属性 set 中去\n\n```\nclass Man {\n    lateinit var car:Car\n        @Inject set\n```\n\n### Component 搭桥\n#### 手写代码\n```\n@Component\ninterface ManComponent {\n    fun inject(man: Man)\n}\n```\n此时build之后会生成一些代码 比如`DaggerManComponent` 约定多了一个`Dagger`前缀\n#### 生成代码\n\n```\npublic final class DaggerManComponent implements ManComponent {\n  private DaggerManComponent(Builder builder) {}\n\n  public static Builder builder() {\n    return new Builder();\n  }\n\n  public static ManComponent create() {\n    return new Builder().build();\n  }\n\n  @Override\n  public void inject(Man man) {\n    injectMan(man);\n  }\n\n  private Man injectMan(Man instance) {\n    Man_MembersInjector.injectSetCar(instance, new Car());\n    return instance;\n  }\n\n  public static final class Builder {\n    private Builder() {}\n\n    public ManComponent build() {\n      return new DaggerManComponent(this);\n    }\n  }\n}\n```\n调用的顺序似乎是 `create()` -> `inject(Man man)`   \n其中\n**`create() == Builder().build()`**  \n而在`build()`方法中返回了一个**DaggerManComponent**实例，通过这个实例，来调用`inject()`  \n而 `inject()`里面调用的是  \n**`Man_MembersInjector.injectSetCar(instance, new Car());`**  \n最后返回**instance** 也就是传进来的**Man**\n\n其他都没啥 ，关键是**`Man_MembersInjector.injectSetCar(instance, new Car());`**   \n而这方法应该是Man(使用注入对象的Man所生成的代码)  \n猜测是将`new Car()`对象赋值到了`instance`中  \n**继续看下面**\n\n### 完成注入\n#### 手写代码\n最后成功输出了**`com.zcy.mydagger.Car@6ff3c5b5`**\n\n```\nclass Man {\n    init {\n        DaggerManComponent.create().inject(this)\n    }\n\n    lateinit var car: Car\n        @Inject set\n\n    fun a() {\n        println(car)\n    }\n\n\n}\n\nfun main(args: Array<String>) {\n    println(Man().a())\n}\n```\n#### 生成的代码\n\n```\npublic final class Man_MembersInjector implements MembersInjector<Man> {\n  private final Provider<Car> p0Provider;\n\n  public Man_MembersInjector(Provider<Car> p0Provider) {\n    this.p0Provider = p0Provider;\n  }\n\n  public static MembersInjector<Man> create(Provider<Car> p0Provider) {\n    return new Man_MembersInjector(p0Provider);\n  }\n\n  @Override\n  public void injectMembers(Man instance) {\n    injectSetCar(instance, p0Provider.get());\n  }\n\n  public static void injectSetCar(Man instance, Car p0) {\n    instance.setCar(p0);\n  }\n}\n\n```\n此处正好证实了上面的猜想，**`injectSetCar`** 方法中 `instance.setCar(p0);`正好是将**car**这个属性进行赋值，恰好就是我们**component**中的`new car()`\n\n\n简单的代码分析就酱","source":"_posts/dagger.md","raw":"---\ntitle: Use Dagger2 With Kotlin\ndate: 2019-02-26 13:52:21\ntags: dagger\ncategories: 技术\n\n---\n\n## Use Dagger2 With Kotlin\n\n\n### 添加Dagger依赖\n\n```\ndependencies {\n    kapt 'com.google.dagger:dagger-compiler:2.16'\n    implementation 'com.google.dagger:dagger:2.16'\n```\n并且 要再文件的头部添加上apply\n\n```\napply plugin: 'kotlin-kapt'\n```\n\n这样就会在`/app/build/generated/source/kapt/debug/com/zcy/mydagger`下生成对应的代码来实现注入\n<!--more-->\n### 被注入对象\n#### 手写代码\n```\nclass Car @Inject constructor() {\n\n}\n```\n#### 生成的代码\n仔细阅读代码发现\n\n调用的顺序似乎是 `create(创建 INSTANCE )` -> `get()` -> `provideInstatnce()` -> `new Car()`\n\n来生产出一个 **Car** 对象\n\n```\npublic final class Car_Factory implements Factory<Car> {\n  private static final Car_Factory INSTANCE = new Car_Factory();\n\n  @Override\n  public Car get() {\n    return provideInstance();\n  }\n\n  public static Car provideInstance() {\n    return new Car();\n  }\n\n  public static Car_Factory create() {\n    return INSTANCE;\n  }\n\n  public static Car newCar() {\n    return new Car();\n  }\n}\n```\n\n### 使用被注入的对象\n在kotlin中 需要注入到属性 set 中去\n\n```\nclass Man {\n    lateinit var car:Car\n        @Inject set\n```\n\n### Component 搭桥\n#### 手写代码\n```\n@Component\ninterface ManComponent {\n    fun inject(man: Man)\n}\n```\n此时build之后会生成一些代码 比如`DaggerManComponent` 约定多了一个`Dagger`前缀\n#### 生成代码\n\n```\npublic final class DaggerManComponent implements ManComponent {\n  private DaggerManComponent(Builder builder) {}\n\n  public static Builder builder() {\n    return new Builder();\n  }\n\n  public static ManComponent create() {\n    return new Builder().build();\n  }\n\n  @Override\n  public void inject(Man man) {\n    injectMan(man);\n  }\n\n  private Man injectMan(Man instance) {\n    Man_MembersInjector.injectSetCar(instance, new Car());\n    return instance;\n  }\n\n  public static final class Builder {\n    private Builder() {}\n\n    public ManComponent build() {\n      return new DaggerManComponent(this);\n    }\n  }\n}\n```\n调用的顺序似乎是 `create()` -> `inject(Man man)`   \n其中\n**`create() == Builder().build()`**  \n而在`build()`方法中返回了一个**DaggerManComponent**实例，通过这个实例，来调用`inject()`  \n而 `inject()`里面调用的是  \n**`Man_MembersInjector.injectSetCar(instance, new Car());`**  \n最后返回**instance** 也就是传进来的**Man**\n\n其他都没啥 ，关键是**`Man_MembersInjector.injectSetCar(instance, new Car());`**   \n而这方法应该是Man(使用注入对象的Man所生成的代码)  \n猜测是将`new Car()`对象赋值到了`instance`中  \n**继续看下面**\n\n### 完成注入\n#### 手写代码\n最后成功输出了**`com.zcy.mydagger.Car@6ff3c5b5`**\n\n```\nclass Man {\n    init {\n        DaggerManComponent.create().inject(this)\n    }\n\n    lateinit var car: Car\n        @Inject set\n\n    fun a() {\n        println(car)\n    }\n\n\n}\n\nfun main(args: Array<String>) {\n    println(Man().a())\n}\n```\n#### 生成的代码\n\n```\npublic final class Man_MembersInjector implements MembersInjector<Man> {\n  private final Provider<Car> p0Provider;\n\n  public Man_MembersInjector(Provider<Car> p0Provider) {\n    this.p0Provider = p0Provider;\n  }\n\n  public static MembersInjector<Man> create(Provider<Car> p0Provider) {\n    return new Man_MembersInjector(p0Provider);\n  }\n\n  @Override\n  public void injectMembers(Man instance) {\n    injectSetCar(instance, p0Provider.get());\n  }\n\n  public static void injectSetCar(Man instance, Car p0) {\n    instance.setCar(p0);\n  }\n}\n\n```\n此处正好证实了上面的猜想，**`injectSetCar`** 方法中 `instance.setCar(p0);`正好是将**car**这个属性进行赋值，恰好就是我们**component**中的`new car()`\n\n\n简单的代码分析就酱","slug":"dagger","published":1,"updated":"2019-02-26T08:28:20.877Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf10v000o5l26b7381v5o","content":"<h2 id=\"Use-Dagger2-With-Kotlin\"><a href=\"#Use-Dagger2-With-Kotlin\" class=\"headerlink\" title=\"Use Dagger2 With Kotlin\"></a>Use Dagger2 With Kotlin</h2><h3 id=\"添加Dagger依赖\"><a href=\"#添加Dagger依赖\" class=\"headerlink\" title=\"添加Dagger依赖\"></a>添加Dagger依赖</h3><pre><code>dependencies {\n    kapt &#39;com.google.dagger:dagger-compiler:2.16&#39;\n    implementation &#39;com.google.dagger:dagger:2.16&#39;\n</code></pre><p>并且 要再文件的头部添加上apply</p>\n<pre><code>apply plugin: &#39;kotlin-kapt&#39;\n</code></pre><p>这样就会在<code>/app/build/generated/source/kapt/debug/com/zcy/mydagger</code>下生成对应的代码来实现注入<br><a id=\"more\"></a></p>\n<h3 id=\"被注入对象\"><a href=\"#被注入对象\" class=\"headerlink\" title=\"被注入对象\"></a>被注入对象</h3><h4 id=\"手写代码\"><a href=\"#手写代码\" class=\"headerlink\" title=\"手写代码\"></a>手写代码</h4><pre><code>class Car @Inject constructor() {\n\n}\n</code></pre><h4 id=\"生成的代码\"><a href=\"#生成的代码\" class=\"headerlink\" title=\"生成的代码\"></a>生成的代码</h4><p>仔细阅读代码发现</p>\n<p>调用的顺序似乎是 <code>create(创建 INSTANCE )</code> -&gt; <code>get()</code> -&gt; <code>provideInstatnce()</code> -&gt; <code>new Car()</code></p>\n<p>来生产出一个 <strong>Car</strong> 对象</p>\n<pre><code>public final class Car_Factory implements Factory&lt;Car&gt; {\n  private static final Car_Factory INSTANCE = new Car_Factory();\n\n  @Override\n  public Car get() {\n    return provideInstance();\n  }\n\n  public static Car provideInstance() {\n    return new Car();\n  }\n\n  public static Car_Factory create() {\n    return INSTANCE;\n  }\n\n  public static Car newCar() {\n    return new Car();\n  }\n}\n</code></pre><h3 id=\"使用被注入的对象\"><a href=\"#使用被注入的对象\" class=\"headerlink\" title=\"使用被注入的对象\"></a>使用被注入的对象</h3><p>在kotlin中 需要注入到属性 set 中去</p>\n<pre><code>class Man {\n    lateinit var car:Car\n        @Inject set\n</code></pre><h3 id=\"Component-搭桥\"><a href=\"#Component-搭桥\" class=\"headerlink\" title=\"Component 搭桥\"></a>Component 搭桥</h3><h4 id=\"手写代码-1\"><a href=\"#手写代码-1\" class=\"headerlink\" title=\"手写代码\"></a>手写代码</h4><pre><code>@Component\ninterface ManComponent {\n    fun inject(man: Man)\n}\n</code></pre><p>此时build之后会生成一些代码 比如<code>DaggerManComponent</code> 约定多了一个<code>Dagger</code>前缀</p>\n<h4 id=\"生成代码\"><a href=\"#生成代码\" class=\"headerlink\" title=\"生成代码\"></a>生成代码</h4><pre><code>public final class DaggerManComponent implements ManComponent {\n  private DaggerManComponent(Builder builder) {}\n\n  public static Builder builder() {\n    return new Builder();\n  }\n\n  public static ManComponent create() {\n    return new Builder().build();\n  }\n\n  @Override\n  public void inject(Man man) {\n    injectMan(man);\n  }\n\n  private Man injectMan(Man instance) {\n    Man_MembersInjector.injectSetCar(instance, new Car());\n    return instance;\n  }\n\n  public static final class Builder {\n    private Builder() {}\n\n    public ManComponent build() {\n      return new DaggerManComponent(this);\n    }\n  }\n}\n</code></pre><p>调用的顺序似乎是 <code>create()</code> -&gt; <code>inject(Man man)</code><br>其中<br><strong><code>create() == Builder().build()</code></strong><br>而在<code>build()</code>方法中返回了一个<strong>DaggerManComponent</strong>实例，通过这个实例，来调用<code>inject()</code><br>而 <code>inject()</code>里面调用的是<br><strong><code>Man_MembersInjector.injectSetCar(instance, new Car());</code></strong><br>最后返回<strong>instance</strong> 也就是传进来的<strong>Man</strong></p>\n<p>其他都没啥 ，关键是<strong><code>Man_MembersInjector.injectSetCar(instance, new Car());</code></strong><br>而这方法应该是Man(使用注入对象的Man所生成的代码)<br>猜测是将<code>new Car()</code>对象赋值到了<code>instance</code>中<br><strong>继续看下面</strong></p>\n<h3 id=\"完成注入\"><a href=\"#完成注入\" class=\"headerlink\" title=\"完成注入\"></a>完成注入</h3><h4 id=\"手写代码-2\"><a href=\"#手写代码-2\" class=\"headerlink\" title=\"手写代码\"></a>手写代码</h4><p>最后成功输出了<strong><code>com.zcy.mydagger.Car@6ff3c5b5</code></strong></p>\n<pre><code>class Man {\n    init {\n        DaggerManComponent.create().inject(this)\n    }\n\n    lateinit var car: Car\n        @Inject set\n\n    fun a() {\n        println(car)\n    }\n\n\n}\n\nfun main(args: Array&lt;String&gt;) {\n    println(Man().a())\n}\n</code></pre><h4 id=\"生成的代码-1\"><a href=\"#生成的代码-1\" class=\"headerlink\" title=\"生成的代码\"></a>生成的代码</h4><pre><code>public final class Man_MembersInjector implements MembersInjector&lt;Man&gt; {\n  private final Provider&lt;Car&gt; p0Provider;\n\n  public Man_MembersInjector(Provider&lt;Car&gt; p0Provider) {\n    this.p0Provider = p0Provider;\n  }\n\n  public static MembersInjector&lt;Man&gt; create(Provider&lt;Car&gt; p0Provider) {\n    return new Man_MembersInjector(p0Provider);\n  }\n\n  @Override\n  public void injectMembers(Man instance) {\n    injectSetCar(instance, p0Provider.get());\n  }\n\n  public static void injectSetCar(Man instance, Car p0) {\n    instance.setCar(p0);\n  }\n}\n\n</code></pre><p>此处正好证实了上面的猜想，<strong><code>injectSetCar</code></strong> 方法中 <code>instance.setCar(p0);</code>正好是将<strong>car</strong>这个属性进行赋值，恰好就是我们<strong>component</strong>中的<code>new car()</code></p>\n<p>简单的代码分析就酱</p>\n","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"<h2 id=\"Use-Dagger2-With-Kotlin\"><a href=\"#Use-Dagger2-With-Kotlin\" class=\"headerlink\" title=\"Use Dagger2 With Kotlin\"></a>Use Dagger2 With Kotlin</h2><h3 id=\"添加Dagger依赖\"><a href=\"#添加Dagger依赖\" class=\"headerlink\" title=\"添加Dagger依赖\"></a>添加Dagger依赖</h3><pre><code>dependencies {\n    kapt &#39;com.google.dagger:dagger-compiler:2.16&#39;\n    implementation &#39;com.google.dagger:dagger:2.16&#39;\n</code></pre><p>并且 要再文件的头部添加上apply</p>\n<pre><code>apply plugin: &#39;kotlin-kapt&#39;\n</code></pre><p>这样就会在<code>/app/build/generated/source/kapt/debug/com/zcy/mydagger</code>下生成对应的代码来实现注入<br>","more":"</p>\n<h3 id=\"被注入对象\"><a href=\"#被注入对象\" class=\"headerlink\" title=\"被注入对象\"></a>被注入对象</h3><h4 id=\"手写代码\"><a href=\"#手写代码\" class=\"headerlink\" title=\"手写代码\"></a>手写代码</h4><pre><code>class Car @Inject constructor() {\n\n}\n</code></pre><h4 id=\"生成的代码\"><a href=\"#生成的代码\" class=\"headerlink\" title=\"生成的代码\"></a>生成的代码</h4><p>仔细阅读代码发现</p>\n<p>调用的顺序似乎是 <code>create(创建 INSTANCE )</code> -&gt; <code>get()</code> -&gt; <code>provideInstatnce()</code> -&gt; <code>new Car()</code></p>\n<p>来生产出一个 <strong>Car</strong> 对象</p>\n<pre><code>public final class Car_Factory implements Factory&lt;Car&gt; {\n  private static final Car_Factory INSTANCE = new Car_Factory();\n\n  @Override\n  public Car get() {\n    return provideInstance();\n  }\n\n  public static Car provideInstance() {\n    return new Car();\n  }\n\n  public static Car_Factory create() {\n    return INSTANCE;\n  }\n\n  public static Car newCar() {\n    return new Car();\n  }\n}\n</code></pre><h3 id=\"使用被注入的对象\"><a href=\"#使用被注入的对象\" class=\"headerlink\" title=\"使用被注入的对象\"></a>使用被注入的对象</h3><p>在kotlin中 需要注入到属性 set 中去</p>\n<pre><code>class Man {\n    lateinit var car:Car\n        @Inject set\n</code></pre><h3 id=\"Component-搭桥\"><a href=\"#Component-搭桥\" class=\"headerlink\" title=\"Component 搭桥\"></a>Component 搭桥</h3><h4 id=\"手写代码-1\"><a href=\"#手写代码-1\" class=\"headerlink\" title=\"手写代码\"></a>手写代码</h4><pre><code>@Component\ninterface ManComponent {\n    fun inject(man: Man)\n}\n</code></pre><p>此时build之后会生成一些代码 比如<code>DaggerManComponent</code> 约定多了一个<code>Dagger</code>前缀</p>\n<h4 id=\"生成代码\"><a href=\"#生成代码\" class=\"headerlink\" title=\"生成代码\"></a>生成代码</h4><pre><code>public final class DaggerManComponent implements ManComponent {\n  private DaggerManComponent(Builder builder) {}\n\n  public static Builder builder() {\n    return new Builder();\n  }\n\n  public static ManComponent create() {\n    return new Builder().build();\n  }\n\n  @Override\n  public void inject(Man man) {\n    injectMan(man);\n  }\n\n  private Man injectMan(Man instance) {\n    Man_MembersInjector.injectSetCar(instance, new Car());\n    return instance;\n  }\n\n  public static final class Builder {\n    private Builder() {}\n\n    public ManComponent build() {\n      return new DaggerManComponent(this);\n    }\n  }\n}\n</code></pre><p>调用的顺序似乎是 <code>create()</code> -&gt; <code>inject(Man man)</code><br>其中<br><strong><code>create() == Builder().build()</code></strong><br>而在<code>build()</code>方法中返回了一个<strong>DaggerManComponent</strong>实例，通过这个实例，来调用<code>inject()</code><br>而 <code>inject()</code>里面调用的是<br><strong><code>Man_MembersInjector.injectSetCar(instance, new Car());</code></strong><br>最后返回<strong>instance</strong> 也就是传进来的<strong>Man</strong></p>\n<p>其他都没啥 ，关键是<strong><code>Man_MembersInjector.injectSetCar(instance, new Car());</code></strong><br>而这方法应该是Man(使用注入对象的Man所生成的代码)<br>猜测是将<code>new Car()</code>对象赋值到了<code>instance</code>中<br><strong>继续看下面</strong></p>\n<h3 id=\"完成注入\"><a href=\"#完成注入\" class=\"headerlink\" title=\"完成注入\"></a>完成注入</h3><h4 id=\"手写代码-2\"><a href=\"#手写代码-2\" class=\"headerlink\" title=\"手写代码\"></a>手写代码</h4><p>最后成功输出了<strong><code>com.zcy.mydagger.Car@6ff3c5b5</code></strong></p>\n<pre><code>class Man {\n    init {\n        DaggerManComponent.create().inject(this)\n    }\n\n    lateinit var car: Car\n        @Inject set\n\n    fun a() {\n        println(car)\n    }\n\n\n}\n\nfun main(args: Array&lt;String&gt;) {\n    println(Man().a())\n}\n</code></pre><h4 id=\"生成的代码-1\"><a href=\"#生成的代码-1\" class=\"headerlink\" title=\"生成的代码\"></a>生成的代码</h4><pre><code>public final class Man_MembersInjector implements MembersInjector&lt;Man&gt; {\n  private final Provider&lt;Car&gt; p0Provider;\n\n  public Man_MembersInjector(Provider&lt;Car&gt; p0Provider) {\n    this.p0Provider = p0Provider;\n  }\n\n  public static MembersInjector&lt;Man&gt; create(Provider&lt;Car&gt; p0Provider) {\n    return new Man_MembersInjector(p0Provider);\n  }\n\n  @Override\n  public void injectMembers(Man instance) {\n    injectSetCar(instance, p0Provider.get());\n  }\n\n  public static void injectSetCar(Man instance, Car p0) {\n    instance.setCar(p0);\n  }\n}\n\n</code></pre><p>此处正好证实了上面的猜想，<strong><code>injectSetCar</code></strong> 方法中 <code>instance.setCar(p0);</code>正好是将<strong>car</strong>这个属性进行赋值，恰好就是我们<strong>component</strong>中的<code>new car()</code></p>\n<p>简单的代码分析就酱</p>"},{"title":"RecyclerView.ItemDecoration() 的用法与技巧","date":"2018-12-18T10:06:32.000Z","_content":"## ItemDecoration\n\nAs we all know but how to use\n\n#### 主要明白其中**重写的三个方法**\n分别是：  \n`getItemOffsets`只负责规定绘制区域  \n`onDrawOver`负责绘制，显示在Item视图之上  \n`onDraw`负责绘制，显示在Item视图之下  \n\n<!--more-->\n\n```\nNo.1\n通过设置outRect 来实现Item分割线的绘制范围\n\noverride fun getItemOffsets(outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State?) {\n    super.getItemOffsets(outRect, view, parent, state)\n    outRect.set(Rect(0, margin, 0, 0))\n}\n\n```\n设置Item的偏移量 也就是绘制的分割线范围[在这里](https://juejin.im/post/59099fe844d904006942a983)  \n\n\n#### 参数解析\n\n```\n* @param outRect Rect to receive the output.\n* @param view    The child view to decorate\n* @param parent  RecyclerView this ItemDecoration is decorating\n* @param state   The current state of RecyclerView.\n```\n#### 如果我想指定分割线在第一个Item的上面绘制，第二个Item的下面绘制，其他的Item不绘制\n\n```\noverride fun getItemOffsets(outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State?) {\n\tsuper.getItemOffsets(outRect, view, parent, state)\n\tval childAdapterPosition = parent.getChildAdapterPosition(view)\n\twhen (childAdapterPosition) {\n\t    0 -> outRect.set(Rect(0, margin, 0, 0))\n\t    1 -> outRect.set(Rect(0, 0, 0, margin))\n\t    else -> outRect.set(Rect())\n\t}\n}\n```\n\n**注意!!**，如果想在这个方法中通过`parent.childCount`来获取到子view的数量，是**不可以**的，我觉得是因为addView的时候就已经走到了`getItemOffsets `这个方法，所以结果就是**第一次**走到这个方法的时候`parent.childCount`就是**1**，**第二次**走到这个方法的时候`parent.childCount`就是**2**。\n\n\n```\nNo.2 会被Item视图覆盖掉\n\noverride fun onDraw(c: Canvas?, parent: RecyclerView?, state: RecyclerView.State?) {\n    super.onDraw(c, parent, state)\n}\n```\n \n#### 参数解析 下同\n```\n* @param c Canvas to draw into\n* @param parent RecyclerView this ItemDecoration is drawing into\n* @param state The current state of RecyclerView\n```\n\n这样就**仅仅是**在第二个Item上画了一个底部分割线 \n\n```\nNo.3 将覆盖Item视图\n\noverride fun onDrawOver(canvas: Canvas?, parent: RecyclerView?, state: RecyclerView.State?) {\n    if (parent == null || null == canvas) {\n        return\n    }\n    val index = parent.childCount - 2\n    val child = parent.getChildAt(index)\n    val left = 0f\n    val right = child.right.toFloat()\n    val top = (child.bottom - offset).toFloat()\n    val bottom = child.bottom.toFloat()\n    val rect = RectF(left, top, right, bottom)\n    canvas.drawRect(rect, paint.apply { color = color })\n}\n```","source":"_posts/decoration.md","raw":"---\ntitle: RecyclerView.ItemDecoration() 的用法与技巧\ndate: 2018-12-18 18:06:32\ncategory: 技术\ntags: android\n---\n## ItemDecoration\n\nAs we all know but how to use\n\n#### 主要明白其中**重写的三个方法**\n分别是：  \n`getItemOffsets`只负责规定绘制区域  \n`onDrawOver`负责绘制，显示在Item视图之上  \n`onDraw`负责绘制，显示在Item视图之下  \n\n<!--more-->\n\n```\nNo.1\n通过设置outRect 来实现Item分割线的绘制范围\n\noverride fun getItemOffsets(outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State?) {\n    super.getItemOffsets(outRect, view, parent, state)\n    outRect.set(Rect(0, margin, 0, 0))\n}\n\n```\n设置Item的偏移量 也就是绘制的分割线范围[在这里](https://juejin.im/post/59099fe844d904006942a983)  \n\n\n#### 参数解析\n\n```\n* @param outRect Rect to receive the output.\n* @param view    The child view to decorate\n* @param parent  RecyclerView this ItemDecoration is decorating\n* @param state   The current state of RecyclerView.\n```\n#### 如果我想指定分割线在第一个Item的上面绘制，第二个Item的下面绘制，其他的Item不绘制\n\n```\noverride fun getItemOffsets(outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State?) {\n\tsuper.getItemOffsets(outRect, view, parent, state)\n\tval childAdapterPosition = parent.getChildAdapterPosition(view)\n\twhen (childAdapterPosition) {\n\t    0 -> outRect.set(Rect(0, margin, 0, 0))\n\t    1 -> outRect.set(Rect(0, 0, 0, margin))\n\t    else -> outRect.set(Rect())\n\t}\n}\n```\n\n**注意!!**，如果想在这个方法中通过`parent.childCount`来获取到子view的数量，是**不可以**的，我觉得是因为addView的时候就已经走到了`getItemOffsets `这个方法，所以结果就是**第一次**走到这个方法的时候`parent.childCount`就是**1**，**第二次**走到这个方法的时候`parent.childCount`就是**2**。\n\n\n```\nNo.2 会被Item视图覆盖掉\n\noverride fun onDraw(c: Canvas?, parent: RecyclerView?, state: RecyclerView.State?) {\n    super.onDraw(c, parent, state)\n}\n```\n \n#### 参数解析 下同\n```\n* @param c Canvas to draw into\n* @param parent RecyclerView this ItemDecoration is drawing into\n* @param state The current state of RecyclerView\n```\n\n这样就**仅仅是**在第二个Item上画了一个底部分割线 \n\n```\nNo.3 将覆盖Item视图\n\noverride fun onDrawOver(canvas: Canvas?, parent: RecyclerView?, state: RecyclerView.State?) {\n    if (parent == null || null == canvas) {\n        return\n    }\n    val index = parent.childCount - 2\n    val child = parent.getChildAt(index)\n    val left = 0f\n    val right = child.right.toFloat()\n    val top = (child.bottom - offset).toFloat()\n    val bottom = child.bottom.toFloat()\n    val rect = RectF(left, top, right, bottom)\n    canvas.drawRect(rect, paint.apply { color = color })\n}\n```","slug":"decoration","published":1,"updated":"2019-02-28T09:06:54.679Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf11s00155l261uw1u0af","content":"<h2 id=\"ItemDecoration\"><a href=\"#ItemDecoration\" class=\"headerlink\" title=\"ItemDecoration\"></a>ItemDecoration</h2><p>As we all know but how to use</p>\n<h4 id=\"主要明白其中重写的三个方法\"><a href=\"#主要明白其中重写的三个方法\" class=\"headerlink\" title=\"主要明白其中重写的三个方法\"></a>主要明白其中<strong>重写的三个方法</strong></h4><p>分别是：<br><code>getItemOffsets</code>只负责规定绘制区域<br><code>onDrawOver</code>负责绘制，显示在Item视图之上<br><code>onDraw</code>负责绘制，显示在Item视图之下  </p>\n<a id=\"more\"></a>\n<pre><code>No.1\n通过设置outRect 来实现Item分割线的绘制范围\n\noverride fun getItemOffsets(outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State?) {\n    super.getItemOffsets(outRect, view, parent, state)\n    outRect.set(Rect(0, margin, 0, 0))\n}\n\n</code></pre><p>设置Item的偏移量 也就是绘制的分割线范围<a href=\"https://juejin.im/post/59099fe844d904006942a983\" target=\"_blank\" rel=\"noopener\">在这里</a>  </p>\n<h4 id=\"参数解析\"><a href=\"#参数解析\" class=\"headerlink\" title=\"参数解析\"></a>参数解析</h4><pre><code>* @param outRect Rect to receive the output.\n* @param view    The child view to decorate\n* @param parent  RecyclerView this ItemDecoration is decorating\n* @param state   The current state of RecyclerView.\n</code></pre><h4 id=\"如果我想指定分割线在第一个Item的上面绘制，第二个Item的下面绘制，其他的Item不绘制\"><a href=\"#如果我想指定分割线在第一个Item的上面绘制，第二个Item的下面绘制，其他的Item不绘制\" class=\"headerlink\" title=\"如果我想指定分割线在第一个Item的上面绘制，第二个Item的下面绘制，其他的Item不绘制\"></a>如果我想指定分割线在第一个Item的上面绘制，第二个Item的下面绘制，其他的Item不绘制</h4><pre><code>override fun getItemOffsets(outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State?) {\n    super.getItemOffsets(outRect, view, parent, state)\n    val childAdapterPosition = parent.getChildAdapterPosition(view)\n    when (childAdapterPosition) {\n        0 -&gt; outRect.set(Rect(0, margin, 0, 0))\n        1 -&gt; outRect.set(Rect(0, 0, 0, margin))\n        else -&gt; outRect.set(Rect())\n    }\n}\n</code></pre><p><strong>注意!!</strong>，如果想在这个方法中通过<code>parent.childCount</code>来获取到子view的数量，是<strong>不可以</strong>的，我觉得是因为addView的时候就已经走到了<code>getItemOffsets</code>这个方法，所以结果就是<strong>第一次</strong>走到这个方法的时候<code>parent.childCount</code>就是<strong>1</strong>，<strong>第二次</strong>走到这个方法的时候<code>parent.childCount</code>就是<strong>2</strong>。</p>\n<pre><code>No.2 会被Item视图覆盖掉\n\noverride fun onDraw(c: Canvas?, parent: RecyclerView?, state: RecyclerView.State?) {\n    super.onDraw(c, parent, state)\n}\n</code></pre><h4 id=\"参数解析-下同\"><a href=\"#参数解析-下同\" class=\"headerlink\" title=\"参数解析 下同\"></a>参数解析 下同</h4><pre><code>* @param c Canvas to draw into\n* @param parent RecyclerView this ItemDecoration is drawing into\n* @param state The current state of RecyclerView\n</code></pre><p>这样就<strong>仅仅是</strong>在第二个Item上画了一个底部分割线 </p>\n<pre><code>No.3 将覆盖Item视图\n\noverride fun onDrawOver(canvas: Canvas?, parent: RecyclerView?, state: RecyclerView.State?) {\n    if (parent == null || null == canvas) {\n        return\n    }\n    val index = parent.childCount - 2\n    val child = parent.getChildAt(index)\n    val left = 0f\n    val right = child.right.toFloat()\n    val top = (child.bottom - offset).toFloat()\n    val bottom = child.bottom.toFloat()\n    val rect = RectF(left, top, right, bottom)\n    canvas.drawRect(rect, paint.apply { color = color })\n}\n</code></pre>","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"<h2 id=\"ItemDecoration\"><a href=\"#ItemDecoration\" class=\"headerlink\" title=\"ItemDecoration\"></a>ItemDecoration</h2><p>As we all know but how to use</p>\n<h4 id=\"主要明白其中重写的三个方法\"><a href=\"#主要明白其中重写的三个方法\" class=\"headerlink\" title=\"主要明白其中重写的三个方法\"></a>主要明白其中<strong>重写的三个方法</strong></h4><p>分别是：<br><code>getItemOffsets</code>只负责规定绘制区域<br><code>onDrawOver</code>负责绘制，显示在Item视图之上<br><code>onDraw</code>负责绘制，显示在Item视图之下  </p>","more":"<pre><code>No.1\n通过设置outRect 来实现Item分割线的绘制范围\n\noverride fun getItemOffsets(outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State?) {\n    super.getItemOffsets(outRect, view, parent, state)\n    outRect.set(Rect(0, margin, 0, 0))\n}\n\n</code></pre><p>设置Item的偏移量 也就是绘制的分割线范围<a href=\"https://juejin.im/post/59099fe844d904006942a983\" target=\"_blank\" rel=\"noopener\">在这里</a>  </p>\n<h4 id=\"参数解析\"><a href=\"#参数解析\" class=\"headerlink\" title=\"参数解析\"></a>参数解析</h4><pre><code>* @param outRect Rect to receive the output.\n* @param view    The child view to decorate\n* @param parent  RecyclerView this ItemDecoration is decorating\n* @param state   The current state of RecyclerView.\n</code></pre><h4 id=\"如果我想指定分割线在第一个Item的上面绘制，第二个Item的下面绘制，其他的Item不绘制\"><a href=\"#如果我想指定分割线在第一个Item的上面绘制，第二个Item的下面绘制，其他的Item不绘制\" class=\"headerlink\" title=\"如果我想指定分割线在第一个Item的上面绘制，第二个Item的下面绘制，其他的Item不绘制\"></a>如果我想指定分割线在第一个Item的上面绘制，第二个Item的下面绘制，其他的Item不绘制</h4><pre><code>override fun getItemOffsets(outRect: Rect, view: View, parent: RecyclerView, state: RecyclerView.State?) {\n    super.getItemOffsets(outRect, view, parent, state)\n    val childAdapterPosition = parent.getChildAdapterPosition(view)\n    when (childAdapterPosition) {\n        0 -&gt; outRect.set(Rect(0, margin, 0, 0))\n        1 -&gt; outRect.set(Rect(0, 0, 0, margin))\n        else -&gt; outRect.set(Rect())\n    }\n}\n</code></pre><p><strong>注意!!</strong>，如果想在这个方法中通过<code>parent.childCount</code>来获取到子view的数量，是<strong>不可以</strong>的，我觉得是因为addView的时候就已经走到了<code>getItemOffsets</code>这个方法，所以结果就是<strong>第一次</strong>走到这个方法的时候<code>parent.childCount</code>就是<strong>1</strong>，<strong>第二次</strong>走到这个方法的时候<code>parent.childCount</code>就是<strong>2</strong>。</p>\n<pre><code>No.2 会被Item视图覆盖掉\n\noverride fun onDraw(c: Canvas?, parent: RecyclerView?, state: RecyclerView.State?) {\n    super.onDraw(c, parent, state)\n}\n</code></pre><h4 id=\"参数解析-下同\"><a href=\"#参数解析-下同\" class=\"headerlink\" title=\"参数解析 下同\"></a>参数解析 下同</h4><pre><code>* @param c Canvas to draw into\n* @param parent RecyclerView this ItemDecoration is drawing into\n* @param state The current state of RecyclerView\n</code></pre><p>这样就<strong>仅仅是</strong>在第二个Item上画了一个底部分割线 </p>\n<pre><code>No.3 将覆盖Item视图\n\noverride fun onDrawOver(canvas: Canvas?, parent: RecyclerView?, state: RecyclerView.State?) {\n    if (parent == null || null == canvas) {\n        return\n    }\n    val index = parent.childCount - 2\n    val child = parent.getChildAt(index)\n    val left = 0f\n    val right = child.right.toFloat()\n    val top = (child.bottom - offset).toFloat()\n    val bottom = child.bottom.toFloat()\n    val rect = RectF(left, top, right, bottom)\n    canvas.drawRect(rect, paint.apply { color = color })\n}\n</code></pre>"},{"title":"DataBinding & MVVM","date":"2019-02-11T08:18:01.000Z","_content":"\n### DataBinding\n\n\n因为DataBinding相关的Gradle默认是不开启的，但是确实存在系统中，所以手动去打开它。  \n在app的目录下面 **`android{}`**里面加上这句开启命令。\n\n```\ndataBinding {\n    enabled = true\n}\n```\n<!--more-->\n#### 简单的例子\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <data>\n        <variable\n            name=\"person\"\n            type=\"com.zcy.nidavellir.mydatabinding.Person\" />\n    </data>\n    <LinearLayout\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"vertical\">\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@{person.name}\" />\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@{person.age}\" />\n    </LinearLayout>\n</layout>\n```\n\n定义了一个形式变量**`person`** 然后可以在view中直接引用。\n\n```\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        val binding = DataBindingUtil.setContentView<com.zcy.nidavellir.mydatabinding.databinding.ActivityMainBinding>(this, R.layout.activity_main)\n        binding.person = Person(\"只是\",\"123\")\n    }\n}\n```\n这里使用了**`DataBindingUtil.setContentView`**来代替 `setContentView`\n\n而泛型中的`ActivityMainBinding` 则为xml文件名的大驼峰命名转换加上Binding组成。\n\n进而通过`binding`来赋值xml文件中的`person`变量\n\n非常的简洁 ヾ(=･ω･=)o  \n\n如果`person`有一个属性`val like: ObservableInt` 那么更改这个属性，会自动更新UI。\n\n```\nfun click(v: View) {\n\tperson.like.set(person.like.get() + 1)\n}\n```\n**注意！** 如果含有`ImageView`且引用了`R.drawable.xxx` 那么还需要在`data`标签中加上\n**`<import type=\"com.zcy.nidavellir.mydatabinding.R\"/>`**\n\n\n### MVVM\n\n#### Model层\n负责数据的存储、网络请求、数据库以及I/O操作\n#### View层\nView层做的仅仅和UI相关的工作，View层不做任何业务逻辑、不涉及操作数据、不处理数据、UI和数据严格的分开。\n#### ViewModel层\nViewModel 只做和业务逻辑和业务数据相关的事，不做任何和UI、控件相关的事\n\n\n#### 举栗子\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\n    <data>\n        <variable\n            name=\"person\"\n            type=\"com.zcy.nidavellir.mydatabinding.PersonViewModel\"/>\n    </data>\n\n    <LinearLayout\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"vertical\">\n\n        <TextView\n            android:id=\"@+id/asdf\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@{person.name}\" />\n\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@{Integer.toString(person.likes)}\" />\n\n        <Button\n            android:id=\"@+id/button\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:onClick=\"@{() -> person.onLike()}\"\n            android:text=\"+LIke\" />\n    </LinearLayout>\n</layout>\n```\n\n我们在这里面绑定了View与Model\n\n```\nval viewModel = ViewModelProvider.NewInstanceFactory().create(PersonViewModel::class.java)\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    val binding =\n        DataBindingUtil.setContentView<com.zcy.nidavellir.mydatabinding.databinding.ActivityMainBinding>(this, R.layout.activity_main)\n    binding.person = viewModel\n}\n```\n在Activity中去赋值xml中的参数变量\n\n***这里 AndroidX 中的ViewModelProvider 与 Support 中的ViewModelProvider 不太一样 ***\n\n```\nclass PersonViewModel : ViewModel() {\n    val name = ObservableField(\"Ada\")\n    val likes = ObservableInt(0)\n\n    fun onLike() {\n        likes.set(likes.get() + 1)\n    }\n}\n```\n最后在ViewModel中去处理点击事件","source":"_posts/databinding.md","raw":"---\ntitle: DataBinding & MVVM\ndate: 2019-02-11 16:18:01\ntags: jetpack\ncategories: 技术\n---\n\n### DataBinding\n\n\n因为DataBinding相关的Gradle默认是不开启的，但是确实存在系统中，所以手动去打开它。  \n在app的目录下面 **`android{}`**里面加上这句开启命令。\n\n```\ndataBinding {\n    enabled = true\n}\n```\n<!--more-->\n#### 简单的例子\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <data>\n        <variable\n            name=\"person\"\n            type=\"com.zcy.nidavellir.mydatabinding.Person\" />\n    </data>\n    <LinearLayout\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"vertical\">\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@{person.name}\" />\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@{person.age}\" />\n    </LinearLayout>\n</layout>\n```\n\n定义了一个形式变量**`person`** 然后可以在view中直接引用。\n\n```\nclass MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        val binding = DataBindingUtil.setContentView<com.zcy.nidavellir.mydatabinding.databinding.ActivityMainBinding>(this, R.layout.activity_main)\n        binding.person = Person(\"只是\",\"123\")\n    }\n}\n```\n这里使用了**`DataBindingUtil.setContentView`**来代替 `setContentView`\n\n而泛型中的`ActivityMainBinding` 则为xml文件名的大驼峰命名转换加上Binding组成。\n\n进而通过`binding`来赋值xml文件中的`person`变量\n\n非常的简洁 ヾ(=･ω･=)o  \n\n如果`person`有一个属性`val like: ObservableInt` 那么更改这个属性，会自动更新UI。\n\n```\nfun click(v: View) {\n\tperson.like.set(person.like.get() + 1)\n}\n```\n**注意！** 如果含有`ImageView`且引用了`R.drawable.xxx` 那么还需要在`data`标签中加上\n**`<import type=\"com.zcy.nidavellir.mydatabinding.R\"/>`**\n\n\n### MVVM\n\n#### Model层\n负责数据的存储、网络请求、数据库以及I/O操作\n#### View层\nView层做的仅仅和UI相关的工作，View层不做任何业务逻辑、不涉及操作数据、不处理数据、UI和数据严格的分开。\n#### ViewModel层\nViewModel 只做和业务逻辑和业务数据相关的事，不做任何和UI、控件相关的事\n\n\n#### 举栗子\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<layout xmlns:android=\"http://schemas.android.com/apk/res/android\">\n\n    <data>\n        <variable\n            name=\"person\"\n            type=\"com.zcy.nidavellir.mydatabinding.PersonViewModel\"/>\n    </data>\n\n    <LinearLayout\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:orientation=\"vertical\">\n\n        <TextView\n            android:id=\"@+id/asdf\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@{person.name}\" />\n\n        <TextView\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"@{Integer.toString(person.likes)}\" />\n\n        <Button\n            android:id=\"@+id/button\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:onClick=\"@{() -> person.onLike()}\"\n            android:text=\"+LIke\" />\n    </LinearLayout>\n</layout>\n```\n\n我们在这里面绑定了View与Model\n\n```\nval viewModel = ViewModelProvider.NewInstanceFactory().create(PersonViewModel::class.java)\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    val binding =\n        DataBindingUtil.setContentView<com.zcy.nidavellir.mydatabinding.databinding.ActivityMainBinding>(this, R.layout.activity_main)\n    binding.person = viewModel\n}\n```\n在Activity中去赋值xml中的参数变量\n\n***这里 AndroidX 中的ViewModelProvider 与 Support 中的ViewModelProvider 不太一样 ***\n\n```\nclass PersonViewModel : ViewModel() {\n    val name = ObservableField(\"Ada\")\n    val likes = ObservableInt(0)\n\n    fun onLike() {\n        likes.set(likes.get() + 1)\n    }\n}\n```\n最后在ViewModel中去处理点击事件","slug":"databinding","published":1,"updated":"2019-02-28T09:06:46.707Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf11t00175l26pzkoqtj1","content":"<h3 id=\"DataBinding\"><a href=\"#DataBinding\" class=\"headerlink\" title=\"DataBinding\"></a>DataBinding</h3><p>因为DataBinding相关的Gradle默认是不开启的，但是确实存在系统中，所以手动去打开它。<br>在app的目录下面 <strong><code>android{}</code></strong>里面加上这句开启命令。</p>\n<pre><code>dataBinding {\n    enabled = true\n}\n</code></pre><a id=\"more\"></a>\n<h4 id=\"简单的例子\"><a href=\"#简单的例子\" class=\"headerlink\" title=\"简单的例子\"></a>简单的例子</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;\n    &lt;data&gt;\n        &lt;variable\n            name=&quot;person&quot;\n            type=&quot;com.zcy.nidavellir.mydatabinding.Person&quot; /&gt;\n    &lt;/data&gt;\n    &lt;LinearLayout\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:orientation=&quot;vertical&quot;&gt;\n        &lt;TextView\n            android:layout_width=&quot;wrap_content&quot;\n            android:layout_height=&quot;wrap_content&quot;\n            android:text=&quot;@{person.name}&quot; /&gt;\n        &lt;TextView\n            android:layout_width=&quot;wrap_content&quot;\n            android:layout_height=&quot;wrap_content&quot;\n            android:text=&quot;@{person.age}&quot; /&gt;\n    &lt;/LinearLayout&gt;\n&lt;/layout&gt;\n</code></pre><p>定义了一个形式变量<strong><code>person</code></strong> 然后可以在view中直接引用。</p>\n<pre><code>class MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        val binding = DataBindingUtil.setContentView&lt;com.zcy.nidavellir.mydatabinding.databinding.ActivityMainBinding&gt;(this, R.layout.activity_main)\n        binding.person = Person(&quot;只是&quot;,&quot;123&quot;)\n    }\n}\n</code></pre><p>这里使用了<strong><code>DataBindingUtil.setContentView</code></strong>来代替 <code>setContentView</code></p>\n<p>而泛型中的<code>ActivityMainBinding</code> 则为xml文件名的大驼峰命名转换加上Binding组成。</p>\n<p>进而通过<code>binding</code>来赋值xml文件中的<code>person</code>变量</p>\n<p>非常的简洁 ヾ(=･ω･=)o  </p>\n<p>如果<code>person</code>有一个属性<code>val like: ObservableInt</code> 那么更改这个属性，会自动更新UI。</p>\n<pre><code>fun click(v: View) {\n    person.like.set(person.like.get() + 1)\n}\n</code></pre><p><strong>注意！</strong> 如果含有<code>ImageView</code>且引用了<code>R.drawable.xxx</code> 那么还需要在<code>data</code>标签中加上<br><strong><code>&lt;import type=&quot;com.zcy.nidavellir.mydatabinding.R&quot;/&gt;</code></strong></p>\n<h3 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h3><h4 id=\"Model层\"><a href=\"#Model层\" class=\"headerlink\" title=\"Model层\"></a>Model层</h4><p>负责数据的存储、网络请求、数据库以及I/O操作</p>\n<h4 id=\"View层\"><a href=\"#View层\" class=\"headerlink\" title=\"View层\"></a>View层</h4><p>View层做的仅仅和UI相关的工作，View层不做任何业务逻辑、不涉及操作数据、不处理数据、UI和数据严格的分开。</p>\n<h4 id=\"ViewModel层\"><a href=\"#ViewModel层\" class=\"headerlink\" title=\"ViewModel层\"></a>ViewModel层</h4><p>ViewModel 只做和业务逻辑和业务数据相关的事，不做任何和UI、控件相关的事</p>\n<h4 id=\"举栗子\"><a href=\"#举栗子\" class=\"headerlink\" title=\"举栗子\"></a>举栗子</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;\n\n    &lt;data&gt;\n        &lt;variable\n            name=&quot;person&quot;\n            type=&quot;com.zcy.nidavellir.mydatabinding.PersonViewModel&quot;/&gt;\n    &lt;/data&gt;\n\n    &lt;LinearLayout\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:orientation=&quot;vertical&quot;&gt;\n\n        &lt;TextView\n            android:id=&quot;@+id/asdf&quot;\n            android:layout_width=&quot;wrap_content&quot;\n            android:layout_height=&quot;wrap_content&quot;\n            android:text=&quot;@{person.name}&quot; /&gt;\n\n        &lt;TextView\n            android:layout_width=&quot;wrap_content&quot;\n            android:layout_height=&quot;wrap_content&quot;\n            android:text=&quot;@{Integer.toString(person.likes)}&quot; /&gt;\n\n        &lt;Button\n            android:id=&quot;@+id/button&quot;\n            android:layout_width=&quot;wrap_content&quot;\n            android:layout_height=&quot;wrap_content&quot;\n            android:onClick=&quot;@{() -&gt; person.onLike()}&quot;\n            android:text=&quot;+LIke&quot; /&gt;\n    &lt;/LinearLayout&gt;\n&lt;/layout&gt;\n</code></pre><p>我们在这里面绑定了View与Model</p>\n<pre><code>val viewModel = ViewModelProvider.NewInstanceFactory().create(PersonViewModel::class.java)\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    val binding =\n        DataBindingUtil.setContentView&lt;com.zcy.nidavellir.mydatabinding.databinding.ActivityMainBinding&gt;(this, R.layout.activity_main)\n    binding.person = viewModel\n}\n</code></pre><p>在Activity中去赋值xml中的参数变量</p>\n<p><strong><em>这里 AndroidX 中的ViewModelProvider 与 Support 中的ViewModelProvider 不太一样 </em></strong></p>\n<pre><code>class PersonViewModel : ViewModel() {\n    val name = ObservableField(&quot;Ada&quot;)\n    val likes = ObservableInt(0)\n\n    fun onLike() {\n        likes.set(likes.get() + 1)\n    }\n}\n</code></pre><p>最后在ViewModel中去处理点击事件</p>\n","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"<h3 id=\"DataBinding\"><a href=\"#DataBinding\" class=\"headerlink\" title=\"DataBinding\"></a>DataBinding</h3><p>因为DataBinding相关的Gradle默认是不开启的，但是确实存在系统中，所以手动去打开它。<br>在app的目录下面 <strong><code>android{}</code></strong>里面加上这句开启命令。</p>\n<pre><code>dataBinding {\n    enabled = true\n}\n</code></pre>","more":"<h4 id=\"简单的例子\"><a href=\"#简单的例子\" class=\"headerlink\" title=\"简单的例子\"></a>简单的例子</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;\n    &lt;data&gt;\n        &lt;variable\n            name=&quot;person&quot;\n            type=&quot;com.zcy.nidavellir.mydatabinding.Person&quot; /&gt;\n    &lt;/data&gt;\n    &lt;LinearLayout\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:orientation=&quot;vertical&quot;&gt;\n        &lt;TextView\n            android:layout_width=&quot;wrap_content&quot;\n            android:layout_height=&quot;wrap_content&quot;\n            android:text=&quot;@{person.name}&quot; /&gt;\n        &lt;TextView\n            android:layout_width=&quot;wrap_content&quot;\n            android:layout_height=&quot;wrap_content&quot;\n            android:text=&quot;@{person.age}&quot; /&gt;\n    &lt;/LinearLayout&gt;\n&lt;/layout&gt;\n</code></pre><p>定义了一个形式变量<strong><code>person</code></strong> 然后可以在view中直接引用。</p>\n<pre><code>class MainActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        val binding = DataBindingUtil.setContentView&lt;com.zcy.nidavellir.mydatabinding.databinding.ActivityMainBinding&gt;(this, R.layout.activity_main)\n        binding.person = Person(&quot;只是&quot;,&quot;123&quot;)\n    }\n}\n</code></pre><p>这里使用了<strong><code>DataBindingUtil.setContentView</code></strong>来代替 <code>setContentView</code></p>\n<p>而泛型中的<code>ActivityMainBinding</code> 则为xml文件名的大驼峰命名转换加上Binding组成。</p>\n<p>进而通过<code>binding</code>来赋值xml文件中的<code>person</code>变量</p>\n<p>非常的简洁 ヾ(=･ω･=)o  </p>\n<p>如果<code>person</code>有一个属性<code>val like: ObservableInt</code> 那么更改这个属性，会自动更新UI。</p>\n<pre><code>fun click(v: View) {\n    person.like.set(person.like.get() + 1)\n}\n</code></pre><p><strong>注意！</strong> 如果含有<code>ImageView</code>且引用了<code>R.drawable.xxx</code> 那么还需要在<code>data</code>标签中加上<br><strong><code>&lt;import type=&quot;com.zcy.nidavellir.mydatabinding.R&quot;/&gt;</code></strong></p>\n<h3 id=\"MVVM\"><a href=\"#MVVM\" class=\"headerlink\" title=\"MVVM\"></a>MVVM</h3><h4 id=\"Model层\"><a href=\"#Model层\" class=\"headerlink\" title=\"Model层\"></a>Model层</h4><p>负责数据的存储、网络请求、数据库以及I/O操作</p>\n<h4 id=\"View层\"><a href=\"#View层\" class=\"headerlink\" title=\"View层\"></a>View层</h4><p>View层做的仅仅和UI相关的工作，View层不做任何业务逻辑、不涉及操作数据、不处理数据、UI和数据严格的分开。</p>\n<h4 id=\"ViewModel层\"><a href=\"#ViewModel层\" class=\"headerlink\" title=\"ViewModel层\"></a>ViewModel层</h4><p>ViewModel 只做和业务逻辑和业务数据相关的事，不做任何和UI、控件相关的事</p>\n<h4 id=\"举栗子\"><a href=\"#举栗子\" class=\"headerlink\" title=\"举栗子\"></a>举栗子</h4><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;\n&lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;\n\n    &lt;data&gt;\n        &lt;variable\n            name=&quot;person&quot;\n            type=&quot;com.zcy.nidavellir.mydatabinding.PersonViewModel&quot;/&gt;\n    &lt;/data&gt;\n\n    &lt;LinearLayout\n        android:layout_width=&quot;wrap_content&quot;\n        android:layout_height=&quot;wrap_content&quot;\n        android:orientation=&quot;vertical&quot;&gt;\n\n        &lt;TextView\n            android:id=&quot;@+id/asdf&quot;\n            android:layout_width=&quot;wrap_content&quot;\n            android:layout_height=&quot;wrap_content&quot;\n            android:text=&quot;@{person.name}&quot; /&gt;\n\n        &lt;TextView\n            android:layout_width=&quot;wrap_content&quot;\n            android:layout_height=&quot;wrap_content&quot;\n            android:text=&quot;@{Integer.toString(person.likes)}&quot; /&gt;\n\n        &lt;Button\n            android:id=&quot;@+id/button&quot;\n            android:layout_width=&quot;wrap_content&quot;\n            android:layout_height=&quot;wrap_content&quot;\n            android:onClick=&quot;@{() -&gt; person.onLike()}&quot;\n            android:text=&quot;+LIke&quot; /&gt;\n    &lt;/LinearLayout&gt;\n&lt;/layout&gt;\n</code></pre><p>我们在这里面绑定了View与Model</p>\n<pre><code>val viewModel = ViewModelProvider.NewInstanceFactory().create(PersonViewModel::class.java)\noverride fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    val binding =\n        DataBindingUtil.setContentView&lt;com.zcy.nidavellir.mydatabinding.databinding.ActivityMainBinding&gt;(this, R.layout.activity_main)\n    binding.person = viewModel\n}\n</code></pre><p>在Activity中去赋值xml中的参数变量</p>\n<p><strong><em>这里 AndroidX 中的ViewModelProvider 与 Support 中的ViewModelProvider 不太一样 </em></strong></p>\n<pre><code>class PersonViewModel : ViewModel() {\n    val name = ObservableField(&quot;Ada&quot;)\n    val likes = ObservableInt(0)\n\n    fun onLike() {\n        likes.set(likes.get() + 1)\n    }\n}\n</code></pre><p>最后在ViewModel中去处理点击事件</p>"},{"title":"DSL风格代替Builder模式 fancyDialog","date":"2019-01-08T09:47:15.000Z","top":true,"_content":"\n# FancyDialog\n## DSL风格代替Builder模式\n\n### 什么是DSL\ndomain specific language / DSL  \nJava使用Builder来构建复杂对象。  \n而Kotlin配合lambad 使用DSL风格 将使复杂对象的构建更加可读，更清晰，更简洁\n\n首先我们要明白`lambda`的几个特性\n\n* 如果`lambda`是函数的最后一个参数，可以放在**括号外面**\n* 如果`lambda`是函数的唯一参数，它可以放在**括号外面**并且**省略括号**\n* 指定接收者的`lambda`\n\n通过`apply(block)` 来配置dialog所需要的参数。而不需要通过不断的`.setXXX`来设置\n\n例如\n\n```\n//  DSL style\ninline fun askDialog(fragmentManager: FragmentManager, dsl: AskDialog.() -> Unit) {\n    AskDialog.newInstance().apply(dsl).show(fragmentManager, \"dialog\")\n}\n```\n使用姿势\n\n```\naskDialog(supportFragmentManager) {\n    mTitle = \"标题\"\n    mMessage = \"内容\"\n}\n```\n下面提供几种常见的dialog使用形式\n\n<!--more-->\n\n### askDialog\n#### normal\n```\naskDialog(supportFragmentManager) {\n    mTitle = \"标题\"\n    sureClick {\n        Toast.makeText(this@MainActivity, \"sure\", Toast.LENGTH_SHORT).show()\n    }\n    cancelClick {\n        Toast.makeText(this@MainActivity, \"cancel\", Toast.LENGTH_SHORT).show()\n    }\n}\n```\n<img src=\"https://raw.githubusercontent.com/o0o0oo00/FancyDialog/master/mdimage/S90102-163051.jpg\" width=\"20%\" height=\"20%\">\n\n#### onlySure\n```\naskDialog(supportFragmentManager) {\n    mTitle = \"标题\"\n    mMessage = \"摘要vv摘要摘要摘要摘要摘要\"\n    mGravity = Gravity.TOP\n    onlySure = true\n    sureClick {\n        Toast.makeText(this@MainActivity, \"sure\", Toast.LENGTH_SHORT).show()\n    }\n}\n```\n\n<img src=\"https://raw.githubusercontent.com/o0o0oo00/FancyDialog/master/mdimage/S90102-163103.jpg\" width=\"20%\" height=\"20%\">\n\n### askMoreDialog\n```\naskMoreDialog(supportFragmentManager) {\n    mTitle = \"标题\"\n    mMessage = \"摘要vv摘要摘要摘要摘要摘要摘要vv摘要摘要摘要摘要摘要\"\n    mColor = Color.RED\n    sureClick(key = \"第一个\") {\n        Toast.makeText(this@MainActivity, \"第一个\", Toast.LENGTH_SHORT).show()\n    }\n    cancelClick(key = \"第二个\") {\n        Toast.makeText(this@MainActivity, \"第二个\", Toast.LENGTH_SHORT).show()\n    }\n    button3Clicks(key = \"第三个\", color = Color.GRAY) {\n        Toast.makeText(this@MainActivity, \"第三个\", Toast.LENGTH_SHORT).show()\n    }\n}\n```\n<img src=\"https://raw.githubusercontent.com/o0o0oo00/FancyDialog/master/mdimage/S90102-163121.jpg\" width=\"20%\" height=\"20%\">\n\n### editDialog\n```\neditDialog(supportFragmentManager) {\n    rightClick {\n        Toast.makeText(this@MainActivity, it, Toast.LENGTH_SHORT).show()\n    }\n}\n```\n<img src=\"https://raw.githubusercontent.com/o0o0oo00/FancyDialog/master/mdimage/S90102-163127.jpg\" width=\"20%\" height=\"20%\">\n\n### listDialog\n```\nlateinit var dialog: ListDialog\nval listener = object : ClickListener {\n    override fun onItemLongClick(position: Int, v: View) {\n\n    }\n\n    override fun onItemClick(position: Int, v: View) {\n        dialog.dismiss()\n        Toast.makeText(this@MainActivity, (v.tag as String), Toast.LENGTH_SHORT).show()\n    }\n\n}\ndialog = listDialog {\n    listSetting(listener) {\n        add(\"第一头条\")\n        add(\"第二头条\")\n        add(\"_(:з」∠)_\")\n    }\n}\ndialog.show(supportFragmentManager,\"dialog\")\n```\n<img src=\"https://raw.githubusercontent.com/o0o0oo00/FancyDialog/master/mdimage/S90108-153438.jpg\" width=\"20%\" height=\"20%\">\n### customDialog\n待续...\n","source":"_posts/fancyDialog.md","raw":"---\ntitle: DSL风格代替Builder模式 fancyDialog\ndate: 2019-01-08 17:47:15\ntags: alert\ncategory: 技术\ntop : true\n\n---\n\n# FancyDialog\n## DSL风格代替Builder模式\n\n### 什么是DSL\ndomain specific language / DSL  \nJava使用Builder来构建复杂对象。  \n而Kotlin配合lambad 使用DSL风格 将使复杂对象的构建更加可读，更清晰，更简洁\n\n首先我们要明白`lambda`的几个特性\n\n* 如果`lambda`是函数的最后一个参数，可以放在**括号外面**\n* 如果`lambda`是函数的唯一参数，它可以放在**括号外面**并且**省略括号**\n* 指定接收者的`lambda`\n\n通过`apply(block)` 来配置dialog所需要的参数。而不需要通过不断的`.setXXX`来设置\n\n例如\n\n```\n//  DSL style\ninline fun askDialog(fragmentManager: FragmentManager, dsl: AskDialog.() -> Unit) {\n    AskDialog.newInstance().apply(dsl).show(fragmentManager, \"dialog\")\n}\n```\n使用姿势\n\n```\naskDialog(supportFragmentManager) {\n    mTitle = \"标题\"\n    mMessage = \"内容\"\n}\n```\n下面提供几种常见的dialog使用形式\n\n<!--more-->\n\n### askDialog\n#### normal\n```\naskDialog(supportFragmentManager) {\n    mTitle = \"标题\"\n    sureClick {\n        Toast.makeText(this@MainActivity, \"sure\", Toast.LENGTH_SHORT).show()\n    }\n    cancelClick {\n        Toast.makeText(this@MainActivity, \"cancel\", Toast.LENGTH_SHORT).show()\n    }\n}\n```\n<img src=\"https://raw.githubusercontent.com/o0o0oo00/FancyDialog/master/mdimage/S90102-163051.jpg\" width=\"20%\" height=\"20%\">\n\n#### onlySure\n```\naskDialog(supportFragmentManager) {\n    mTitle = \"标题\"\n    mMessage = \"摘要vv摘要摘要摘要摘要摘要\"\n    mGravity = Gravity.TOP\n    onlySure = true\n    sureClick {\n        Toast.makeText(this@MainActivity, \"sure\", Toast.LENGTH_SHORT).show()\n    }\n}\n```\n\n<img src=\"https://raw.githubusercontent.com/o0o0oo00/FancyDialog/master/mdimage/S90102-163103.jpg\" width=\"20%\" height=\"20%\">\n\n### askMoreDialog\n```\naskMoreDialog(supportFragmentManager) {\n    mTitle = \"标题\"\n    mMessage = \"摘要vv摘要摘要摘要摘要摘要摘要vv摘要摘要摘要摘要摘要\"\n    mColor = Color.RED\n    sureClick(key = \"第一个\") {\n        Toast.makeText(this@MainActivity, \"第一个\", Toast.LENGTH_SHORT).show()\n    }\n    cancelClick(key = \"第二个\") {\n        Toast.makeText(this@MainActivity, \"第二个\", Toast.LENGTH_SHORT).show()\n    }\n    button3Clicks(key = \"第三个\", color = Color.GRAY) {\n        Toast.makeText(this@MainActivity, \"第三个\", Toast.LENGTH_SHORT).show()\n    }\n}\n```\n<img src=\"https://raw.githubusercontent.com/o0o0oo00/FancyDialog/master/mdimage/S90102-163121.jpg\" width=\"20%\" height=\"20%\">\n\n### editDialog\n```\neditDialog(supportFragmentManager) {\n    rightClick {\n        Toast.makeText(this@MainActivity, it, Toast.LENGTH_SHORT).show()\n    }\n}\n```\n<img src=\"https://raw.githubusercontent.com/o0o0oo00/FancyDialog/master/mdimage/S90102-163127.jpg\" width=\"20%\" height=\"20%\">\n\n### listDialog\n```\nlateinit var dialog: ListDialog\nval listener = object : ClickListener {\n    override fun onItemLongClick(position: Int, v: View) {\n\n    }\n\n    override fun onItemClick(position: Int, v: View) {\n        dialog.dismiss()\n        Toast.makeText(this@MainActivity, (v.tag as String), Toast.LENGTH_SHORT).show()\n    }\n\n}\ndialog = listDialog {\n    listSetting(listener) {\n        add(\"第一头条\")\n        add(\"第二头条\")\n        add(\"_(:з」∠)_\")\n    }\n}\ndialog.show(supportFragmentManager,\"dialog\")\n```\n<img src=\"https://raw.githubusercontent.com/o0o0oo00/FancyDialog/master/mdimage/S90108-153438.jpg\" width=\"20%\" height=\"20%\">\n### customDialog\n待续...\n","slug":"fancyDialog","published":1,"updated":"2019-02-28T09:56:14.806Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf11v001a5l26l6e2nct8","content":"<h1 id=\"FancyDialog\"><a href=\"#FancyDialog\" class=\"headerlink\" title=\"FancyDialog\"></a>FancyDialog</h1><h2 id=\"DSL风格代替Builder模式\"><a href=\"#DSL风格代替Builder模式\" class=\"headerlink\" title=\"DSL风格代替Builder模式\"></a>DSL风格代替Builder模式</h2><h3 id=\"什么是DSL\"><a href=\"#什么是DSL\" class=\"headerlink\" title=\"什么是DSL\"></a>什么是DSL</h3><p>domain specific language / DSL<br>Java使用Builder来构建复杂对象。<br>而Kotlin配合lambad 使用DSL风格 将使复杂对象的构建更加可读，更清晰，更简洁</p>\n<p>首先我们要明白<code>lambda</code>的几个特性</p>\n<ul>\n<li>如果<code>lambda</code>是函数的最后一个参数，可以放在<strong>括号外面</strong></li>\n<li>如果<code>lambda</code>是函数的唯一参数，它可以放在<strong>括号外面</strong>并且<strong>省略括号</strong></li>\n<li>指定接收者的<code>lambda</code></li>\n</ul>\n<p>通过<code>apply(block)</code> 来配置dialog所需要的参数。而不需要通过不断的<code>.setXXX</code>来设置</p>\n<p>例如</p>\n<pre><code>//  DSL style\ninline fun askDialog(fragmentManager: FragmentManager, dsl: AskDialog.() -&gt; Unit) {\n    AskDialog.newInstance().apply(dsl).show(fragmentManager, &quot;dialog&quot;)\n}\n</code></pre><p>使用姿势</p>\n<pre><code>askDialog(supportFragmentManager) {\n    mTitle = &quot;标题&quot;\n    mMessage = &quot;内容&quot;\n}\n</code></pre><p>下面提供几种常见的dialog使用形式</p>\n<a id=\"more\"></a>\n<h3 id=\"askDialog\"><a href=\"#askDialog\" class=\"headerlink\" title=\"askDialog\"></a>askDialog</h3><h4 id=\"normal\"><a href=\"#normal\" class=\"headerlink\" title=\"normal\"></a>normal</h4><pre><code>askDialog(supportFragmentManager) {\n    mTitle = &quot;标题&quot;\n    sureClick {\n        Toast.makeText(this@MainActivity, &quot;sure&quot;, Toast.LENGTH_SHORT).show()\n    }\n    cancelClick {\n        Toast.makeText(this@MainActivity, &quot;cancel&quot;, Toast.LENGTH_SHORT).show()\n    }\n}\n</code></pre><p><img src=\"https://raw.githubusercontent.com/o0o0oo00/FancyDialog/master/mdimage/S90102-163051.jpg\" width=\"20%\" height=\"20%\"></p>\n<h4 id=\"onlySure\"><a href=\"#onlySure\" class=\"headerlink\" title=\"onlySure\"></a>onlySure</h4><pre><code>askDialog(supportFragmentManager) {\n    mTitle = &quot;标题&quot;\n    mMessage = &quot;摘要vv摘要摘要摘要摘要摘要&quot;\n    mGravity = Gravity.TOP\n    onlySure = true\n    sureClick {\n        Toast.makeText(this@MainActivity, &quot;sure&quot;, Toast.LENGTH_SHORT).show()\n    }\n}\n</code></pre><p><img src=\"https://raw.githubusercontent.com/o0o0oo00/FancyDialog/master/mdimage/S90102-163103.jpg\" width=\"20%\" height=\"20%\"></p>\n<h3 id=\"askMoreDialog\"><a href=\"#askMoreDialog\" class=\"headerlink\" title=\"askMoreDialog\"></a>askMoreDialog</h3><pre><code>askMoreDialog(supportFragmentManager) {\n    mTitle = &quot;标题&quot;\n    mMessage = &quot;摘要vv摘要摘要摘要摘要摘要摘要vv摘要摘要摘要摘要摘要&quot;\n    mColor = Color.RED\n    sureClick(key = &quot;第一个&quot;) {\n        Toast.makeText(this@MainActivity, &quot;第一个&quot;, Toast.LENGTH_SHORT).show()\n    }\n    cancelClick(key = &quot;第二个&quot;) {\n        Toast.makeText(this@MainActivity, &quot;第二个&quot;, Toast.LENGTH_SHORT).show()\n    }\n    button3Clicks(key = &quot;第三个&quot;, color = Color.GRAY) {\n        Toast.makeText(this@MainActivity, &quot;第三个&quot;, Toast.LENGTH_SHORT).show()\n    }\n}\n</code></pre><p><img src=\"https://raw.githubusercontent.com/o0o0oo00/FancyDialog/master/mdimage/S90102-163121.jpg\" width=\"20%\" height=\"20%\"></p>\n<h3 id=\"editDialog\"><a href=\"#editDialog\" class=\"headerlink\" title=\"editDialog\"></a>editDialog</h3><pre><code>editDialog(supportFragmentManager) {\n    rightClick {\n        Toast.makeText(this@MainActivity, it, Toast.LENGTH_SHORT).show()\n    }\n}\n</code></pre><p><img src=\"https://raw.githubusercontent.com/o0o0oo00/FancyDialog/master/mdimage/S90102-163127.jpg\" width=\"20%\" height=\"20%\"></p>\n<h3 id=\"listDialog\"><a href=\"#listDialog\" class=\"headerlink\" title=\"listDialog\"></a>listDialog</h3><pre><code>lateinit var dialog: ListDialog\nval listener = object : ClickListener {\n    override fun onItemLongClick(position: Int, v: View) {\n\n    }\n\n    override fun onItemClick(position: Int, v: View) {\n        dialog.dismiss()\n        Toast.makeText(this@MainActivity, (v.tag as String), Toast.LENGTH_SHORT).show()\n    }\n\n}\ndialog = listDialog {\n    listSetting(listener) {\n        add(&quot;第一头条&quot;)\n        add(&quot;第二头条&quot;)\n        add(&quot;_(:з」∠)_&quot;)\n    }\n}\ndialog.show(supportFragmentManager,&quot;dialog&quot;)\n</code></pre><p><img src=\"https://raw.githubusercontent.com/o0o0oo00/FancyDialog/master/mdimage/S90108-153438.jpg\" width=\"20%\" height=\"20%\"></p>\n<h3 id=\"customDialog\"><a href=\"#customDialog\" class=\"headerlink\" title=\"customDialog\"></a>customDialog</h3><p>待续…</p>\n","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"<h1 id=\"FancyDialog\"><a href=\"#FancyDialog\" class=\"headerlink\" title=\"FancyDialog\"></a>FancyDialog</h1><h2 id=\"DSL风格代替Builder模式\"><a href=\"#DSL风格代替Builder模式\" class=\"headerlink\" title=\"DSL风格代替Builder模式\"></a>DSL风格代替Builder模式</h2><h3 id=\"什么是DSL\"><a href=\"#什么是DSL\" class=\"headerlink\" title=\"什么是DSL\"></a>什么是DSL</h3><p>domain specific language / DSL<br>Java使用Builder来构建复杂对象。<br>而Kotlin配合lambad 使用DSL风格 将使复杂对象的构建更加可读，更清晰，更简洁</p>\n<p>首先我们要明白<code>lambda</code>的几个特性</p>\n<ul>\n<li>如果<code>lambda</code>是函数的最后一个参数，可以放在<strong>括号外面</strong></li>\n<li>如果<code>lambda</code>是函数的唯一参数，它可以放在<strong>括号外面</strong>并且<strong>省略括号</strong></li>\n<li>指定接收者的<code>lambda</code></li>\n</ul>\n<p>通过<code>apply(block)</code> 来配置dialog所需要的参数。而不需要通过不断的<code>.setXXX</code>来设置</p>\n<p>例如</p>\n<pre><code>//  DSL style\ninline fun askDialog(fragmentManager: FragmentManager, dsl: AskDialog.() -&gt; Unit) {\n    AskDialog.newInstance().apply(dsl).show(fragmentManager, &quot;dialog&quot;)\n}\n</code></pre><p>使用姿势</p>\n<pre><code>askDialog(supportFragmentManager) {\n    mTitle = &quot;标题&quot;\n    mMessage = &quot;内容&quot;\n}\n</code></pre><p>下面提供几种常见的dialog使用形式</p>","more":"<h3 id=\"askDialog\"><a href=\"#askDialog\" class=\"headerlink\" title=\"askDialog\"></a>askDialog</h3><h4 id=\"normal\"><a href=\"#normal\" class=\"headerlink\" title=\"normal\"></a>normal</h4><pre><code>askDialog(supportFragmentManager) {\n    mTitle = &quot;标题&quot;\n    sureClick {\n        Toast.makeText(this@MainActivity, &quot;sure&quot;, Toast.LENGTH_SHORT).show()\n    }\n    cancelClick {\n        Toast.makeText(this@MainActivity, &quot;cancel&quot;, Toast.LENGTH_SHORT).show()\n    }\n}\n</code></pre><p><img src=\"https://raw.githubusercontent.com/o0o0oo00/FancyDialog/master/mdimage/S90102-163051.jpg\" width=\"20%\" height=\"20%\"></p>\n<h4 id=\"onlySure\"><a href=\"#onlySure\" class=\"headerlink\" title=\"onlySure\"></a>onlySure</h4><pre><code>askDialog(supportFragmentManager) {\n    mTitle = &quot;标题&quot;\n    mMessage = &quot;摘要vv摘要摘要摘要摘要摘要&quot;\n    mGravity = Gravity.TOP\n    onlySure = true\n    sureClick {\n        Toast.makeText(this@MainActivity, &quot;sure&quot;, Toast.LENGTH_SHORT).show()\n    }\n}\n</code></pre><p><img src=\"https://raw.githubusercontent.com/o0o0oo00/FancyDialog/master/mdimage/S90102-163103.jpg\" width=\"20%\" height=\"20%\"></p>\n<h3 id=\"askMoreDialog\"><a href=\"#askMoreDialog\" class=\"headerlink\" title=\"askMoreDialog\"></a>askMoreDialog</h3><pre><code>askMoreDialog(supportFragmentManager) {\n    mTitle = &quot;标题&quot;\n    mMessage = &quot;摘要vv摘要摘要摘要摘要摘要摘要vv摘要摘要摘要摘要摘要&quot;\n    mColor = Color.RED\n    sureClick(key = &quot;第一个&quot;) {\n        Toast.makeText(this@MainActivity, &quot;第一个&quot;, Toast.LENGTH_SHORT).show()\n    }\n    cancelClick(key = &quot;第二个&quot;) {\n        Toast.makeText(this@MainActivity, &quot;第二个&quot;, Toast.LENGTH_SHORT).show()\n    }\n    button3Clicks(key = &quot;第三个&quot;, color = Color.GRAY) {\n        Toast.makeText(this@MainActivity, &quot;第三个&quot;, Toast.LENGTH_SHORT).show()\n    }\n}\n</code></pre><p><img src=\"https://raw.githubusercontent.com/o0o0oo00/FancyDialog/master/mdimage/S90102-163121.jpg\" width=\"20%\" height=\"20%\"></p>\n<h3 id=\"editDialog\"><a href=\"#editDialog\" class=\"headerlink\" title=\"editDialog\"></a>editDialog</h3><pre><code>editDialog(supportFragmentManager) {\n    rightClick {\n        Toast.makeText(this@MainActivity, it, Toast.LENGTH_SHORT).show()\n    }\n}\n</code></pre><p><img src=\"https://raw.githubusercontent.com/o0o0oo00/FancyDialog/master/mdimage/S90102-163127.jpg\" width=\"20%\" height=\"20%\"></p>\n<h3 id=\"listDialog\"><a href=\"#listDialog\" class=\"headerlink\" title=\"listDialog\"></a>listDialog</h3><pre><code>lateinit var dialog: ListDialog\nval listener = object : ClickListener {\n    override fun onItemLongClick(position: Int, v: View) {\n\n    }\n\n    override fun onItemClick(position: Int, v: View) {\n        dialog.dismiss()\n        Toast.makeText(this@MainActivity, (v.tag as String), Toast.LENGTH_SHORT).show()\n    }\n\n}\ndialog = listDialog {\n    listSetting(listener) {\n        add(&quot;第一头条&quot;)\n        add(&quot;第二头条&quot;)\n        add(&quot;_(:з」∠)_&quot;)\n    }\n}\ndialog.show(supportFragmentManager,&quot;dialog&quot;)\n</code></pre><p><img src=\"https://raw.githubusercontent.com/o0o0oo00/FancyDialog/master/mdimage/S90108-153438.jpg\" width=\"20%\" height=\"20%\"></p>\n<h3 id=\"customDialog\"><a href=\"#customDialog\" class=\"headerlink\" title=\"customDialog\"></a>customDialog</h3><p>待续…</p>"},{"title":"泛型简述","date":"2018-10-11T08:48:12.000Z","_content":"### 泛型\n泛型还有一种较为准确的说法就是为了参数化类型，或者说可以将类型当作参数传递给一个类或者是方法。  \n看一个例子，证明为什么要有泛型\n<!--more-->\n\n``` \nclass Cache {\nvar value: Any? = null\n}\n```\n\n我们操作数据的时候是酱紫的\n\n```        \nCache cache = new Cache();\ncache.setValue(\"123\");\nString str = (String) cache.getValue();\n\n```\n显然需要一个强制类型转换才能取出理想的数据。\n我们来看使用泛型的情况\n\n```\nclass Cache<T> {\nvar value: T? = null\n}\n\nCache<String> cache = new Cache<String>();\ncache.setValue(\"123\");\nString str =cache.getValue();\n```\n你看，不用强制类型转换了吧~而且泛型可以传入任何一种想要的类型\n泛型可以将类型参数化，但是参数一旦确定好，如果类似不匹配，编译器就不通过。  \n**好处：**  \n1. 它提供了一种扩展能力  \n2. 它是一种类型安全检测机制  \n3. 泛型提高了程序代码的可读性  \n\n#### 按照使用方式\n1. 泛型类。 \n2. 泛型方法。 \n3. 泛型接口。\n\n**定义一个泛型类,理论上这个ZCY可以是任何**\n\n```\nclass Cache<ZCY> {\nvar value: ZCY? = null\n}\n```\n\n```\nclass Cache<ZCY1,ZCY2> {\nvar value: ZCY1? = null\nvar value2: ZCY2? = null\n}\n```\n\n但出于规范的目的，Java 还是建议我们用单个大写字母来代表类型参数。常见的如：\n\n1. T 代表一般的任何类。 \n2. E 代表 Element 的意思，或者 Exception 异常的意思。 \n3. K 代表 Key 的意思。 \n4. V 代表 Value 的意思，通常与 K 一起配合使用。 \n5. S 代表 Subtype 的意思\n\n**泛型方法**  \n泛型方法所定义的泛型与其所在类的泛型互相不冲突，类的ZCY可以是String类型，而方法的ZCY可以是Int类型，它只是一泛泛的类型而已\n\n```\nfun someThing(some: ZCY2): ZCY1? {\nreturn null\n}\n\n或者\n@Throws(IllegalAccessException::class, InstantiationException::class)\nfun <T> fun1(t: Class<T>): T {\nreturn t.newInstance()\n}\n\n```\n#### 通配符\n除了用` <T> `表示泛型外，还有 `<?>` 这种形式。`？` 被称为通配符。  \n有需求说希望泛型可以处理某一范围内的数据类型，比如某个类和他的子类  \n##### 三种形式的通配符\n\n如果存在了通配符，那么它就丧失了“写”的能力，因为它属于未知类型。\n下面的编译是不会通过的\n\n```\nList<?> test1 = new ArrayList<>();\ntest1.add(\"123\"));\ntest1.add(123);\n\n```\n于是乎，通配符用来指明泛型**范围**、**边界**\n\n1. <?> 被称作无限定的通配符。\n2. <? extends T> 被称作有上限的通配符。\n3. <? super T> 被称作有下限的通配符。 \n\n时常（哦不，应该是一直）搞不懂他俩的区别  \nFor Example:\n\n```\nPlate<Fruit> plate = new Plate<Apple>(new Apple());\n```\n这样子是不能通过编译的，**因为一个装苹果的盘子不能变成一个装水果的盘子**。沙雕玩意 ┐(ﾟ～ﾟ)┌ \n就算容器里装的东西之间有继承关系，但容器之间是没有继承关系的。所以我们不能像`Fruit fruit = new Apple();`这么样写。\n\n**有上限通配符**：   \n`Plate<？ extends Fruit>`\n就是说水果以及水果的子类可以放进盘子里面。\n\n```\nPlate<? extends Fruit> plate = new Plate<Apple>(new Apple());\n```\n此时我们发现set方法失效了，原因是编辑器只知道可以set进去Fruit和它的子类，但是具体的类型不知道，可能是Apple，可能是Banana、Orange。所以就不允许。（可是为什么构造方法可以啊？摊手┑(￣Д ￣)┍）  \n**那么我们就可以得出结论 `？`代表我知道它是一个东西，具体是什么我不知道**  \n\n**有下限通配符**：  \n`Plate<? super Fruit>`就是水果以及水果的父类（食物）可以放进盘子里面\n\n```\nPlate<? super Fruit> plate = new Plate<Fruit>(new Fruit());\nplate.set(new Apple());\nplate.set(new Fruit());\nplate.set(new Food());//报错\nObject o = plate.get();\n```\n我们可以看到，水果（Apple 或者 Fruit）可以放进盘子里面，但是Food这一行会报错的，**因为食物Food不一定是水果**，也可能是肉、蔬菜，所以它不能放盘子里面。  \n下限通配符，放开了存储，但是取出来的话就会失效一部分，因为取出来的不知道到底是什么类型，Apple? Fruit? Banana? 不确定 **所以只能用Object来接收**，这样就把元素的类型信息丢掉了。 (●ﾟωﾟ●)\n\n##### PECS:  \n\n* 频繁往外读取内容的，适合用上界Extends。\n* 经常往里插入的，适合用下界Super。\n\n#### 类型擦除\n\njava中的泛型，是相对于**编辑器**阶段的，在**编译**期间java的字节码中是不包含泛型信息的。\n\n看一段代码，这段代码的结果是true，是因为在进入JVM之前，与泛型相关的信息，T 会被类型擦除，无论 T 是String，还是Integer都被替换成了Object，如果指定了上限<? extends String>那么就会被擦除成上限String。\n\n```\nList<String> l1 = new ArrayList<String>();\nList<Integer> l2 = new ArrayList<Integer>();\n\nSystem.out.println(l1.getClass() == l2.getClass());\n```\n\n**Attention**  \n泛型类或者泛型方法中，不接受 8 种基本数据类型。要接受也是他们的包装类。  \n","source":"_posts/fx.md","raw":"---\ntitle: 泛型简述\ndate: 2018-10-11 16:48:12\ncategories: 技术\ntag: kotlin\n---\n### 泛型\n泛型还有一种较为准确的说法就是为了参数化类型，或者说可以将类型当作参数传递给一个类或者是方法。  \n看一个例子，证明为什么要有泛型\n<!--more-->\n\n``` \nclass Cache {\nvar value: Any? = null\n}\n```\n\n我们操作数据的时候是酱紫的\n\n```        \nCache cache = new Cache();\ncache.setValue(\"123\");\nString str = (String) cache.getValue();\n\n```\n显然需要一个强制类型转换才能取出理想的数据。\n我们来看使用泛型的情况\n\n```\nclass Cache<T> {\nvar value: T? = null\n}\n\nCache<String> cache = new Cache<String>();\ncache.setValue(\"123\");\nString str =cache.getValue();\n```\n你看，不用强制类型转换了吧~而且泛型可以传入任何一种想要的类型\n泛型可以将类型参数化，但是参数一旦确定好，如果类似不匹配，编译器就不通过。  \n**好处：**  \n1. 它提供了一种扩展能力  \n2. 它是一种类型安全检测机制  \n3. 泛型提高了程序代码的可读性  \n\n#### 按照使用方式\n1. 泛型类。 \n2. 泛型方法。 \n3. 泛型接口。\n\n**定义一个泛型类,理论上这个ZCY可以是任何**\n\n```\nclass Cache<ZCY> {\nvar value: ZCY? = null\n}\n```\n\n```\nclass Cache<ZCY1,ZCY2> {\nvar value: ZCY1? = null\nvar value2: ZCY2? = null\n}\n```\n\n但出于规范的目的，Java 还是建议我们用单个大写字母来代表类型参数。常见的如：\n\n1. T 代表一般的任何类。 \n2. E 代表 Element 的意思，或者 Exception 异常的意思。 \n3. K 代表 Key 的意思。 \n4. V 代表 Value 的意思，通常与 K 一起配合使用。 \n5. S 代表 Subtype 的意思\n\n**泛型方法**  \n泛型方法所定义的泛型与其所在类的泛型互相不冲突，类的ZCY可以是String类型，而方法的ZCY可以是Int类型，它只是一泛泛的类型而已\n\n```\nfun someThing(some: ZCY2): ZCY1? {\nreturn null\n}\n\n或者\n@Throws(IllegalAccessException::class, InstantiationException::class)\nfun <T> fun1(t: Class<T>): T {\nreturn t.newInstance()\n}\n\n```\n#### 通配符\n除了用` <T> `表示泛型外，还有 `<?>` 这种形式。`？` 被称为通配符。  \n有需求说希望泛型可以处理某一范围内的数据类型，比如某个类和他的子类  \n##### 三种形式的通配符\n\n如果存在了通配符，那么它就丧失了“写”的能力，因为它属于未知类型。\n下面的编译是不会通过的\n\n```\nList<?> test1 = new ArrayList<>();\ntest1.add(\"123\"));\ntest1.add(123);\n\n```\n于是乎，通配符用来指明泛型**范围**、**边界**\n\n1. <?> 被称作无限定的通配符。\n2. <? extends T> 被称作有上限的通配符。\n3. <? super T> 被称作有下限的通配符。 \n\n时常（哦不，应该是一直）搞不懂他俩的区别  \nFor Example:\n\n```\nPlate<Fruit> plate = new Plate<Apple>(new Apple());\n```\n这样子是不能通过编译的，**因为一个装苹果的盘子不能变成一个装水果的盘子**。沙雕玩意 ┐(ﾟ～ﾟ)┌ \n就算容器里装的东西之间有继承关系，但容器之间是没有继承关系的。所以我们不能像`Fruit fruit = new Apple();`这么样写。\n\n**有上限通配符**：   \n`Plate<？ extends Fruit>`\n就是说水果以及水果的子类可以放进盘子里面。\n\n```\nPlate<? extends Fruit> plate = new Plate<Apple>(new Apple());\n```\n此时我们发现set方法失效了，原因是编辑器只知道可以set进去Fruit和它的子类，但是具体的类型不知道，可能是Apple，可能是Banana、Orange。所以就不允许。（可是为什么构造方法可以啊？摊手┑(￣Д ￣)┍）  \n**那么我们就可以得出结论 `？`代表我知道它是一个东西，具体是什么我不知道**  \n\n**有下限通配符**：  \n`Plate<? super Fruit>`就是水果以及水果的父类（食物）可以放进盘子里面\n\n```\nPlate<? super Fruit> plate = new Plate<Fruit>(new Fruit());\nplate.set(new Apple());\nplate.set(new Fruit());\nplate.set(new Food());//报错\nObject o = plate.get();\n```\n我们可以看到，水果（Apple 或者 Fruit）可以放进盘子里面，但是Food这一行会报错的，**因为食物Food不一定是水果**，也可能是肉、蔬菜，所以它不能放盘子里面。  \n下限通配符，放开了存储，但是取出来的话就会失效一部分，因为取出来的不知道到底是什么类型，Apple? Fruit? Banana? 不确定 **所以只能用Object来接收**，这样就把元素的类型信息丢掉了。 (●ﾟωﾟ●)\n\n##### PECS:  \n\n* 频繁往外读取内容的，适合用上界Extends。\n* 经常往里插入的，适合用下界Super。\n\n#### 类型擦除\n\njava中的泛型，是相对于**编辑器**阶段的，在**编译**期间java的字节码中是不包含泛型信息的。\n\n看一段代码，这段代码的结果是true，是因为在进入JVM之前，与泛型相关的信息，T 会被类型擦除，无论 T 是String，还是Integer都被替换成了Object，如果指定了上限<? extends String>那么就会被擦除成上限String。\n\n```\nList<String> l1 = new ArrayList<String>();\nList<Integer> l2 = new ArrayList<Integer>();\n\nSystem.out.println(l1.getClass() == l2.getClass());\n```\n\n**Attention**  \n泛型类或者泛型方法中，不接受 8 种基本数据类型。要接受也是他们的包装类。  \n","slug":"fx","published":1,"updated":"2019-02-28T09:07:32.398Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf11w001d5l2692nwlzbs","content":"<h3 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h3><p>泛型还有一种较为准确的说法就是为了参数化类型，或者说可以将类型当作参数传递给一个类或者是方法。<br>看一个例子，证明为什么要有泛型<br><a id=\"more\"></a></p>\n<pre><code>class Cache {\nvar value: Any? = null\n}\n</code></pre><p>我们操作数据的时候是酱紫的</p>\n<pre><code>Cache cache = new Cache();\ncache.setValue(&quot;123&quot;);\nString str = (String) cache.getValue();\n\n</code></pre><p>显然需要一个强制类型转换才能取出理想的数据。<br>我们来看使用泛型的情况</p>\n<pre><code>class Cache&lt;T&gt; {\nvar value: T? = null\n}\n\nCache&lt;String&gt; cache = new Cache&lt;String&gt;();\ncache.setValue(&quot;123&quot;);\nString str =cache.getValue();\n</code></pre><p>你看，不用强制类型转换了吧~而且泛型可以传入任何一种想要的类型<br>泛型可以将类型参数化，但是参数一旦确定好，如果类似不匹配，编译器就不通过。<br><strong>好处：</strong>  </p>\n<ol>\n<li>它提供了一种扩展能力  </li>\n<li>它是一种类型安全检测机制  </li>\n<li>泛型提高了程序代码的可读性  </li>\n</ol>\n<h4 id=\"按照使用方式\"><a href=\"#按照使用方式\" class=\"headerlink\" title=\"按照使用方式\"></a>按照使用方式</h4><ol>\n<li>泛型类。 </li>\n<li>泛型方法。 </li>\n<li>泛型接口。</li>\n</ol>\n<p><strong>定义一个泛型类,理论上这个ZCY可以是任何</strong></p>\n<pre><code>class Cache&lt;ZCY&gt; {\nvar value: ZCY? = null\n}\n</code></pre><pre><code>class Cache&lt;ZCY1,ZCY2&gt; {\nvar value: ZCY1? = null\nvar value2: ZCY2? = null\n}\n</code></pre><p>但出于规范的目的，Java 还是建议我们用单个大写字母来代表类型参数。常见的如：</p>\n<ol>\n<li>T 代表一般的任何类。 </li>\n<li>E 代表 Element 的意思，或者 Exception 异常的意思。 </li>\n<li>K 代表 Key 的意思。 </li>\n<li>V 代表 Value 的意思，通常与 K 一起配合使用。 </li>\n<li>S 代表 Subtype 的意思</li>\n</ol>\n<p><strong>泛型方法</strong><br>泛型方法所定义的泛型与其所在类的泛型互相不冲突，类的ZCY可以是String类型，而方法的ZCY可以是Int类型，它只是一泛泛的类型而已</p>\n<pre><code>fun someThing(some: ZCY2): ZCY1? {\nreturn null\n}\n\n或者\n@Throws(IllegalAccessException::class, InstantiationException::class)\nfun &lt;T&gt; fun1(t: Class&lt;T&gt;): T {\nreturn t.newInstance()\n}\n\n</code></pre><h4 id=\"通配符\"><a href=\"#通配符\" class=\"headerlink\" title=\"通配符\"></a>通配符</h4><p>除了用<code>&lt;T&gt;</code>表示泛型外，还有 <code>&lt;?&gt;</code> 这种形式。<code>？</code> 被称为通配符。<br>有需求说希望泛型可以处理某一范围内的数据类型，比如某个类和他的子类  </p>\n<h5 id=\"三种形式的通配符\"><a href=\"#三种形式的通配符\" class=\"headerlink\" title=\"三种形式的通配符\"></a>三种形式的通配符</h5><p>如果存在了通配符，那么它就丧失了“写”的能力，因为它属于未知类型。<br>下面的编译是不会通过的</p>\n<pre><code>List&lt;?&gt; test1 = new ArrayList&lt;&gt;();\ntest1.add(&quot;123&quot;));\ntest1.add(123);\n\n</code></pre><p>于是乎，通配符用来指明泛型<strong>范围</strong>、<strong>边界</strong></p>\n<ol>\n<li>&lt;?&gt; 被称作无限定的通配符。</li>\n<li>&lt;? extends T&gt; 被称作有上限的通配符。</li>\n<li>&lt;? super T&gt; 被称作有下限的通配符。 </li>\n</ol>\n<p>时常（哦不，应该是一直）搞不懂他俩的区别<br>For Example:</p>\n<pre><code>Plate&lt;Fruit&gt; plate = new Plate&lt;Apple&gt;(new Apple());\n</code></pre><p>这样子是不能通过编译的，<strong>因为一个装苹果的盘子不能变成一个装水果的盘子</strong>。沙雕玩意 ┐(ﾟ～ﾟ)┌<br>就算容器里装的东西之间有继承关系，但容器之间是没有继承关系的。所以我们不能像<code>Fruit fruit = new Apple();</code>这么样写。</p>\n<p><strong>有上限通配符</strong>：<br><code>Plate&lt;？ extends Fruit&gt;</code><br>就是说水果以及水果的子类可以放进盘子里面。</p>\n<pre><code>Plate&lt;? extends Fruit&gt; plate = new Plate&lt;Apple&gt;(new Apple());\n</code></pre><p>此时我们发现set方法失效了，原因是编辑器只知道可以set进去Fruit和它的子类，但是具体的类型不知道，可能是Apple，可能是Banana、Orange。所以就不允许。（可是为什么构造方法可以啊？摊手┑(￣Д ￣)┍）<br><strong>那么我们就可以得出结论 <code>？</code>代表我知道它是一个东西，具体是什么我不知道</strong>  </p>\n<p><strong>有下限通配符</strong>：<br><code>Plate&lt;? super Fruit&gt;</code>就是水果以及水果的父类（食物）可以放进盘子里面</p>\n<pre><code>Plate&lt;? super Fruit&gt; plate = new Plate&lt;Fruit&gt;(new Fruit());\nplate.set(new Apple());\nplate.set(new Fruit());\nplate.set(new Food());//报错\nObject o = plate.get();\n</code></pre><p>我们可以看到，水果（Apple 或者 Fruit）可以放进盘子里面，但是Food这一行会报错的，<strong>因为食物Food不一定是水果</strong>，也可能是肉、蔬菜，所以它不能放盘子里面。<br>下限通配符，放开了存储，但是取出来的话就会失效一部分，因为取出来的不知道到底是什么类型，Apple? Fruit? Banana? 不确定 <strong>所以只能用Object来接收</strong>，这样就把元素的类型信息丢掉了。 (●ﾟωﾟ●)</p>\n<h5 id=\"PECS\"><a href=\"#PECS\" class=\"headerlink\" title=\"PECS:\"></a>PECS:</h5><ul>\n<li>频繁往外读取内容的，适合用上界Extends。</li>\n<li>经常往里插入的，适合用下界Super。</li>\n</ul>\n<h4 id=\"类型擦除\"><a href=\"#类型擦除\" class=\"headerlink\" title=\"类型擦除\"></a>类型擦除</h4><p>java中的泛型，是相对于<strong>编辑器</strong>阶段的，在<strong>编译</strong>期间java的字节码中是不包含泛型信息的。</p>\n<p>看一段代码，这段代码的结果是true，是因为在进入JVM之前，与泛型相关的信息，T 会被类型擦除，无论 T 是String，还是Integer都被替换成了Object，如果指定了上限&lt;? extends String&gt;那么就会被擦除成上限String。</p>\n<pre><code>List&lt;String&gt; l1 = new ArrayList&lt;String&gt;();\nList&lt;Integer&gt; l2 = new ArrayList&lt;Integer&gt;();\n\nSystem.out.println(l1.getClass() == l2.getClass());\n</code></pre><p><strong>Attention</strong><br>泛型类或者泛型方法中，不接受 8 种基本数据类型。要接受也是他们的包装类。  </p>\n","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"<h3 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h3><p>泛型还有一种较为准确的说法就是为了参数化类型，或者说可以将类型当作参数传递给一个类或者是方法。<br>看一个例子，证明为什么要有泛型<br>","more":"</p>\n<pre><code>class Cache {\nvar value: Any? = null\n}\n</code></pre><p>我们操作数据的时候是酱紫的</p>\n<pre><code>Cache cache = new Cache();\ncache.setValue(&quot;123&quot;);\nString str = (String) cache.getValue();\n\n</code></pre><p>显然需要一个强制类型转换才能取出理想的数据。<br>我们来看使用泛型的情况</p>\n<pre><code>class Cache&lt;T&gt; {\nvar value: T? = null\n}\n\nCache&lt;String&gt; cache = new Cache&lt;String&gt;();\ncache.setValue(&quot;123&quot;);\nString str =cache.getValue();\n</code></pre><p>你看，不用强制类型转换了吧~而且泛型可以传入任何一种想要的类型<br>泛型可以将类型参数化，但是参数一旦确定好，如果类似不匹配，编译器就不通过。<br><strong>好处：</strong>  </p>\n<ol>\n<li>它提供了一种扩展能力  </li>\n<li>它是一种类型安全检测机制  </li>\n<li>泛型提高了程序代码的可读性  </li>\n</ol>\n<h4 id=\"按照使用方式\"><a href=\"#按照使用方式\" class=\"headerlink\" title=\"按照使用方式\"></a>按照使用方式</h4><ol>\n<li>泛型类。 </li>\n<li>泛型方法。 </li>\n<li>泛型接口。</li>\n</ol>\n<p><strong>定义一个泛型类,理论上这个ZCY可以是任何</strong></p>\n<pre><code>class Cache&lt;ZCY&gt; {\nvar value: ZCY? = null\n}\n</code></pre><pre><code>class Cache&lt;ZCY1,ZCY2&gt; {\nvar value: ZCY1? = null\nvar value2: ZCY2? = null\n}\n</code></pre><p>但出于规范的目的，Java 还是建议我们用单个大写字母来代表类型参数。常见的如：</p>\n<ol>\n<li>T 代表一般的任何类。 </li>\n<li>E 代表 Element 的意思，或者 Exception 异常的意思。 </li>\n<li>K 代表 Key 的意思。 </li>\n<li>V 代表 Value 的意思，通常与 K 一起配合使用。 </li>\n<li>S 代表 Subtype 的意思</li>\n</ol>\n<p><strong>泛型方法</strong><br>泛型方法所定义的泛型与其所在类的泛型互相不冲突，类的ZCY可以是String类型，而方法的ZCY可以是Int类型，它只是一泛泛的类型而已</p>\n<pre><code>fun someThing(some: ZCY2): ZCY1? {\nreturn null\n}\n\n或者\n@Throws(IllegalAccessException::class, InstantiationException::class)\nfun &lt;T&gt; fun1(t: Class&lt;T&gt;): T {\nreturn t.newInstance()\n}\n\n</code></pre><h4 id=\"通配符\"><a href=\"#通配符\" class=\"headerlink\" title=\"通配符\"></a>通配符</h4><p>除了用<code>&lt;T&gt;</code>表示泛型外，还有 <code>&lt;?&gt;</code> 这种形式。<code>？</code> 被称为通配符。<br>有需求说希望泛型可以处理某一范围内的数据类型，比如某个类和他的子类  </p>\n<h5 id=\"三种形式的通配符\"><a href=\"#三种形式的通配符\" class=\"headerlink\" title=\"三种形式的通配符\"></a>三种形式的通配符</h5><p>如果存在了通配符，那么它就丧失了“写”的能力，因为它属于未知类型。<br>下面的编译是不会通过的</p>\n<pre><code>List&lt;?&gt; test1 = new ArrayList&lt;&gt;();\ntest1.add(&quot;123&quot;));\ntest1.add(123);\n\n</code></pre><p>于是乎，通配符用来指明泛型<strong>范围</strong>、<strong>边界</strong></p>\n<ol>\n<li>&lt;?&gt; 被称作无限定的通配符。</li>\n<li>&lt;? extends T&gt; 被称作有上限的通配符。</li>\n<li>&lt;? super T&gt; 被称作有下限的通配符。 </li>\n</ol>\n<p>时常（哦不，应该是一直）搞不懂他俩的区别<br>For Example:</p>\n<pre><code>Plate&lt;Fruit&gt; plate = new Plate&lt;Apple&gt;(new Apple());\n</code></pre><p>这样子是不能通过编译的，<strong>因为一个装苹果的盘子不能变成一个装水果的盘子</strong>。沙雕玩意 ┐(ﾟ～ﾟ)┌<br>就算容器里装的东西之间有继承关系，但容器之间是没有继承关系的。所以我们不能像<code>Fruit fruit = new Apple();</code>这么样写。</p>\n<p><strong>有上限通配符</strong>：<br><code>Plate&lt;？ extends Fruit&gt;</code><br>就是说水果以及水果的子类可以放进盘子里面。</p>\n<pre><code>Plate&lt;? extends Fruit&gt; plate = new Plate&lt;Apple&gt;(new Apple());\n</code></pre><p>此时我们发现set方法失效了，原因是编辑器只知道可以set进去Fruit和它的子类，但是具体的类型不知道，可能是Apple，可能是Banana、Orange。所以就不允许。（可是为什么构造方法可以啊？摊手┑(￣Д ￣)┍）<br><strong>那么我们就可以得出结论 <code>？</code>代表我知道它是一个东西，具体是什么我不知道</strong>  </p>\n<p><strong>有下限通配符</strong>：<br><code>Plate&lt;? super Fruit&gt;</code>就是水果以及水果的父类（食物）可以放进盘子里面</p>\n<pre><code>Plate&lt;? super Fruit&gt; plate = new Plate&lt;Fruit&gt;(new Fruit());\nplate.set(new Apple());\nplate.set(new Fruit());\nplate.set(new Food());//报错\nObject o = plate.get();\n</code></pre><p>我们可以看到，水果（Apple 或者 Fruit）可以放进盘子里面，但是Food这一行会报错的，<strong>因为食物Food不一定是水果</strong>，也可能是肉、蔬菜，所以它不能放盘子里面。<br>下限通配符，放开了存储，但是取出来的话就会失效一部分，因为取出来的不知道到底是什么类型，Apple? Fruit? Banana? 不确定 <strong>所以只能用Object来接收</strong>，这样就把元素的类型信息丢掉了。 (●ﾟωﾟ●)</p>\n<h5 id=\"PECS\"><a href=\"#PECS\" class=\"headerlink\" title=\"PECS:\"></a>PECS:</h5><ul>\n<li>频繁往外读取内容的，适合用上界Extends。</li>\n<li>经常往里插入的，适合用下界Super。</li>\n</ul>\n<h4 id=\"类型擦除\"><a href=\"#类型擦除\" class=\"headerlink\" title=\"类型擦除\"></a>类型擦除</h4><p>java中的泛型，是相对于<strong>编辑器</strong>阶段的，在<strong>编译</strong>期间java的字节码中是不包含泛型信息的。</p>\n<p>看一段代码，这段代码的结果是true，是因为在进入JVM之前，与泛型相关的信息，T 会被类型擦除，无论 T 是String，还是Integer都被替换成了Object，如果指定了上限&lt;? extends String&gt;那么就会被擦除成上限String。</p>\n<pre><code>List&lt;String&gt; l1 = new ArrayList&lt;String&gt;();\nList&lt;Integer&gt; l2 = new ArrayList&lt;Integer&gt;();\n\nSystem.out.println(l1.getClass() == l2.getClass());\n</code></pre><p><strong>Attention</strong><br>泛型类或者泛型方法中，不接受 8 种基本数据类型。要接受也是他们的包装类。  </p>"},{"title":"Hello World","comments":1,"_content":"\n\n### 最新更新\n\n使用[闪烁之狐](https://github.com/blinkfox/hexo-theme-matery)主题\n全部搞定  \n[文档地址](https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/)\n\n\n\n---\n**下面修改的是next主题的一些配置**\n\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n\n### 关于网站的一些配置\n<!--more-->\n打开Mac壁纸：  \nFinder 前往文件夹 输入/Library/Desktop Pictures/ \n更改网站主题颜色：\nopen  hexoSpace\\themes\\next\\source\\css\\_custom\\custom.styl\n\n\n```\nbody{\nbackground:url(/images/FloatingIce.jpg);\nbackground-size:cover;\nbackground-repeat:no-repeat;\nbackground-attachment:fixed;\nbackground-position:center;\n}\n\n背景透明：  \n.post-block {\nbackground:rgba(255, 255, 255, 0.75) none repeat scroll !important;\n}\n\n\n$body-bg-color = rgba(255, 255, 255, 0.85);\n$my-color = rgb(113, 189, 229)\n// 修改网站头部颜色\n.headband {\nheight: 3px;\nbackground: $my-color;\n}\n.site-meta {\npadding: 20px 0;\ncolor: #fff;\nbackground: $my-color;\n}\n.site-subtitle {\nmargin-top: 10px;\nfont-size: 13px;\ncolor: #ffffff;\n}\n// 修改按键（button）样式\n.btn {\ncolor: $my-color;\nbackground: #fff;\nborder: 2px solid $my-color;\n}\n// 按键（button）点击时样式\n.btn:hover {\nborder-color: $my-color;\ncolor: #fff;\nbackground: $my-color;\n}\n```\n\n\n\n#### fork me on github\n\nopen hexoSpace/themes/next/layout/_layout.swig\n\nfind this\n\n```\n<div class=\"{{ container_class }} {% block page_class %}{% endblock %} \">\n<div class=\"headband\"></div>\n```\n\nadd this below\n\n```\n<a href=\"https://o0o0oo00.github.io\" class=\"github-corner\" aria-label=\"View source on GitHub\"><svg width=\"80\" height=\"80\" viewBox=\"0 0 250 250\" style=\"fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;\" aria-hidden=\"true\"><path d=\"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z\"></path><path d=\"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2\" fill=\"currentColor\" style=\"transform-origin: 130px 106px;\" class=\"octo-arm\"></path><path d=\"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z\" fill=\"currentColor\" class=\"octo-body\"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>\n```\n\n\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ncomments: true #是否可评论\ncategories: hexo #分类\ntag: hexo\n\n---\n\n\n### 最新更新\n\n使用[闪烁之狐](https://github.com/blinkfox/hexo-theme-matery)主题\n全部搞定  \n[文档地址](https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/)\n\n\n\n---\n**下面修改的是next主题的一些配置**\n\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n\n### 关于网站的一些配置\n<!--more-->\n打开Mac壁纸：  \nFinder 前往文件夹 输入/Library/Desktop Pictures/ \n更改网站主题颜色：\nopen  hexoSpace\\themes\\next\\source\\css\\_custom\\custom.styl\n\n\n```\nbody{\nbackground:url(/images/FloatingIce.jpg);\nbackground-size:cover;\nbackground-repeat:no-repeat;\nbackground-attachment:fixed;\nbackground-position:center;\n}\n\n背景透明：  \n.post-block {\nbackground:rgba(255, 255, 255, 0.75) none repeat scroll !important;\n}\n\n\n$body-bg-color = rgba(255, 255, 255, 0.85);\n$my-color = rgb(113, 189, 229)\n// 修改网站头部颜色\n.headband {\nheight: 3px;\nbackground: $my-color;\n}\n.site-meta {\npadding: 20px 0;\ncolor: #fff;\nbackground: $my-color;\n}\n.site-subtitle {\nmargin-top: 10px;\nfont-size: 13px;\ncolor: #ffffff;\n}\n// 修改按键（button）样式\n.btn {\ncolor: $my-color;\nbackground: #fff;\nborder: 2px solid $my-color;\n}\n// 按键（button）点击时样式\n.btn:hover {\nborder-color: $my-color;\ncolor: #fff;\nbackground: $my-color;\n}\n```\n\n\n\n#### fork me on github\n\nopen hexoSpace/themes/next/layout/_layout.swig\n\nfind this\n\n```\n<div class=\"{{ container_class }} {% block page_class %}{% endblock %} \">\n<div class=\"headband\"></div>\n```\n\nadd this below\n\n```\n<a href=\"https://o0o0oo00.github.io\" class=\"github-corner\" aria-label=\"View source on GitHub\"><svg width=\"80\" height=\"80\" viewBox=\"0 0 250 250\" style=\"fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;\" aria-hidden=\"true\"><path d=\"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z\"></path><path d=\"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2\" fill=\"currentColor\" style=\"transform-origin: 130px 106px;\" class=\"octo-arm\"></path><path d=\"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z\" fill=\"currentColor\" class=\"octo-body\"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>\n```\n\n\n","slug":"hello-world","published":1,"date":"2018-09-17T06:39:09.000Z","updated":"2019-02-28T09:28:30.047Z","layout":"post","photos":[],"link":"","_id":"cjsogf11y001h5l26xbq88nlf","content":"<h3 id=\"最新更新\"><a href=\"#最新更新\" class=\"headerlink\" title=\"最新更新\"></a>最新更新</h3><p>使用<a href=\"https://github.com/blinkfox/hexo-theme-matery\" target=\"_blank\" rel=\"noopener\">闪烁之狐</a>主题<br>全部搞定<br><a href=\"https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/\" target=\"_blank\" rel=\"noopener\">文档地址</a></p>\n<hr>\n<p><strong>下面修改的是next主题的一些配置</strong></p>\n<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h3 id=\"关于网站的一些配置\"><a href=\"#关于网站的一些配置\" class=\"headerlink\" title=\"关于网站的一些配置\"></a>关于网站的一些配置</h3><a id=\"more\"></a>\n<p>打开Mac壁纸：<br>Finder 前往文件夹 输入/Library/Desktop Pictures/<br>更改网站主题颜色：<br>open  hexoSpace\\themes\\next\\source\\css_custom\\custom.styl</p>\n<pre><code>body{\nbackground:url(/images/FloatingIce.jpg);\nbackground-size:cover;\nbackground-repeat:no-repeat;\nbackground-attachment:fixed;\nbackground-position:center;\n}\n\n背景透明：  \n.post-block {\nbackground:rgba(255, 255, 255, 0.75) none repeat scroll !important;\n}\n\n\n$body-bg-color = rgba(255, 255, 255, 0.85);\n$my-color = rgb(113, 189, 229)\n// 修改网站头部颜色\n.headband {\nheight: 3px;\nbackground: $my-color;\n}\n.site-meta {\npadding: 20px 0;\ncolor: #fff;\nbackground: $my-color;\n}\n.site-subtitle {\nmargin-top: 10px;\nfont-size: 13px;\ncolor: #ffffff;\n}\n// 修改按键（button）样式\n.btn {\ncolor: $my-color;\nbackground: #fff;\nborder: 2px solid $my-color;\n}\n// 按键（button）点击时样式\n.btn:hover {\nborder-color: $my-color;\ncolor: #fff;\nbackground: $my-color;\n}\n</code></pre><h4 id=\"fork-me-on-github\"><a href=\"#fork-me-on-github\" class=\"headerlink\" title=\"fork me on github\"></a>fork me on github</h4><p>open hexoSpace/themes/next/layout/_layout.swig</p>\n<p>find this</p>\n<pre><code>&lt;div class=&quot;{{ container_class }} {% block page_class %}{% endblock %} &quot;&gt;\n&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;\n</code></pre><p>add this below</p>\n<pre><code>&lt;a href=&quot;https://o0o0oo00.github.io&quot; class=&quot;github-corner&quot; aria-label=&quot;View source on GitHub&quot;&gt;&lt;svg width=&quot;80&quot; height=&quot;80&quot; viewBox=&quot;0 0 250 250&quot; style=&quot;fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill=&quot;currentColor&quot; style=&quot;transform-origin: 130px 106px;&quot; class=&quot;octo-arm&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill=&quot;currentColor&quot; class=&quot;octo-body&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}&lt;/style&gt;\n</code></pre>","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"<h3 id=\"最新更新\"><a href=\"#最新更新\" class=\"headerlink\" title=\"最新更新\"></a>最新更新</h3><p>使用<a href=\"https://github.com/blinkfox/hexo-theme-matery\" target=\"_blank\" rel=\"noopener\">闪烁之狐</a>主题<br>全部搞定<br><a href=\"https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/\" target=\"_blank\" rel=\"noopener\">文档地址</a></p>\n<hr>\n<p><strong>下面修改的是next主题的一些配置</strong></p>\n<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h3 id=\"关于网站的一些配置\"><a href=\"#关于网站的一些配置\" class=\"headerlink\" title=\"关于网站的一些配置\"></a>关于网站的一些配置</h3>","more":"<p>打开Mac壁纸：<br>Finder 前往文件夹 输入/Library/Desktop Pictures/<br>更改网站主题颜色：<br>open  hexoSpace\\themes\\next\\source\\css_custom\\custom.styl</p>\n<pre><code>body{\nbackground:url(/images/FloatingIce.jpg);\nbackground-size:cover;\nbackground-repeat:no-repeat;\nbackground-attachment:fixed;\nbackground-position:center;\n}\n\n背景透明：  \n.post-block {\nbackground:rgba(255, 255, 255, 0.75) none repeat scroll !important;\n}\n\n\n$body-bg-color = rgba(255, 255, 255, 0.85);\n$my-color = rgb(113, 189, 229)\n// 修改网站头部颜色\n.headband {\nheight: 3px;\nbackground: $my-color;\n}\n.site-meta {\npadding: 20px 0;\ncolor: #fff;\nbackground: $my-color;\n}\n.site-subtitle {\nmargin-top: 10px;\nfont-size: 13px;\ncolor: #ffffff;\n}\n// 修改按键（button）样式\n.btn {\ncolor: $my-color;\nbackground: #fff;\nborder: 2px solid $my-color;\n}\n// 按键（button）点击时样式\n.btn:hover {\nborder-color: $my-color;\ncolor: #fff;\nbackground: $my-color;\n}\n</code></pre><h4 id=\"fork-me-on-github\"><a href=\"#fork-me-on-github\" class=\"headerlink\" title=\"fork me on github\"></a>fork me on github</h4><p>open hexoSpace/themes/next/layout/_layout.swig</p>\n<p>find this</p>\n<pre><code>&lt;div class=&quot;{{ container_class }} {% block page_class %}{% endblock %} &quot;&gt;\n&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;\n</code></pre><p>add this below</p>\n<pre><code>&lt;a href=&quot;https://o0o0oo00.github.io&quot; class=&quot;github-corner&quot; aria-label=&quot;View source on GitHub&quot;&gt;&lt;svg width=&quot;80&quot; height=&quot;80&quot; viewBox=&quot;0 0 250 250&quot; style=&quot;fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; right: 0;&quot; aria-hidden=&quot;true&quot;&gt;&lt;path d=&quot;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2&quot; fill=&quot;currentColor&quot; style=&quot;transform-origin: 130px 106px;&quot; class=&quot;octo-arm&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z&quot; fill=&quot;currentColor&quot; class=&quot;octo-body&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}&lt;/style&gt;\n</code></pre>"},{"title":"RxJava2 线程调度","date":"2018-10-22T08:08:04.000Z","_content":"### RxJava2 线程调度\n既然是异步就要涉及到线程控制  \n#### RxJava提供的线程\n\n1. `Schedulers.trampoline()`当前线程\n2. `Schedulers.newThread()`启动新的线程，在新的线程中执行操作\n3. `Schedulers.io()`io读写线程，区别于`newThread`在于`io`内部的是用一个无数量上限的线程池，可以重用空闲线程，推荐使用。\n4. `Schedulers.computation()`这个Sheduler使用的固定的线程池，大小为cpu核数，有些操作符或者涉及到运算的情况下使用。\n5. `Schedulers.single()`任务都在这个单例线程中执行，按**队列**顺序\n<!--more-->\n\n#### 指定线程\n指定**观察者**线程：`observerOn(Schedulers)`  \n指定**被观察者**线程：`subScribeOn(Schedulers)`  \n\n恕老衲直言，这个名字起的是真的瘪嘴。\n\n看例子：\n\n```\nprivate fun testThreadWhere() {\n    Observable.create(ObservableOnSubscribe<Long>() {\n        Log.e(TAG, \"发射 线程为：${Thread.currentThread().name} \")\n        it.onNext(12L)\n    })\n        .filter {\n            Log.e(TAG, \"filter 线程为：${Thread.currentThread().name} $it \")\n            return@filter it > 10\n        }\n        .subscribeOn(Schedulers.io())// 1 指定filter线程 \n        .observeOn(Schedulers.newThread()) // 2 指定map线程\n        .map(Function<Long, String>() {\n            Log.e(TAG, \"map 线程为：${Thread.currentThread().name} $it \")\n            return@Function it.toString()\n        })\n        .observeOn(AndroidSchedulers.mainThread())// 3\n        .subscribe {\n            Log.e(TAG, \"处理 线程为：${Thread.currentThread().name} $it \")\n        }\n}\n```\n看一下结果：\n其中  \n`RxCachedThreadScheduler `为`io`线程因为其内部采用的是线程池处理机制。  \n`RxNewThreadScheduler `为`newThread`线程。\n\n```\n10-22 16:02:16.199 17797-17855/com.zcy.nidavellir.javaworld E/MainActivity: 发射 线程为：RxCachedThreadScheduler-1 \n10-22 16:02:16.199 17797-17855/com.zcy.nidavellir.javaworld E/MainActivity: filter 线程为：RxCachedThreadScheduler-1 12 \n10-22 16:02:16.200 17797-17856/com.zcy.nidavellir.javaworld E/MainActivity: map 线程为：RxNewThreadScheduler-1 12 \n10-22 16:02:16.251 17797-17797/com.zcy.nidavellir.javaworld E/MainActivity: 处理 线程为：main 12 \n```\n\n* 如果注释掉 注释中的1 相当于是不指定**被观察者**线程，那么**被观察者**会在当前的**默认线程**也就是**主线程**执行任务。\n* 如果注释掉 注释中的2 那么filter 和 map 都会在`io`线程中执行，直到遇到了`observerOn`\n* observerOn的下游也就是**观察者**因为指定了`AndroidSchedulers.mainThread()`所以在`mainThread`中运行。\n* 多次指定`subscribeOn`不生效，以最先指定的线程为准。多次`observerOn`生效，指定一次对下游直到下一个`observerOn`中间生效。\n\n\n\n\n","source":"_posts/rxScheduler.md","raw":"---\ntitle: RxJava2 线程调度\ndate: 2018-10-22 16:08:04\ncategories: 技术\ntag: kotlin\n---\n### RxJava2 线程调度\n既然是异步就要涉及到线程控制  \n#### RxJava提供的线程\n\n1. `Schedulers.trampoline()`当前线程\n2. `Schedulers.newThread()`启动新的线程，在新的线程中执行操作\n3. `Schedulers.io()`io读写线程，区别于`newThread`在于`io`内部的是用一个无数量上限的线程池，可以重用空闲线程，推荐使用。\n4. `Schedulers.computation()`这个Sheduler使用的固定的线程池，大小为cpu核数，有些操作符或者涉及到运算的情况下使用。\n5. `Schedulers.single()`任务都在这个单例线程中执行，按**队列**顺序\n<!--more-->\n\n#### 指定线程\n指定**观察者**线程：`observerOn(Schedulers)`  \n指定**被观察者**线程：`subScribeOn(Schedulers)`  \n\n恕老衲直言，这个名字起的是真的瘪嘴。\n\n看例子：\n\n```\nprivate fun testThreadWhere() {\n    Observable.create(ObservableOnSubscribe<Long>() {\n        Log.e(TAG, \"发射 线程为：${Thread.currentThread().name} \")\n        it.onNext(12L)\n    })\n        .filter {\n            Log.e(TAG, \"filter 线程为：${Thread.currentThread().name} $it \")\n            return@filter it > 10\n        }\n        .subscribeOn(Schedulers.io())// 1 指定filter线程 \n        .observeOn(Schedulers.newThread()) // 2 指定map线程\n        .map(Function<Long, String>() {\n            Log.e(TAG, \"map 线程为：${Thread.currentThread().name} $it \")\n            return@Function it.toString()\n        })\n        .observeOn(AndroidSchedulers.mainThread())// 3\n        .subscribe {\n            Log.e(TAG, \"处理 线程为：${Thread.currentThread().name} $it \")\n        }\n}\n```\n看一下结果：\n其中  \n`RxCachedThreadScheduler `为`io`线程因为其内部采用的是线程池处理机制。  \n`RxNewThreadScheduler `为`newThread`线程。\n\n```\n10-22 16:02:16.199 17797-17855/com.zcy.nidavellir.javaworld E/MainActivity: 发射 线程为：RxCachedThreadScheduler-1 \n10-22 16:02:16.199 17797-17855/com.zcy.nidavellir.javaworld E/MainActivity: filter 线程为：RxCachedThreadScheduler-1 12 \n10-22 16:02:16.200 17797-17856/com.zcy.nidavellir.javaworld E/MainActivity: map 线程为：RxNewThreadScheduler-1 12 \n10-22 16:02:16.251 17797-17797/com.zcy.nidavellir.javaworld E/MainActivity: 处理 线程为：main 12 \n```\n\n* 如果注释掉 注释中的1 相当于是不指定**被观察者**线程，那么**被观察者**会在当前的**默认线程**也就是**主线程**执行任务。\n* 如果注释掉 注释中的2 那么filter 和 map 都会在`io`线程中执行，直到遇到了`observerOn`\n* observerOn的下游也就是**观察者**因为指定了`AndroidSchedulers.mainThread()`所以在`mainThread`中运行。\n* 多次指定`subscribeOn`不生效，以最先指定的线程为准。多次`observerOn`生效，指定一次对下游直到下一个`observerOn`中间生效。\n\n\n\n\n","slug":"rxScheduler","published":1,"updated":"2019-02-28T09:09:35.932Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf11z001k5l26o5me9etn","content":"<h3 id=\"RxJava2-线程调度\"><a href=\"#RxJava2-线程调度\" class=\"headerlink\" title=\"RxJava2 线程调度\"></a>RxJava2 线程调度</h3><p>既然是异步就要涉及到线程控制  </p>\n<h4 id=\"RxJava提供的线程\"><a href=\"#RxJava提供的线程\" class=\"headerlink\" title=\"RxJava提供的线程\"></a>RxJava提供的线程</h4><ol>\n<li><code>Schedulers.trampoline()</code>当前线程</li>\n<li><code>Schedulers.newThread()</code>启动新的线程，在新的线程中执行操作</li>\n<li><code>Schedulers.io()</code>io读写线程，区别于<code>newThread</code>在于<code>io</code>内部的是用一个无数量上限的线程池，可以重用空闲线程，推荐使用。</li>\n<li><code>Schedulers.computation()</code>这个Sheduler使用的固定的线程池，大小为cpu核数，有些操作符或者涉及到运算的情况下使用。</li>\n<li><code>Schedulers.single()</code>任务都在这个单例线程中执行，按<strong>队列</strong>顺序<a id=\"more\"></a>\n</li>\n</ol>\n<h4 id=\"指定线程\"><a href=\"#指定线程\" class=\"headerlink\" title=\"指定线程\"></a>指定线程</h4><p>指定<strong>观察者</strong>线程：<code>observerOn(Schedulers)</code><br>指定<strong>被观察者</strong>线程：<code>subScribeOn(Schedulers)</code>  </p>\n<p>恕老衲直言，这个名字起的是真的瘪嘴。</p>\n<p>看例子：</p>\n<pre><code>private fun testThreadWhere() {\n    Observable.create(ObservableOnSubscribe&lt;Long&gt;() {\n        Log.e(TAG, &quot;发射 线程为：${Thread.currentThread().name} &quot;)\n        it.onNext(12L)\n    })\n        .filter {\n            Log.e(TAG, &quot;filter 线程为：${Thread.currentThread().name} $it &quot;)\n            return@filter it &gt; 10\n        }\n        .subscribeOn(Schedulers.io())// 1 指定filter线程 \n        .observeOn(Schedulers.newThread()) // 2 指定map线程\n        .map(Function&lt;Long, String&gt;() {\n            Log.e(TAG, &quot;map 线程为：${Thread.currentThread().name} $it &quot;)\n            return@Function it.toString()\n        })\n        .observeOn(AndroidSchedulers.mainThread())// 3\n        .subscribe {\n            Log.e(TAG, &quot;处理 线程为：${Thread.currentThread().name} $it &quot;)\n        }\n}\n</code></pre><p>看一下结果：<br>其中<br><code>RxCachedThreadScheduler</code>为<code>io</code>线程因为其内部采用的是线程池处理机制。<br><code>RxNewThreadScheduler</code>为<code>newThread</code>线程。</p>\n<pre><code>10-22 16:02:16.199 17797-17855/com.zcy.nidavellir.javaworld E/MainActivity: 发射 线程为：RxCachedThreadScheduler-1 \n10-22 16:02:16.199 17797-17855/com.zcy.nidavellir.javaworld E/MainActivity: filter 线程为：RxCachedThreadScheduler-1 12 \n10-22 16:02:16.200 17797-17856/com.zcy.nidavellir.javaworld E/MainActivity: map 线程为：RxNewThreadScheduler-1 12 \n10-22 16:02:16.251 17797-17797/com.zcy.nidavellir.javaworld E/MainActivity: 处理 线程为：main 12 \n</code></pre><ul>\n<li>如果注释掉 注释中的1 相当于是不指定<strong>被观察者</strong>线程，那么<strong>被观察者</strong>会在当前的<strong>默认线程</strong>也就是<strong>主线程</strong>执行任务。</li>\n<li>如果注释掉 注释中的2 那么filter 和 map 都会在<code>io</code>线程中执行，直到遇到了<code>observerOn</code></li>\n<li>observerOn的下游也就是<strong>观察者</strong>因为指定了<code>AndroidSchedulers.mainThread()</code>所以在<code>mainThread</code>中运行。</li>\n<li>多次指定<code>subscribeOn</code>不生效，以最先指定的线程为准。多次<code>observerOn</code>生效，指定一次对下游直到下一个<code>observerOn</code>中间生效。</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"<h3 id=\"RxJava2-线程调度\"><a href=\"#RxJava2-线程调度\" class=\"headerlink\" title=\"RxJava2 线程调度\"></a>RxJava2 线程调度</h3><p>既然是异步就要涉及到线程控制  </p>\n<h4 id=\"RxJava提供的线程\"><a href=\"#RxJava提供的线程\" class=\"headerlink\" title=\"RxJava提供的线程\"></a>RxJava提供的线程</h4><ol>\n<li><code>Schedulers.trampoline()</code>当前线程</li>\n<li><code>Schedulers.newThread()</code>启动新的线程，在新的线程中执行操作</li>\n<li><code>Schedulers.io()</code>io读写线程，区别于<code>newThread</code>在于<code>io</code>内部的是用一个无数量上限的线程池，可以重用空闲线程，推荐使用。</li>\n<li><code>Schedulers.computation()</code>这个Sheduler使用的固定的线程池，大小为cpu核数，有些操作符或者涉及到运算的情况下使用。</li>\n<li><code>Schedulers.single()</code>任务都在这个单例线程中执行，按<strong>队列</strong>顺序","more":"</li>\n</ol>\n<h4 id=\"指定线程\"><a href=\"#指定线程\" class=\"headerlink\" title=\"指定线程\"></a>指定线程</h4><p>指定<strong>观察者</strong>线程：<code>observerOn(Schedulers)</code><br>指定<strong>被观察者</strong>线程：<code>subScribeOn(Schedulers)</code>  </p>\n<p>恕老衲直言，这个名字起的是真的瘪嘴。</p>\n<p>看例子：</p>\n<pre><code>private fun testThreadWhere() {\n    Observable.create(ObservableOnSubscribe&lt;Long&gt;() {\n        Log.e(TAG, &quot;发射 线程为：${Thread.currentThread().name} &quot;)\n        it.onNext(12L)\n    })\n        .filter {\n            Log.e(TAG, &quot;filter 线程为：${Thread.currentThread().name} $it &quot;)\n            return@filter it &gt; 10\n        }\n        .subscribeOn(Schedulers.io())// 1 指定filter线程 \n        .observeOn(Schedulers.newThread()) // 2 指定map线程\n        .map(Function&lt;Long, String&gt;() {\n            Log.e(TAG, &quot;map 线程为：${Thread.currentThread().name} $it &quot;)\n            return@Function it.toString()\n        })\n        .observeOn(AndroidSchedulers.mainThread())// 3\n        .subscribe {\n            Log.e(TAG, &quot;处理 线程为：${Thread.currentThread().name} $it &quot;)\n        }\n}\n</code></pre><p>看一下结果：<br>其中<br><code>RxCachedThreadScheduler</code>为<code>io</code>线程因为其内部采用的是线程池处理机制。<br><code>RxNewThreadScheduler</code>为<code>newThread</code>线程。</p>\n<pre><code>10-22 16:02:16.199 17797-17855/com.zcy.nidavellir.javaworld E/MainActivity: 发射 线程为：RxCachedThreadScheduler-1 \n10-22 16:02:16.199 17797-17855/com.zcy.nidavellir.javaworld E/MainActivity: filter 线程为：RxCachedThreadScheduler-1 12 \n10-22 16:02:16.200 17797-17856/com.zcy.nidavellir.javaworld E/MainActivity: map 线程为：RxNewThreadScheduler-1 12 \n10-22 16:02:16.251 17797-17797/com.zcy.nidavellir.javaworld E/MainActivity: 处理 线程为：main 12 \n</code></pre><ul>\n<li>如果注释掉 注释中的1 相当于是不指定<strong>被观察者</strong>线程，那么<strong>被观察者</strong>会在当前的<strong>默认线程</strong>也就是<strong>主线程</strong>执行任务。</li>\n<li>如果注释掉 注释中的2 那么filter 和 map 都会在<code>io</code>线程中执行，直到遇到了<code>observerOn</code></li>\n<li>observerOn的下游也就是<strong>观察者</strong>因为指定了<code>AndroidSchedulers.mainThread()</code>所以在<code>mainThread</code>中运行。</li>\n<li>多次指定<code>subscribeOn</code>不生效，以最先指定的线程为准。多次<code>observerOn</code>生效，指定一次对下游直到下一个<code>observerOn</code>中间生效。</li>\n</ul>"},{"title":"Jetpack 全家桶","date":"2019-02-12T06:20:53.000Z","_content":"\n### Jetpack 全家桶\n\n#### DataBinding\n\n[单项绑定](https://o0o0oo00.github.io/2019/02/11/databinding/#more)  \n双向绑定 我们知道 正常的情况下是数据驱动视图，也就是数据改变了，UI也会跟着更新，但是如果是一个EditText 输入框中的内容改变了，我们的数据是不会跟着改变的，这就引申出了**双向绑定** UI视图的变化也会驱动数据的改变，\n\n#### Lifecycle\n**`Lifecycle`** 是一个类，它持有关于组件（如 Activity 或 Fragment）生命周期状态的信息，并且允许其他对象观察此状态。\n\n##### 使用方式：\n\n* 在UIController（Activity/Fragment）中添加**观察者**`getLifecycle().addObserver(mPresenter);//添加LifecycleObserver`\n* 在外部的一个类去实现`LifecycleObserver` 进而就可以去监听到UIController 的各个生命周期的状态改变了。\n\n##### 原理以及重要的类\n\n* LifecycleObserver接口（ Lifecycle观察者）：实现该接口的类，通过注解的方式，可以通过被LifecycleOwner类的addObserver(o: LifecycleObserver)方法注册，被注册后，LifecycleObserver便可以观察到LifecycleOwner的生命周期事件。\n\n\n* LifecycleOwner接口（ Lifecycle持有者）：实现该接口的类持有生命周期(Lifecycle对象)，该接口的生命周期(Lifecycle对象)的改变会被其注册的观察者LifecycleObserver观察到并触发其对应的事件。\n\n`LifecycleOwner` 通常为`Activity`/`Fragment` 而目前AndroidX中已经对其做了封装，我们可以直接使用 持有 的**Lifecycle对象**\n\n* LifecycleRegistry 是 Lifecycle 的一个子类 我们正常通过`getLifecycle()`获取的Lifecycle对象 就是它。\n\n* 当被观察者LifecycleOwner生命周期改变的时候 LifecycleRegistry 就会逐个通知每一个注册的LifecycleObserver ，并执行对应生命周期的方法。\n\n#### ViewModel\n\n**`ViewModel`** 应尽量保证 纯的业务代码，不要持有任何View层(Activity或者Fragment)或Lifecycle的引用\n\n* ViewModel的扩展类会自动保留其数据，如果Activity被重新创建了，它会收到和之前相同的ViewModel实例。当所属Activity终止后，框架调用ViewModel的onCleared()方法释放对应资源。\n\n* ViewModel是有一定的 作用域 的，它不会在指定的作用域内生成更多的实例，从而节省了更多关于 状态维护（数据的存储、序列化和反序列化）的代码。\n\n* 如果ViewModel的作用域为Activity那么 不同的fragment 之间就可以 实现 **数据状态的共享**\n\n* 在对应的作用域内，保正只生产出对应的**唯一实例**，多个Fragment维护相同的数据状态，极大减少了UI组件之间的数据传递的代码成本。\n\n\n#### LiveData\n\n又是观察者模式，允许我们去观察一个变量，当变量发生改变的时候，我们会接收到改变回调，以便于做出响应。\n\n```\nval live = MutableLiveData<String>()\nlive.observe(this, Observer {\n    Toast.makeText(this,it,Toast.LENGTH_SHORT).show()\n})\n```\n\n* 首先我们在调用LiveData.observer()方法时，传递的第一个参数Acitivity实际被向上抽象成为了 LifecycleOwner，第二个参数Observer实际就是我们的观察后的回调。\n\n* RxJava在使用过程中，避免内存泄漏是一个不可忽视的问题，因此我们一般需要借助三方库比如RxLifecycle、AutoDispose来解决这个问题。\n\n* 而反观LiveData，当它被我们的Activity订阅观察之后 Activity如果finish()掉，LiveData本身会自动“清理”以避免内存泄漏。\n\n* 方法内部实际上将我们传入的2个参数包装成了一个新的 LifecycleBoundObserver对象，它实现了 Lifecycle 组件中的LifecycleObserver接口。\n\n* 为什么LiveData能够 自动解除订阅而避免内存泄漏 了，因为它内部能够感应到Activity或者Fragment的生命周期。\n\n* `livedata.observer()` 与 `livedata.observerForever()`前者 只会接收到 observer.mActive == true 时的回调。而后者可以收到所有状态的回调\n\n* 既然LiveData已经能够实现在onDestroy()的生命周期时自动解除订阅，为什么还要多此一举设置一个Active的状态呢？\n\n>Activity并非只有onDestroy()一种状态的，更多时候，新的Activity运行在栈顶，旧的Activity就会运行在 background——这时旧的Activity会执行对应的onPause()和onStop()方法，我们当然不会关心运行在后台的Activity所观察的LiveData对象（即使数据更新了，我们也无从进行对应UI的更新操作），因此LiveData进入 InActive(待定、非活跃)状态，return并且不去执行对应的回调方法，是 非常缜密的优秀设计 。\n\n\n#### Paging\n**`Paging`** 可以使开发者更轻松在 RecyclerView 中 分页加载数据。\n\n","source":"_posts/jetpack.md","raw":"---\ntitle: Jetpack 全家桶\ndate: 2019-02-12 14:20:53\ntags: jetpack\ncategories: 技术\n---\n\n### Jetpack 全家桶\n\n#### DataBinding\n\n[单项绑定](https://o0o0oo00.github.io/2019/02/11/databinding/#more)  \n双向绑定 我们知道 正常的情况下是数据驱动视图，也就是数据改变了，UI也会跟着更新，但是如果是一个EditText 输入框中的内容改变了，我们的数据是不会跟着改变的，这就引申出了**双向绑定** UI视图的变化也会驱动数据的改变，\n\n#### Lifecycle\n**`Lifecycle`** 是一个类，它持有关于组件（如 Activity 或 Fragment）生命周期状态的信息，并且允许其他对象观察此状态。\n\n##### 使用方式：\n\n* 在UIController（Activity/Fragment）中添加**观察者**`getLifecycle().addObserver(mPresenter);//添加LifecycleObserver`\n* 在外部的一个类去实现`LifecycleObserver` 进而就可以去监听到UIController 的各个生命周期的状态改变了。\n\n##### 原理以及重要的类\n\n* LifecycleObserver接口（ Lifecycle观察者）：实现该接口的类，通过注解的方式，可以通过被LifecycleOwner类的addObserver(o: LifecycleObserver)方法注册，被注册后，LifecycleObserver便可以观察到LifecycleOwner的生命周期事件。\n\n\n* LifecycleOwner接口（ Lifecycle持有者）：实现该接口的类持有生命周期(Lifecycle对象)，该接口的生命周期(Lifecycle对象)的改变会被其注册的观察者LifecycleObserver观察到并触发其对应的事件。\n\n`LifecycleOwner` 通常为`Activity`/`Fragment` 而目前AndroidX中已经对其做了封装，我们可以直接使用 持有 的**Lifecycle对象**\n\n* LifecycleRegistry 是 Lifecycle 的一个子类 我们正常通过`getLifecycle()`获取的Lifecycle对象 就是它。\n\n* 当被观察者LifecycleOwner生命周期改变的时候 LifecycleRegistry 就会逐个通知每一个注册的LifecycleObserver ，并执行对应生命周期的方法。\n\n#### ViewModel\n\n**`ViewModel`** 应尽量保证 纯的业务代码，不要持有任何View层(Activity或者Fragment)或Lifecycle的引用\n\n* ViewModel的扩展类会自动保留其数据，如果Activity被重新创建了，它会收到和之前相同的ViewModel实例。当所属Activity终止后，框架调用ViewModel的onCleared()方法释放对应资源。\n\n* ViewModel是有一定的 作用域 的，它不会在指定的作用域内生成更多的实例，从而节省了更多关于 状态维护（数据的存储、序列化和反序列化）的代码。\n\n* 如果ViewModel的作用域为Activity那么 不同的fragment 之间就可以 实现 **数据状态的共享**\n\n* 在对应的作用域内，保正只生产出对应的**唯一实例**，多个Fragment维护相同的数据状态，极大减少了UI组件之间的数据传递的代码成本。\n\n\n#### LiveData\n\n又是观察者模式，允许我们去观察一个变量，当变量发生改变的时候，我们会接收到改变回调，以便于做出响应。\n\n```\nval live = MutableLiveData<String>()\nlive.observe(this, Observer {\n    Toast.makeText(this,it,Toast.LENGTH_SHORT).show()\n})\n```\n\n* 首先我们在调用LiveData.observer()方法时，传递的第一个参数Acitivity实际被向上抽象成为了 LifecycleOwner，第二个参数Observer实际就是我们的观察后的回调。\n\n* RxJava在使用过程中，避免内存泄漏是一个不可忽视的问题，因此我们一般需要借助三方库比如RxLifecycle、AutoDispose来解决这个问题。\n\n* 而反观LiveData，当它被我们的Activity订阅观察之后 Activity如果finish()掉，LiveData本身会自动“清理”以避免内存泄漏。\n\n* 方法内部实际上将我们传入的2个参数包装成了一个新的 LifecycleBoundObserver对象，它实现了 Lifecycle 组件中的LifecycleObserver接口。\n\n* 为什么LiveData能够 自动解除订阅而避免内存泄漏 了，因为它内部能够感应到Activity或者Fragment的生命周期。\n\n* `livedata.observer()` 与 `livedata.observerForever()`前者 只会接收到 observer.mActive == true 时的回调。而后者可以收到所有状态的回调\n\n* 既然LiveData已经能够实现在onDestroy()的生命周期时自动解除订阅，为什么还要多此一举设置一个Active的状态呢？\n\n>Activity并非只有onDestroy()一种状态的，更多时候，新的Activity运行在栈顶，旧的Activity就会运行在 background——这时旧的Activity会执行对应的onPause()和onStop()方法，我们当然不会关心运行在后台的Activity所观察的LiveData对象（即使数据更新了，我们也无从进行对应UI的更新操作），因此LiveData进入 InActive(待定、非活跃)状态，return并且不去执行对应的回调方法，是 非常缜密的优秀设计 。\n\n\n#### Paging\n**`Paging`** 可以使开发者更轻松在 RecyclerView 中 分页加载数据。\n\n","slug":"jetpack","published":1,"updated":"2019-02-28T09:07:48.797Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf121001o5l26ez8ggwk6","content":"<h3 id=\"Jetpack-全家桶\"><a href=\"#Jetpack-全家桶\" class=\"headerlink\" title=\"Jetpack 全家桶\"></a>Jetpack 全家桶</h3><h4 id=\"DataBinding\"><a href=\"#DataBinding\" class=\"headerlink\" title=\"DataBinding\"></a>DataBinding</h4><p><a href=\"https://o0o0oo00.github.io/2019/02/11/databinding/#more\">单项绑定</a><br>双向绑定 我们知道 正常的情况下是数据驱动视图，也就是数据改变了，UI也会跟着更新，但是如果是一个EditText 输入框中的内容改变了，我们的数据是不会跟着改变的，这就引申出了<strong>双向绑定</strong> UI视图的变化也会驱动数据的改变，</p>\n<h4 id=\"Lifecycle\"><a href=\"#Lifecycle\" class=\"headerlink\" title=\"Lifecycle\"></a>Lifecycle</h4><p><strong><code>Lifecycle</code></strong> 是一个类，它持有关于组件（如 Activity 或 Fragment）生命周期状态的信息，并且允许其他对象观察此状态。</p>\n<h5 id=\"使用方式：\"><a href=\"#使用方式：\" class=\"headerlink\" title=\"使用方式：\"></a>使用方式：</h5><ul>\n<li>在UIController（Activity/Fragment）中添加<strong>观察者</strong><code>getLifecycle().addObserver(mPresenter);//添加LifecycleObserver</code></li>\n<li>在外部的一个类去实现<code>LifecycleObserver</code> 进而就可以去监听到UIController 的各个生命周期的状态改变了。</li>\n</ul>\n<h5 id=\"原理以及重要的类\"><a href=\"#原理以及重要的类\" class=\"headerlink\" title=\"原理以及重要的类\"></a>原理以及重要的类</h5><ul>\n<li>LifecycleObserver接口（ Lifecycle观察者）：实现该接口的类，通过注解的方式，可以通过被LifecycleOwner类的addObserver(o: LifecycleObserver)方法注册，被注册后，LifecycleObserver便可以观察到LifecycleOwner的生命周期事件。</li>\n</ul>\n<ul>\n<li>LifecycleOwner接口（ Lifecycle持有者）：实现该接口的类持有生命周期(Lifecycle对象)，该接口的生命周期(Lifecycle对象)的改变会被其注册的观察者LifecycleObserver观察到并触发其对应的事件。</li>\n</ul>\n<p><code>LifecycleOwner</code> 通常为<code>Activity</code>/<code>Fragment</code> 而目前AndroidX中已经对其做了封装，我们可以直接使用 持有 的<strong>Lifecycle对象</strong></p>\n<ul>\n<li><p>LifecycleRegistry 是 Lifecycle 的一个子类 我们正常通过<code>getLifecycle()</code>获取的Lifecycle对象 就是它。</p>\n</li>\n<li><p>当被观察者LifecycleOwner生命周期改变的时候 LifecycleRegistry 就会逐个通知每一个注册的LifecycleObserver ，并执行对应生命周期的方法。</p>\n</li>\n</ul>\n<h4 id=\"ViewModel\"><a href=\"#ViewModel\" class=\"headerlink\" title=\"ViewModel\"></a>ViewModel</h4><p><strong><code>ViewModel</code></strong> 应尽量保证 纯的业务代码，不要持有任何View层(Activity或者Fragment)或Lifecycle的引用</p>\n<ul>\n<li><p>ViewModel的扩展类会自动保留其数据，如果Activity被重新创建了，它会收到和之前相同的ViewModel实例。当所属Activity终止后，框架调用ViewModel的onCleared()方法释放对应资源。</p>\n</li>\n<li><p>ViewModel是有一定的 作用域 的，它不会在指定的作用域内生成更多的实例，从而节省了更多关于 状态维护（数据的存储、序列化和反序列化）的代码。</p>\n</li>\n<li><p>如果ViewModel的作用域为Activity那么 不同的fragment 之间就可以 实现 <strong>数据状态的共享</strong></p>\n</li>\n<li><p>在对应的作用域内，保正只生产出对应的<strong>唯一实例</strong>，多个Fragment维护相同的数据状态，极大减少了UI组件之间的数据传递的代码成本。</p>\n</li>\n</ul>\n<h4 id=\"LiveData\"><a href=\"#LiveData\" class=\"headerlink\" title=\"LiveData\"></a>LiveData</h4><p>又是观察者模式，允许我们去观察一个变量，当变量发生改变的时候，我们会接收到改变回调，以便于做出响应。</p>\n<pre><code>val live = MutableLiveData&lt;String&gt;()\nlive.observe(this, Observer {\n    Toast.makeText(this,it,Toast.LENGTH_SHORT).show()\n})\n</code></pre><ul>\n<li><p>首先我们在调用LiveData.observer()方法时，传递的第一个参数Acitivity实际被向上抽象成为了 LifecycleOwner，第二个参数Observer实际就是我们的观察后的回调。</p>\n</li>\n<li><p>RxJava在使用过程中，避免内存泄漏是一个不可忽视的问题，因此我们一般需要借助三方库比如RxLifecycle、AutoDispose来解决这个问题。</p>\n</li>\n<li><p>而反观LiveData，当它被我们的Activity订阅观察之后 Activity如果finish()掉，LiveData本身会自动“清理”以避免内存泄漏。</p>\n</li>\n<li><p>方法内部实际上将我们传入的2个参数包装成了一个新的 LifecycleBoundObserver对象，它实现了 Lifecycle 组件中的LifecycleObserver接口。</p>\n</li>\n<li><p>为什么LiveData能够 自动解除订阅而避免内存泄漏 了，因为它内部能够感应到Activity或者Fragment的生命周期。</p>\n</li>\n<li><p><code>livedata.observer()</code> 与 <code>livedata.observerForever()</code>前者 只会接收到 observer.mActive == true 时的回调。而后者可以收到所有状态的回调</p>\n</li>\n<li><p>既然LiveData已经能够实现在onDestroy()的生命周期时自动解除订阅，为什么还要多此一举设置一个Active的状态呢？</p>\n</li>\n</ul>\n<blockquote>\n<p>Activity并非只有onDestroy()一种状态的，更多时候，新的Activity运行在栈顶，旧的Activity就会运行在 background——这时旧的Activity会执行对应的onPause()和onStop()方法，我们当然不会关心运行在后台的Activity所观察的LiveData对象（即使数据更新了，我们也无从进行对应UI的更新操作），因此LiveData进入 InActive(待定、非活跃)状态，return并且不去执行对应的回调方法，是 非常缜密的优秀设计 。</p>\n</blockquote>\n<h4 id=\"Paging\"><a href=\"#Paging\" class=\"headerlink\" title=\"Paging\"></a>Paging</h4><p><strong><code>Paging</code></strong> 可以使开发者更轻松在 RecyclerView 中 分页加载数据。</p>\n","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"","more":"<h3 id=\"Jetpack-全家桶\"><a href=\"#Jetpack-全家桶\" class=\"headerlink\" title=\"Jetpack 全家桶\"></a>Jetpack 全家桶</h3><h4 id=\"DataBinding\"><a href=\"#DataBinding\" class=\"headerlink\" title=\"DataBinding\"></a>DataBinding</h4><p><a href=\"https://o0o0oo00.github.io/2019/02/11/databinding/#more\">单项绑定</a><br>双向绑定 我们知道 正常的情况下是数据驱动视图，也就是数据改变了，UI也会跟着更新，但是如果是一个EditText 输入框中的内容改变了，我们的数据是不会跟着改变的，这就引申出了<strong>双向绑定</strong> UI视图的变化也会驱动数据的改变，</p>\n<h4 id=\"Lifecycle\"><a href=\"#Lifecycle\" class=\"headerlink\" title=\"Lifecycle\"></a>Lifecycle</h4><p><strong><code>Lifecycle</code></strong> 是一个类，它持有关于组件（如 Activity 或 Fragment）生命周期状态的信息，并且允许其他对象观察此状态。</p>\n<h5 id=\"使用方式：\"><a href=\"#使用方式：\" class=\"headerlink\" title=\"使用方式：\"></a>使用方式：</h5><ul>\n<li>在UIController（Activity/Fragment）中添加<strong>观察者</strong><code>getLifecycle().addObserver(mPresenter);//添加LifecycleObserver</code></li>\n<li>在外部的一个类去实现<code>LifecycleObserver</code> 进而就可以去监听到UIController 的各个生命周期的状态改变了。</li>\n</ul>\n<h5 id=\"原理以及重要的类\"><a href=\"#原理以及重要的类\" class=\"headerlink\" title=\"原理以及重要的类\"></a>原理以及重要的类</h5><ul>\n<li>LifecycleObserver接口（ Lifecycle观察者）：实现该接口的类，通过注解的方式，可以通过被LifecycleOwner类的addObserver(o: LifecycleObserver)方法注册，被注册后，LifecycleObserver便可以观察到LifecycleOwner的生命周期事件。</li>\n</ul>\n<ul>\n<li>LifecycleOwner接口（ Lifecycle持有者）：实现该接口的类持有生命周期(Lifecycle对象)，该接口的生命周期(Lifecycle对象)的改变会被其注册的观察者LifecycleObserver观察到并触发其对应的事件。</li>\n</ul>\n<p><code>LifecycleOwner</code> 通常为<code>Activity</code>/<code>Fragment</code> 而目前AndroidX中已经对其做了封装，我们可以直接使用 持有 的<strong>Lifecycle对象</strong></p>\n<ul>\n<li><p>LifecycleRegistry 是 Lifecycle 的一个子类 我们正常通过<code>getLifecycle()</code>获取的Lifecycle对象 就是它。</p>\n</li>\n<li><p>当被观察者LifecycleOwner生命周期改变的时候 LifecycleRegistry 就会逐个通知每一个注册的LifecycleObserver ，并执行对应生命周期的方法。</p>\n</li>\n</ul>\n<h4 id=\"ViewModel\"><a href=\"#ViewModel\" class=\"headerlink\" title=\"ViewModel\"></a>ViewModel</h4><p><strong><code>ViewModel</code></strong> 应尽量保证 纯的业务代码，不要持有任何View层(Activity或者Fragment)或Lifecycle的引用</p>\n<ul>\n<li><p>ViewModel的扩展类会自动保留其数据，如果Activity被重新创建了，它会收到和之前相同的ViewModel实例。当所属Activity终止后，框架调用ViewModel的onCleared()方法释放对应资源。</p>\n</li>\n<li><p>ViewModel是有一定的 作用域 的，它不会在指定的作用域内生成更多的实例，从而节省了更多关于 状态维护（数据的存储、序列化和反序列化）的代码。</p>\n</li>\n<li><p>如果ViewModel的作用域为Activity那么 不同的fragment 之间就可以 实现 <strong>数据状态的共享</strong></p>\n</li>\n<li><p>在对应的作用域内，保正只生产出对应的<strong>唯一实例</strong>，多个Fragment维护相同的数据状态，极大减少了UI组件之间的数据传递的代码成本。</p>\n</li>\n</ul>\n<h4 id=\"LiveData\"><a href=\"#LiveData\" class=\"headerlink\" title=\"LiveData\"></a>LiveData</h4><p>又是观察者模式，允许我们去观察一个变量，当变量发生改变的时候，我们会接收到改变回调，以便于做出响应。</p>\n<pre><code>val live = MutableLiveData&lt;String&gt;()\nlive.observe(this, Observer {\n    Toast.makeText(this,it,Toast.LENGTH_SHORT).show()\n})\n</code></pre><ul>\n<li><p>首先我们在调用LiveData.observer()方法时，传递的第一个参数Acitivity实际被向上抽象成为了 LifecycleOwner，第二个参数Observer实际就是我们的观察后的回调。</p>\n</li>\n<li><p>RxJava在使用过程中，避免内存泄漏是一个不可忽视的问题，因此我们一般需要借助三方库比如RxLifecycle、AutoDispose来解决这个问题。</p>\n</li>\n<li><p>而反观LiveData，当它被我们的Activity订阅观察之后 Activity如果finish()掉，LiveData本身会自动“清理”以避免内存泄漏。</p>\n</li>\n<li><p>方法内部实际上将我们传入的2个参数包装成了一个新的 LifecycleBoundObserver对象，它实现了 Lifecycle 组件中的LifecycleObserver接口。</p>\n</li>\n<li><p>为什么LiveData能够 自动解除订阅而避免内存泄漏 了，因为它内部能够感应到Activity或者Fragment的生命周期。</p>\n</li>\n<li><p><code>livedata.observer()</code> 与 <code>livedata.observerForever()</code>前者 只会接收到 observer.mActive == true 时的回调。而后者可以收到所有状态的回调</p>\n</li>\n<li><p>既然LiveData已经能够实现在onDestroy()的生命周期时自动解除订阅，为什么还要多此一举设置一个Active的状态呢？</p>\n</li>\n</ul>\n<blockquote>\n<p>Activity并非只有onDestroy()一种状态的，更多时候，新的Activity运行在栈顶，旧的Activity就会运行在 background——这时旧的Activity会执行对应的onPause()和onStop()方法，我们当然不会关心运行在后台的Activity所观察的LiveData对象（即使数据更新了，我们也无从进行对应UI的更新操作），因此LiveData进入 InActive(待定、非活跃)状态，return并且不去执行对应的回调方法，是 非常缜密的优秀设计 。</p>\n</blockquote>\n<h4 id=\"Paging\"><a href=\"#Paging\" class=\"headerlink\" title=\"Paging\"></a>Paging</h4><p><strong><code>Paging</code></strong> 可以使开发者更轻松在 RecyclerView 中 分页加载数据。</p>\n"},{"title":"twitter 登录 分享","date":"2018-09-18T07:51:54.000Z","_content":"### Twitter 登录\n#### 1、添加依赖：\n**implementation 'com.twitter.sdk.android:twitter:3.1.1'  \nimplementation 'com.twitter.sdk.android:tweet-composer:3.1.1'**\n<!--more-->\n#### 2、添加KEY SECRET\n在value string 文件夹下面\n```\n<string name=\"com.twitter.sdk.android.CONSUMER_KEY\">uy0CK2sjygumtE7J445NQB9s4</string>  \n```\n```\n<string name=\"com.twitter.sdk.android.CONSUMER_SECRET\">3bI33NoTXqTGV5JIU0MmVlllqygY55CHWNOXTsTnKiho3MbbPO</string>\n```\n#### 3、初始化Twitter\nApplication 中 **Twitter.initialize(this)**\n\n#### 4、Activity / fragment 的布局中加loggin button\n```\n<com.twitter.sdk.android.core.identity.TwitterLoginButton\nandroid:id=\"@+id/loginButton\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"wrap_content\" />\n```\n##### 登录回调\n```\nloginButton.callback = object : Callback<TwitterSession>() {\noverride fun success(result: Result<TwitterSession>) {\nToast.makeText(this@MainActivity, \"login success\", Toast.LENGTH_SHORT).show()\n}\n\noverride fun failure(exception: TwitterException) {\nToast.makeText(this@MainActivity, \"login failure\", Toast.LENGTH_SHORT).show()\n}\n}\n\n```\n##### 启动logginButton回调\n```\noverride fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\nsuper.onActivityResult(requestCode, resultCode, data)\nloginButton.onActivityResult(requestCode, resultCode, data)\n}\n\n```\n##### 拿到用户信息\n```\nfun requestUser() {\nval apiClient = TwitterCore.getInstance().apiClient\nval call = apiClient.accountService.verifyCredentials(true, false, true)\ncall.enqueue(object : Callback<User>() {\noverride fun success(result: Result<User>) {\nLog.e(\"123\", result.data?.let {\nit.name + it.id + it.idStr\n})\n}\n\noverride fun failure(exception: TwitterException?) {\nLog.e(\"123\", \"get user failure\")\n}\n\n})\n}\n```\n\n### Twitter分享\n\n#### 两种方式分享\n##### 1、Launching Twitter Composer 无回调\n```\ntry {\nval builder = TweetComposer.Builder(this@MainActivity)\n.url(URL(\"https://www.google.com/\"))\n.text(\"nice to meet you\")\nbuilder.show()\n} catch (e: MalformedURLException) {\ne.printStackTrace()\n}\n```\n##### 2、Twitter Kit Native Composer 有回调\n```\nval session = TwitterCore.getInstance().sessionManager?.activeSession\nsession?.let {\nval intent = ComposerActivity.Builder(this@MainActivity)\n.session(session)\n.text(\"Love where you work\")\n.hashtags(\"#twitter\")\n.createIntent()\nstartActivity(intent)\n}\n```\n回调采用的是广播方式：\n```\nclass MyResultReceiver : BroadcastReceiver() {\noverride fun onReceive(context: Context?, intent: Intent) {\nif (TweetUploadService.UPLOAD_SUCCESS == intent.action) {\n// success Twitter分享成功的回调\nToast.makeText(context, \"分享成功的回调\", Toast.LENGTH_SHORT).show()\nval tweetId = intent.extras.getLong(TweetUploadService.EXTRA_TWEET_ID);\n} else {\nToast.makeText(context, \"分享failure的回调\", Toast.LENGTH_SHORT).show()\n// failure\n//            val retryIntent = intent.extras.getParcelable(TweetUploadService.EXTRA_RETRY_INTENT);\n}\n}\n}\n```\n注册广播：\n```\n<receiver\nandroid:name=\".MyResultReceiver\"\nandroid:exported=\"false\">\n<intent-filter>\n<action android:name=\"com.twitter.sdk.android.tweetcomposer.UPLOAD_SUCCESS\" />\n<action android:name=\"com.twitter.sdk.android.tweetcomposer.UPLOAD_FAILURE\" />\n<action android:name=\"com.twitter.sdk.android.tweetcomposer.TWEET_COMPOSE_CANCEL\"/>\n</intent-filter>\n</receiver>\n```\n","source":"_posts/twitter.md","raw":"---\ntitle: twitter 登录 分享\ndate: 2018-09-18 15:51:54\ncategories: 技术\ntag : android\n---\n### Twitter 登录\n#### 1、添加依赖：\n**implementation 'com.twitter.sdk.android:twitter:3.1.1'  \nimplementation 'com.twitter.sdk.android:tweet-composer:3.1.1'**\n<!--more-->\n#### 2、添加KEY SECRET\n在value string 文件夹下面\n```\n<string name=\"com.twitter.sdk.android.CONSUMER_KEY\">uy0CK2sjygumtE7J445NQB9s4</string>  \n```\n```\n<string name=\"com.twitter.sdk.android.CONSUMER_SECRET\">3bI33NoTXqTGV5JIU0MmVlllqygY55CHWNOXTsTnKiho3MbbPO</string>\n```\n#### 3、初始化Twitter\nApplication 中 **Twitter.initialize(this)**\n\n#### 4、Activity / fragment 的布局中加loggin button\n```\n<com.twitter.sdk.android.core.identity.TwitterLoginButton\nandroid:id=\"@+id/loginButton\"\nandroid:layout_width=\"match_parent\"\nandroid:layout_height=\"wrap_content\" />\n```\n##### 登录回调\n```\nloginButton.callback = object : Callback<TwitterSession>() {\noverride fun success(result: Result<TwitterSession>) {\nToast.makeText(this@MainActivity, \"login success\", Toast.LENGTH_SHORT).show()\n}\n\noverride fun failure(exception: TwitterException) {\nToast.makeText(this@MainActivity, \"login failure\", Toast.LENGTH_SHORT).show()\n}\n}\n\n```\n##### 启动logginButton回调\n```\noverride fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\nsuper.onActivityResult(requestCode, resultCode, data)\nloginButton.onActivityResult(requestCode, resultCode, data)\n}\n\n```\n##### 拿到用户信息\n```\nfun requestUser() {\nval apiClient = TwitterCore.getInstance().apiClient\nval call = apiClient.accountService.verifyCredentials(true, false, true)\ncall.enqueue(object : Callback<User>() {\noverride fun success(result: Result<User>) {\nLog.e(\"123\", result.data?.let {\nit.name + it.id + it.idStr\n})\n}\n\noverride fun failure(exception: TwitterException?) {\nLog.e(\"123\", \"get user failure\")\n}\n\n})\n}\n```\n\n### Twitter分享\n\n#### 两种方式分享\n##### 1、Launching Twitter Composer 无回调\n```\ntry {\nval builder = TweetComposer.Builder(this@MainActivity)\n.url(URL(\"https://www.google.com/\"))\n.text(\"nice to meet you\")\nbuilder.show()\n} catch (e: MalformedURLException) {\ne.printStackTrace()\n}\n```\n##### 2、Twitter Kit Native Composer 有回调\n```\nval session = TwitterCore.getInstance().sessionManager?.activeSession\nsession?.let {\nval intent = ComposerActivity.Builder(this@MainActivity)\n.session(session)\n.text(\"Love where you work\")\n.hashtags(\"#twitter\")\n.createIntent()\nstartActivity(intent)\n}\n```\n回调采用的是广播方式：\n```\nclass MyResultReceiver : BroadcastReceiver() {\noverride fun onReceive(context: Context?, intent: Intent) {\nif (TweetUploadService.UPLOAD_SUCCESS == intent.action) {\n// success Twitter分享成功的回调\nToast.makeText(context, \"分享成功的回调\", Toast.LENGTH_SHORT).show()\nval tweetId = intent.extras.getLong(TweetUploadService.EXTRA_TWEET_ID);\n} else {\nToast.makeText(context, \"分享failure的回调\", Toast.LENGTH_SHORT).show()\n// failure\n//            val retryIntent = intent.extras.getParcelable(TweetUploadService.EXTRA_RETRY_INTENT);\n}\n}\n}\n```\n注册广播：\n```\n<receiver\nandroid:name=\".MyResultReceiver\"\nandroid:exported=\"false\">\n<intent-filter>\n<action android:name=\"com.twitter.sdk.android.tweetcomposer.UPLOAD_SUCCESS\" />\n<action android:name=\"com.twitter.sdk.android.tweetcomposer.UPLOAD_FAILURE\" />\n<action android:name=\"com.twitter.sdk.android.tweetcomposer.TWEET_COMPOSE_CANCEL\"/>\n</intent-filter>\n</receiver>\n```\n","slug":"twitter","published":1,"updated":"2019-02-28T09:09:45.436Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf122001r5l26u0fshvhw","content":"<h3 id=\"Twitter-登录\"><a href=\"#Twitter-登录\" class=\"headerlink\" title=\"Twitter 登录\"></a>Twitter 登录</h3><h4 id=\"1、添加依赖：\"><a href=\"#1、添加依赖：\" class=\"headerlink\" title=\"1、添加依赖：\"></a>1、添加依赖：</h4><p><strong>implementation ‘com.twitter.sdk.android:twitter:3.1.1’<br>implementation ‘com.twitter.sdk.android:tweet-composer:3.1.1’</strong><br><a id=\"more\"></a></p>\n<h4 id=\"2、添加KEY-SECRET\"><a href=\"#2、添加KEY-SECRET\" class=\"headerlink\" title=\"2、添加KEY SECRET\"></a>2、添加KEY SECRET</h4><p>在value string 文件夹下面</p>\n<pre><code>&lt;string name=&quot;com.twitter.sdk.android.CONSUMER_KEY&quot;&gt;uy0CK2sjygumtE7J445NQB9s4&lt;/string&gt;  \n</code></pre><pre><code>&lt;string name=&quot;com.twitter.sdk.android.CONSUMER_SECRET&quot;&gt;3bI33NoTXqTGV5JIU0MmVlllqygY55CHWNOXTsTnKiho3MbbPO&lt;/string&gt;\n</code></pre><h4 id=\"3、初始化Twitter\"><a href=\"#3、初始化Twitter\" class=\"headerlink\" title=\"3、初始化Twitter\"></a>3、初始化Twitter</h4><p>Application 中 <strong>Twitter.initialize(this)</strong></p>\n<h4 id=\"4、Activity-fragment-的布局中加loggin-button\"><a href=\"#4、Activity-fragment-的布局中加loggin-button\" class=\"headerlink\" title=\"4、Activity / fragment 的布局中加loggin button\"></a>4、Activity / fragment 的布局中加loggin button</h4><pre><code>&lt;com.twitter.sdk.android.core.identity.TwitterLoginButton\nandroid:id=&quot;@+id/loginButton&quot;\nandroid:layout_width=&quot;match_parent&quot;\nandroid:layout_height=&quot;wrap_content&quot; /&gt;\n</code></pre><h5 id=\"登录回调\"><a href=\"#登录回调\" class=\"headerlink\" title=\"登录回调\"></a>登录回调</h5><pre><code>loginButton.callback = object : Callback&lt;TwitterSession&gt;() {\noverride fun success(result: Result&lt;TwitterSession&gt;) {\nToast.makeText(this@MainActivity, &quot;login success&quot;, Toast.LENGTH_SHORT).show()\n}\n\noverride fun failure(exception: TwitterException) {\nToast.makeText(this@MainActivity, &quot;login failure&quot;, Toast.LENGTH_SHORT).show()\n}\n}\n\n</code></pre><h5 id=\"启动logginButton回调\"><a href=\"#启动logginButton回调\" class=\"headerlink\" title=\"启动logginButton回调\"></a>启动logginButton回调</h5><pre><code>override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\nsuper.onActivityResult(requestCode, resultCode, data)\nloginButton.onActivityResult(requestCode, resultCode, data)\n}\n\n</code></pre><h5 id=\"拿到用户信息\"><a href=\"#拿到用户信息\" class=\"headerlink\" title=\"拿到用户信息\"></a>拿到用户信息</h5><pre><code>fun requestUser() {\nval apiClient = TwitterCore.getInstance().apiClient\nval call = apiClient.accountService.verifyCredentials(true, false, true)\ncall.enqueue(object : Callback&lt;User&gt;() {\noverride fun success(result: Result&lt;User&gt;) {\nLog.e(&quot;123&quot;, result.data?.let {\nit.name + it.id + it.idStr\n})\n}\n\noverride fun failure(exception: TwitterException?) {\nLog.e(&quot;123&quot;, &quot;get user failure&quot;)\n}\n\n})\n}\n</code></pre><h3 id=\"Twitter分享\"><a href=\"#Twitter分享\" class=\"headerlink\" title=\"Twitter分享\"></a>Twitter分享</h3><h4 id=\"两种方式分享\"><a href=\"#两种方式分享\" class=\"headerlink\" title=\"两种方式分享\"></a>两种方式分享</h4><h5 id=\"1、Launching-Twitter-Composer-无回调\"><a href=\"#1、Launching-Twitter-Composer-无回调\" class=\"headerlink\" title=\"1、Launching Twitter Composer 无回调\"></a>1、Launching Twitter Composer 无回调</h5><pre><code>try {\nval builder = TweetComposer.Builder(this@MainActivity)\n.url(URL(&quot;https://www.google.com/&quot;))\n.text(&quot;nice to meet you&quot;)\nbuilder.show()\n} catch (e: MalformedURLException) {\ne.printStackTrace()\n}\n</code></pre><h5 id=\"2、Twitter-Kit-Native-Composer-有回调\"><a href=\"#2、Twitter-Kit-Native-Composer-有回调\" class=\"headerlink\" title=\"2、Twitter Kit Native Composer 有回调\"></a>2、Twitter Kit Native Composer 有回调</h5><pre><code>val session = TwitterCore.getInstance().sessionManager?.activeSession\nsession?.let {\nval intent = ComposerActivity.Builder(this@MainActivity)\n.session(session)\n.text(&quot;Love where you work&quot;)\n.hashtags(&quot;#twitter&quot;)\n.createIntent()\nstartActivity(intent)\n}\n</code></pre><p>回调采用的是广播方式：</p>\n<pre><code>class MyResultReceiver : BroadcastReceiver() {\noverride fun onReceive(context: Context?, intent: Intent) {\nif (TweetUploadService.UPLOAD_SUCCESS == intent.action) {\n// success Twitter分享成功的回调\nToast.makeText(context, &quot;分享成功的回调&quot;, Toast.LENGTH_SHORT).show()\nval tweetId = intent.extras.getLong(TweetUploadService.EXTRA_TWEET_ID);\n} else {\nToast.makeText(context, &quot;分享failure的回调&quot;, Toast.LENGTH_SHORT).show()\n// failure\n//            val retryIntent = intent.extras.getParcelable(TweetUploadService.EXTRA_RETRY_INTENT);\n}\n}\n}\n</code></pre><p>注册广播：</p>\n<pre><code>&lt;receiver\nandroid:name=&quot;.MyResultReceiver&quot;\nandroid:exported=&quot;false&quot;&gt;\n&lt;intent-filter&gt;\n&lt;action android:name=&quot;com.twitter.sdk.android.tweetcomposer.UPLOAD_SUCCESS&quot; /&gt;\n&lt;action android:name=&quot;com.twitter.sdk.android.tweetcomposer.UPLOAD_FAILURE&quot; /&gt;\n&lt;action android:name=&quot;com.twitter.sdk.android.tweetcomposer.TWEET_COMPOSE_CANCEL&quot;/&gt;\n&lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre>","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"<h3 id=\"Twitter-登录\"><a href=\"#Twitter-登录\" class=\"headerlink\" title=\"Twitter 登录\"></a>Twitter 登录</h3><h4 id=\"1、添加依赖：\"><a href=\"#1、添加依赖：\" class=\"headerlink\" title=\"1、添加依赖：\"></a>1、添加依赖：</h4><p><strong>implementation ‘com.twitter.sdk.android:twitter:3.1.1’<br>implementation ‘com.twitter.sdk.android:tweet-composer:3.1.1’</strong><br>","more":"</p>\n<h4 id=\"2、添加KEY-SECRET\"><a href=\"#2、添加KEY-SECRET\" class=\"headerlink\" title=\"2、添加KEY SECRET\"></a>2、添加KEY SECRET</h4><p>在value string 文件夹下面</p>\n<pre><code>&lt;string name=&quot;com.twitter.sdk.android.CONSUMER_KEY&quot;&gt;uy0CK2sjygumtE7J445NQB9s4&lt;/string&gt;  \n</code></pre><pre><code>&lt;string name=&quot;com.twitter.sdk.android.CONSUMER_SECRET&quot;&gt;3bI33NoTXqTGV5JIU0MmVlllqygY55CHWNOXTsTnKiho3MbbPO&lt;/string&gt;\n</code></pre><h4 id=\"3、初始化Twitter\"><a href=\"#3、初始化Twitter\" class=\"headerlink\" title=\"3、初始化Twitter\"></a>3、初始化Twitter</h4><p>Application 中 <strong>Twitter.initialize(this)</strong></p>\n<h4 id=\"4、Activity-fragment-的布局中加loggin-button\"><a href=\"#4、Activity-fragment-的布局中加loggin-button\" class=\"headerlink\" title=\"4、Activity / fragment 的布局中加loggin button\"></a>4、Activity / fragment 的布局中加loggin button</h4><pre><code>&lt;com.twitter.sdk.android.core.identity.TwitterLoginButton\nandroid:id=&quot;@+id/loginButton&quot;\nandroid:layout_width=&quot;match_parent&quot;\nandroid:layout_height=&quot;wrap_content&quot; /&gt;\n</code></pre><h5 id=\"登录回调\"><a href=\"#登录回调\" class=\"headerlink\" title=\"登录回调\"></a>登录回调</h5><pre><code>loginButton.callback = object : Callback&lt;TwitterSession&gt;() {\noverride fun success(result: Result&lt;TwitterSession&gt;) {\nToast.makeText(this@MainActivity, &quot;login success&quot;, Toast.LENGTH_SHORT).show()\n}\n\noverride fun failure(exception: TwitterException) {\nToast.makeText(this@MainActivity, &quot;login failure&quot;, Toast.LENGTH_SHORT).show()\n}\n}\n\n</code></pre><h5 id=\"启动logginButton回调\"><a href=\"#启动logginButton回调\" class=\"headerlink\" title=\"启动logginButton回调\"></a>启动logginButton回调</h5><pre><code>override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\nsuper.onActivityResult(requestCode, resultCode, data)\nloginButton.onActivityResult(requestCode, resultCode, data)\n}\n\n</code></pre><h5 id=\"拿到用户信息\"><a href=\"#拿到用户信息\" class=\"headerlink\" title=\"拿到用户信息\"></a>拿到用户信息</h5><pre><code>fun requestUser() {\nval apiClient = TwitterCore.getInstance().apiClient\nval call = apiClient.accountService.verifyCredentials(true, false, true)\ncall.enqueue(object : Callback&lt;User&gt;() {\noverride fun success(result: Result&lt;User&gt;) {\nLog.e(&quot;123&quot;, result.data?.let {\nit.name + it.id + it.idStr\n})\n}\n\noverride fun failure(exception: TwitterException?) {\nLog.e(&quot;123&quot;, &quot;get user failure&quot;)\n}\n\n})\n}\n</code></pre><h3 id=\"Twitter分享\"><a href=\"#Twitter分享\" class=\"headerlink\" title=\"Twitter分享\"></a>Twitter分享</h3><h4 id=\"两种方式分享\"><a href=\"#两种方式分享\" class=\"headerlink\" title=\"两种方式分享\"></a>两种方式分享</h4><h5 id=\"1、Launching-Twitter-Composer-无回调\"><a href=\"#1、Launching-Twitter-Composer-无回调\" class=\"headerlink\" title=\"1、Launching Twitter Composer 无回调\"></a>1、Launching Twitter Composer 无回调</h5><pre><code>try {\nval builder = TweetComposer.Builder(this@MainActivity)\n.url(URL(&quot;https://www.google.com/&quot;))\n.text(&quot;nice to meet you&quot;)\nbuilder.show()\n} catch (e: MalformedURLException) {\ne.printStackTrace()\n}\n</code></pre><h5 id=\"2、Twitter-Kit-Native-Composer-有回调\"><a href=\"#2、Twitter-Kit-Native-Composer-有回调\" class=\"headerlink\" title=\"2、Twitter Kit Native Composer 有回调\"></a>2、Twitter Kit Native Composer 有回调</h5><pre><code>val session = TwitterCore.getInstance().sessionManager?.activeSession\nsession?.let {\nval intent = ComposerActivity.Builder(this@MainActivity)\n.session(session)\n.text(&quot;Love where you work&quot;)\n.hashtags(&quot;#twitter&quot;)\n.createIntent()\nstartActivity(intent)\n}\n</code></pre><p>回调采用的是广播方式：</p>\n<pre><code>class MyResultReceiver : BroadcastReceiver() {\noverride fun onReceive(context: Context?, intent: Intent) {\nif (TweetUploadService.UPLOAD_SUCCESS == intent.action) {\n// success Twitter分享成功的回调\nToast.makeText(context, &quot;分享成功的回调&quot;, Toast.LENGTH_SHORT).show()\nval tweetId = intent.extras.getLong(TweetUploadService.EXTRA_TWEET_ID);\n} else {\nToast.makeText(context, &quot;分享failure的回调&quot;, Toast.LENGTH_SHORT).show()\n// failure\n//            val retryIntent = intent.extras.getParcelable(TweetUploadService.EXTRA_RETRY_INTENT);\n}\n}\n}\n</code></pre><p>注册广播：</p>\n<pre><code>&lt;receiver\nandroid:name=&quot;.MyResultReceiver&quot;\nandroid:exported=&quot;false&quot;&gt;\n&lt;intent-filter&gt;\n&lt;action android:name=&quot;com.twitter.sdk.android.tweetcomposer.UPLOAD_SUCCESS&quot; /&gt;\n&lt;action android:name=&quot;com.twitter.sdk.android.tweetcomposer.UPLOAD_FAILURE&quot; /&gt;\n&lt;action android:name=&quot;com.twitter.sdk.android.tweetcomposer.TWEET_COMPOSE_CANCEL&quot;/&gt;\n&lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</code></pre>"},{"title":"RxJava - 异步","date":"2018-10-15T09:27:52.000Z","_content":"# RxJava - 异步\n\n### Observable(被观察者)的创建\n它没有公开的构造方法，是通过内部的Create方法来创建一个\n\n```\nObservable<String> observable = Observable.create(new Observable.OnSubscribe<String>() {\n@Override\npublic void call(Subscriber<? super String> subscriber) {}\n});\n```\n我们可以看到，call方法的参数是是一个观察者，也就是持有**观察者**的引用，**被观察者**做了一些操作以后，通过`subscriber.onNext/onComplete` 来实现**响应式**\n<!--more-->\n### Subscriber/Observer(观察者)的创建\n\nSubscriber 对 Observer 接口进行了一些扩展，但他们的基本使用方式是完全一样的\n\n```\nSubscriber<String> subscriber = new Subscriber<String>() {\n@Override\npublic void onCompleted() {\n\n}\n\n@Override\npublic void onError(Throwable e) {\n\n}\n\n@Override\npublic void onNext(String s) {\nSystem.out.println(\"subscriber\" + s);\n}\n};\n\nObserver<String> observer = new Observer<String>() {\n@Override\npublic void onCompleted() {\n\n}\n\n@Override\npublic void onError(Throwable e) {\n\n}\n\n@Override\npublic void onNext(String s) {\nSystem.out.println(\"observer\"+s);\n}\n};\n```\n### 观察者响应被观察者\n我们知道[观察者模式](https://o0o0oo00.github.io/2018/10/09/Observer/#more)，是**被观察者持有观察者**的引用，进而遍历所有观察者，调用（通知）其方法来达到响应的目的。\n所以我们看RxJava中的关联方式是通过**被观察者订阅观察者**observable.subscribe(observer/subscriber)来实现的。这个地方可能与概念有些不贴切，因为概念是观察者要响应的是被观察者，所以这里通过**被观察者订阅观察者**来达到**观察者响应被观察者**的目的\n\n1. 创建被观察者`Observable`与观察者`Observer`对象\n2. 观察者订阅被观察者，实际是**观察者**当做参数传入**被观察者** `observable.subscribe(observer);`\n3. **被观察者**`Observable`的重写方法`call()`中调用**观察者**`Observer`的`onNext`方法。然后`Observer`**重写**的`onNext`进行相应的处理\n\n### Observable的其他创建方式\n#### Observable.just(t : T) 具有多个参数的重载方法，源码中就有多达10个参数的重载方法。\n\n例如：相当于执行`call`方法中的`subscriber.``onNext(\"123\")``onNext(\"234\")``onCompleted()`\n\n```\nObservable.just(\"123\",\"234\").subscribe(new Observer<String>() {\n@Override\npublic void onCompleted() {\n\n}\n\n@Override\npublic void onError(Throwable e) {\n\n}\n\n@Override\npublic void onNext(String s) {\nSystem.out.println(s);\n}\n});\n\n```\n#### Observable.from(Iterable<? extends T> iterable)\n\n`from(Iterable<? extends T> iterable)`**支持从数组或者是实现了Iterator接口的集合中接收参数**  \n例如：这两种方式\n\n```\nObservable.from(new String[]{\"345\",\"456\"}).subscribe(new Observer<String>() {\n@Override\npublic void onCompleted() {\n\n}\n\n@Override\npublic void onError(Throwable e) {\n\n}\n\n@Override\npublic void onNext(String s) {\nSystem.out.println(s);\n}\n});\n```\n```\nList<String> list = new ArrayList<>();\nlist.add(\"567\");\nlist.add(\"678\");\nObservable.from(list).subscribe(new Observer<String>() {\n@Override\npublic void onCompleted() {\nSystem.out.println(\"onCompleted\");\n}\n\n@Override\npublic void onError(Throwable e) {\n\n}\n\n@Override\npublic void onNext(String s) {\nSystem.out.println(s);\n}\n});\n```\n**PostScript**：当just参数在2个以上时，实际上内部调用的也是from(T[] array)方法。\n\n#### `Action0`、`Action1<T>` ... `Action9<T1, T2, T3, T4, T5, T6, T7, T8, T9> `\n0个参数的Action,1个参数的Action  \nAction0 可以被当成一个包装对象，将 onCompleted() 的内容打包起来将自己作为一个参数传入 subscribe() 以实现不完整定义的回调。由于 onNext(T obj) 和 onError(Throwable error) 也是单参数无返回值的，因此 Action1 可以将 onNext(obj) 和onError(error) 打包起来传入 subscribe() 以实现不完整定义的回调。\n\n```\nObservable<String> observable = Observable.create(new Observable.OnSubscribe<String>() {\n@Override\npublic void call(Subscriber<? super String> subscriber) {\nsubscriber.onNext(\"123\");\nsubscriber.onNext(\"234\");\nsubscriber.onCompleted();\n}\n});\n\nobservable.subscribe(new Action1<String>() {\n@Override\npublic void call(String s) {\nSystem.out.println(\"onNext\"+s);\n}\n}, new Action1<Throwable>() {\n@Override\npublic void call(Throwable throwable) {\nSystem.out.println(\"onError\");\n}\n}, new Action0() {\n@Override\npublic void call() {\nSystem.out.println(\"onComplete\");\n}\n});\n```\n\n来看看源码中定义的使用方式\n\n```\npublic final Subscription subscribe(final Action1<? super T> onNext) {\nif (onNext == null) {\nthrow new IllegalArgumentException(\"onNext can not be null\");\n}\n\nAction1<Throwable> onError = InternalObservableUtils.ERROR_NOT_IMPLEMENTED;\nAction0 onCompleted = Actions.empty();\nreturn subscribe(new ActionSubscriber<T>(onNext, onError, onCompleted));\n}\n\npublic final Subscription subscribe(final Action1<? super T> onNext, final Action1<Throwable> onError) {\nif (onNext == null) {\nthrow new IllegalArgumentException(\"onNext can not be null\");\n}\nif (onError == null) {\nthrow new IllegalArgumentException(\"onError can not be null\");\n}\n\nAction0 onCompleted = Actions.empty();\nreturn subscribe(new ActionSubscriber<T>(onNext, onError, onCompleted));\n}\n\npublic final Subscription subscribe(final Action1<? super T> onNext, final Action1<Throwable> onError, final Action0 onCompleted) {\nif (onNext == null) {\nthrow new IllegalArgumentException(\"onNext can not be null\");\n}\nif (onError == null) {\nthrow new IllegalArgumentException(\"onError can not be null\");\n\nif (onCompleted == null) {\nthrow new IllegalArgumentException(\"onComplete can not be null\");\n}\n\nreturn subscribe(new ActionSubscriber<T>(onNext, onError, onCompleted));\n}\n```\n\n无论传入几个Action，最后都会返回`subscribe(new ActionSubscriber<T>(onNext, onError, onCompleted));`  \n哎呀，听人家讲不如自己去看看源码，也没几行 (●ﾟωﾟ●)\n\n\n上面这些都只是皮毛啦，RxJava真正的意义在于**异步**，『后台处理，前台回调』，而要实现异步，则需要用到 RxJava 的另一个概念： Scheduler 。\n\n### 线程控制Scheduler\n用于指定每一段代码运行在什么样的线程之中。RxJava内置的Scheduler：\n\n* `Schedulers.immediate()`: 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。\n* `Schedulers.newThread()`: 总是启用新线程，并在新线程执行操作。\n* `Schedulers.io()`: I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。\n* 另外， Android 还有一个专用的 `AndroidSchedulers.mainThread()`，它指定的操作将在 Android 主线程运行。\n\n有了这些个SchedulerJ就可以用`subscribeOn ``observeOn `这两个方法来对线程进行控制了。分别指定**观察者在主线程**用于更新UI，**被观察者位于io线程**执行以下耗时的操作。  \n例子：\n\n```\nObservable.just(123, 123, 123)\n.subscribeOn(AndroidSchedulers.mainThread())\n.observeOn(Schedulers.io())\n.subscribe { integer -> println(integer!!.toString()) }\n\n```\n\n\n","source":"_posts/rx.md","raw":"---\ntitle: RxJava - 异步\ndate: 2018-10-15 17:27:52\ncategories: 技术\ntag : 技术\n---\n# RxJava - 异步\n\n### Observable(被观察者)的创建\n它没有公开的构造方法，是通过内部的Create方法来创建一个\n\n```\nObservable<String> observable = Observable.create(new Observable.OnSubscribe<String>() {\n@Override\npublic void call(Subscriber<? super String> subscriber) {}\n});\n```\n我们可以看到，call方法的参数是是一个观察者，也就是持有**观察者**的引用，**被观察者**做了一些操作以后，通过`subscriber.onNext/onComplete` 来实现**响应式**\n<!--more-->\n### Subscriber/Observer(观察者)的创建\n\nSubscriber 对 Observer 接口进行了一些扩展，但他们的基本使用方式是完全一样的\n\n```\nSubscriber<String> subscriber = new Subscriber<String>() {\n@Override\npublic void onCompleted() {\n\n}\n\n@Override\npublic void onError(Throwable e) {\n\n}\n\n@Override\npublic void onNext(String s) {\nSystem.out.println(\"subscriber\" + s);\n}\n};\n\nObserver<String> observer = new Observer<String>() {\n@Override\npublic void onCompleted() {\n\n}\n\n@Override\npublic void onError(Throwable e) {\n\n}\n\n@Override\npublic void onNext(String s) {\nSystem.out.println(\"observer\"+s);\n}\n};\n```\n### 观察者响应被观察者\n我们知道[观察者模式](https://o0o0oo00.github.io/2018/10/09/Observer/#more)，是**被观察者持有观察者**的引用，进而遍历所有观察者，调用（通知）其方法来达到响应的目的。\n所以我们看RxJava中的关联方式是通过**被观察者订阅观察者**observable.subscribe(observer/subscriber)来实现的。这个地方可能与概念有些不贴切，因为概念是观察者要响应的是被观察者，所以这里通过**被观察者订阅观察者**来达到**观察者响应被观察者**的目的\n\n1. 创建被观察者`Observable`与观察者`Observer`对象\n2. 观察者订阅被观察者，实际是**观察者**当做参数传入**被观察者** `observable.subscribe(observer);`\n3. **被观察者**`Observable`的重写方法`call()`中调用**观察者**`Observer`的`onNext`方法。然后`Observer`**重写**的`onNext`进行相应的处理\n\n### Observable的其他创建方式\n#### Observable.just(t : T) 具有多个参数的重载方法，源码中就有多达10个参数的重载方法。\n\n例如：相当于执行`call`方法中的`subscriber.``onNext(\"123\")``onNext(\"234\")``onCompleted()`\n\n```\nObservable.just(\"123\",\"234\").subscribe(new Observer<String>() {\n@Override\npublic void onCompleted() {\n\n}\n\n@Override\npublic void onError(Throwable e) {\n\n}\n\n@Override\npublic void onNext(String s) {\nSystem.out.println(s);\n}\n});\n\n```\n#### Observable.from(Iterable<? extends T> iterable)\n\n`from(Iterable<? extends T> iterable)`**支持从数组或者是实现了Iterator接口的集合中接收参数**  \n例如：这两种方式\n\n```\nObservable.from(new String[]{\"345\",\"456\"}).subscribe(new Observer<String>() {\n@Override\npublic void onCompleted() {\n\n}\n\n@Override\npublic void onError(Throwable e) {\n\n}\n\n@Override\npublic void onNext(String s) {\nSystem.out.println(s);\n}\n});\n```\n```\nList<String> list = new ArrayList<>();\nlist.add(\"567\");\nlist.add(\"678\");\nObservable.from(list).subscribe(new Observer<String>() {\n@Override\npublic void onCompleted() {\nSystem.out.println(\"onCompleted\");\n}\n\n@Override\npublic void onError(Throwable e) {\n\n}\n\n@Override\npublic void onNext(String s) {\nSystem.out.println(s);\n}\n});\n```\n**PostScript**：当just参数在2个以上时，实际上内部调用的也是from(T[] array)方法。\n\n#### `Action0`、`Action1<T>` ... `Action9<T1, T2, T3, T4, T5, T6, T7, T8, T9> `\n0个参数的Action,1个参数的Action  \nAction0 可以被当成一个包装对象，将 onCompleted() 的内容打包起来将自己作为一个参数传入 subscribe() 以实现不完整定义的回调。由于 onNext(T obj) 和 onError(Throwable error) 也是单参数无返回值的，因此 Action1 可以将 onNext(obj) 和onError(error) 打包起来传入 subscribe() 以实现不完整定义的回调。\n\n```\nObservable<String> observable = Observable.create(new Observable.OnSubscribe<String>() {\n@Override\npublic void call(Subscriber<? super String> subscriber) {\nsubscriber.onNext(\"123\");\nsubscriber.onNext(\"234\");\nsubscriber.onCompleted();\n}\n});\n\nobservable.subscribe(new Action1<String>() {\n@Override\npublic void call(String s) {\nSystem.out.println(\"onNext\"+s);\n}\n}, new Action1<Throwable>() {\n@Override\npublic void call(Throwable throwable) {\nSystem.out.println(\"onError\");\n}\n}, new Action0() {\n@Override\npublic void call() {\nSystem.out.println(\"onComplete\");\n}\n});\n```\n\n来看看源码中定义的使用方式\n\n```\npublic final Subscription subscribe(final Action1<? super T> onNext) {\nif (onNext == null) {\nthrow new IllegalArgumentException(\"onNext can not be null\");\n}\n\nAction1<Throwable> onError = InternalObservableUtils.ERROR_NOT_IMPLEMENTED;\nAction0 onCompleted = Actions.empty();\nreturn subscribe(new ActionSubscriber<T>(onNext, onError, onCompleted));\n}\n\npublic final Subscription subscribe(final Action1<? super T> onNext, final Action1<Throwable> onError) {\nif (onNext == null) {\nthrow new IllegalArgumentException(\"onNext can not be null\");\n}\nif (onError == null) {\nthrow new IllegalArgumentException(\"onError can not be null\");\n}\n\nAction0 onCompleted = Actions.empty();\nreturn subscribe(new ActionSubscriber<T>(onNext, onError, onCompleted));\n}\n\npublic final Subscription subscribe(final Action1<? super T> onNext, final Action1<Throwable> onError, final Action0 onCompleted) {\nif (onNext == null) {\nthrow new IllegalArgumentException(\"onNext can not be null\");\n}\nif (onError == null) {\nthrow new IllegalArgumentException(\"onError can not be null\");\n\nif (onCompleted == null) {\nthrow new IllegalArgumentException(\"onComplete can not be null\");\n}\n\nreturn subscribe(new ActionSubscriber<T>(onNext, onError, onCompleted));\n}\n```\n\n无论传入几个Action，最后都会返回`subscribe(new ActionSubscriber<T>(onNext, onError, onCompleted));`  \n哎呀，听人家讲不如自己去看看源码，也没几行 (●ﾟωﾟ●)\n\n\n上面这些都只是皮毛啦，RxJava真正的意义在于**异步**，『后台处理，前台回调』，而要实现异步，则需要用到 RxJava 的另一个概念： Scheduler 。\n\n### 线程控制Scheduler\n用于指定每一段代码运行在什么样的线程之中。RxJava内置的Scheduler：\n\n* `Schedulers.immediate()`: 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。\n* `Schedulers.newThread()`: 总是启用新线程，并在新线程执行操作。\n* `Schedulers.io()`: I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。\n* 另外， Android 还有一个专用的 `AndroidSchedulers.mainThread()`，它指定的操作将在 Android 主线程运行。\n\n有了这些个SchedulerJ就可以用`subscribeOn ``observeOn `这两个方法来对线程进行控制了。分别指定**观察者在主线程**用于更新UI，**被观察者位于io线程**执行以下耗时的操作。  \n例子：\n\n```\nObservable.just(123, 123, 123)\n.subscribeOn(AndroidSchedulers.mainThread())\n.observeOn(Schedulers.io())\n.subscribe { integer -> println(integer!!.toString()) }\n\n```\n\n\n","slug":"rx","published":1,"updated":"2019-02-28T09:09:14.767Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf126001t5l26acl13qlz","content":"<h1 id=\"RxJava-异步\"><a href=\"#RxJava-异步\" class=\"headerlink\" title=\"RxJava - 异步\"></a>RxJava - 异步</h1><h3 id=\"Observable-被观察者-的创建\"><a href=\"#Observable-被观察者-的创建\" class=\"headerlink\" title=\"Observable(被观察者)的创建\"></a>Observable(被观察者)的创建</h3><p>它没有公开的构造方法，是通过内部的Create方法来创建一个</p>\n<pre><code>Observable&lt;String&gt; observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() {\n@Override\npublic void call(Subscriber&lt;? super String&gt; subscriber) {}\n});\n</code></pre><p>我们可以看到，call方法的参数是是一个观察者，也就是持有<strong>观察者</strong>的引用，<strong>被观察者</strong>做了一些操作以后，通过<code>subscriber.onNext/onComplete</code> 来实现<strong>响应式</strong><br><a id=\"more\"></a></p>\n<h3 id=\"Subscriber-Observer-观察者-的创建\"><a href=\"#Subscriber-Observer-观察者-的创建\" class=\"headerlink\" title=\"Subscriber/Observer(观察者)的创建\"></a>Subscriber/Observer(观察者)的创建</h3><p>Subscriber 对 Observer 接口进行了一些扩展，但他们的基本使用方式是完全一样的</p>\n<pre><code>Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() {\n@Override\npublic void onCompleted() {\n\n}\n\n@Override\npublic void onError(Throwable e) {\n\n}\n\n@Override\npublic void onNext(String s) {\nSystem.out.println(&quot;subscriber&quot; + s);\n}\n};\n\nObserver&lt;String&gt; observer = new Observer&lt;String&gt;() {\n@Override\npublic void onCompleted() {\n\n}\n\n@Override\npublic void onError(Throwable e) {\n\n}\n\n@Override\npublic void onNext(String s) {\nSystem.out.println(&quot;observer&quot;+s);\n}\n};\n</code></pre><h3 id=\"观察者响应被观察者\"><a href=\"#观察者响应被观察者\" class=\"headerlink\" title=\"观察者响应被观察者\"></a>观察者响应被观察者</h3><p>我们知道<a href=\"https://o0o0oo00.github.io/2018/10/09/Observer/#more\">观察者模式</a>，是<strong>被观察者持有观察者</strong>的引用，进而遍历所有观察者，调用（通知）其方法来达到响应的目的。<br>所以我们看RxJava中的关联方式是通过<strong>被观察者订阅观察者</strong>observable.subscribe(observer/subscriber)来实现的。这个地方可能与概念有些不贴切，因为概念是观察者要响应的是被观察者，所以这里通过<strong>被观察者订阅观察者</strong>来达到<strong>观察者响应被观察者</strong>的目的</p>\n<ol>\n<li>创建被观察者<code>Observable</code>与观察者<code>Observer</code>对象</li>\n<li>观察者订阅被观察者，实际是<strong>观察者</strong>当做参数传入<strong>被观察者</strong> <code>observable.subscribe(observer);</code></li>\n<li><strong>被观察者</strong><code>Observable</code>的重写方法<code>call()</code>中调用<strong>观察者</strong><code>Observer</code>的<code>onNext</code>方法。然后<code>Observer</code><strong>重写</strong>的<code>onNext</code>进行相应的处理</li>\n</ol>\n<h3 id=\"Observable的其他创建方式\"><a href=\"#Observable的其他创建方式\" class=\"headerlink\" title=\"Observable的其他创建方式\"></a>Observable的其他创建方式</h3><h4 id=\"Observable-just-t-T-具有多个参数的重载方法，源码中就有多达10个参数的重载方法。\"><a href=\"#Observable-just-t-T-具有多个参数的重载方法，源码中就有多达10个参数的重载方法。\" class=\"headerlink\" title=\"Observable.just(t : T) 具有多个参数的重载方法，源码中就有多达10个参数的重载方法。\"></a>Observable.just(t : T) 具有多个参数的重载方法，源码中就有多达10个参数的重载方法。</h4><p>例如：相当于执行<code>call</code>方法中的<code>subscriber.`</code>onNext(“123”)<code>onNext(&quot;234&quot;)</code>onCompleted()`</p>\n<pre><code>Observable.just(&quot;123&quot;,&quot;234&quot;).subscribe(new Observer&lt;String&gt;() {\n@Override\npublic void onCompleted() {\n\n}\n\n@Override\npublic void onError(Throwable e) {\n\n}\n\n@Override\npublic void onNext(String s) {\nSystem.out.println(s);\n}\n});\n\n</code></pre><h4 id=\"Observable-from-Iterable-lt-extends-T-gt-iterable\"><a href=\"#Observable-from-Iterable-lt-extends-T-gt-iterable\" class=\"headerlink\" title=\"Observable.from(Iterable&lt;? extends T&gt; iterable)\"></a>Observable.from(Iterable&lt;? extends T&gt; iterable)</h4><p><code>from(Iterable&lt;? extends T&gt; iterable)</code><strong>支持从数组或者是实现了Iterator接口的集合中接收参数</strong><br>例如：这两种方式</p>\n<pre><code>Observable.from(new String[]{&quot;345&quot;,&quot;456&quot;}).subscribe(new Observer&lt;String&gt;() {\n@Override\npublic void onCompleted() {\n\n}\n\n@Override\npublic void onError(Throwable e) {\n\n}\n\n@Override\npublic void onNext(String s) {\nSystem.out.println(s);\n}\n});\n</code></pre><pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(&quot;567&quot;);\nlist.add(&quot;678&quot;);\nObservable.from(list).subscribe(new Observer&lt;String&gt;() {\n@Override\npublic void onCompleted() {\nSystem.out.println(&quot;onCompleted&quot;);\n}\n\n@Override\npublic void onError(Throwable e) {\n\n}\n\n@Override\npublic void onNext(String s) {\nSystem.out.println(s);\n}\n});\n</code></pre><p><strong>PostScript</strong>：当just参数在2个以上时，实际上内部调用的也是from(T[] array)方法。</p>\n<h4 id=\"Action0、Action1-lt-T-gt-…-Action9-lt-T1-T2-T3-T4-T5-T6-T7-T8-T9-gt\"><a href=\"#Action0、Action1-lt-T-gt-…-Action9-lt-T1-T2-T3-T4-T5-T6-T7-T8-T9-gt\" class=\"headerlink\" title=\"Action0、Action1&lt;T&gt; … Action9&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9&gt;\"></a><code>Action0</code>、<code>Action1&lt;T&gt;</code> … <code>Action9&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9&gt;</code></h4><p>0个参数的Action,1个参数的Action<br>Action0 可以被当成一个包装对象，将 onCompleted() 的内容打包起来将自己作为一个参数传入 subscribe() 以实现不完整定义的回调。由于 onNext(T obj) 和 onError(Throwable error) 也是单参数无返回值的，因此 Action1 可以将 onNext(obj) 和onError(error) 打包起来传入 subscribe() 以实现不完整定义的回调。</p>\n<pre><code>Observable&lt;String&gt; observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() {\n@Override\npublic void call(Subscriber&lt;? super String&gt; subscriber) {\nsubscriber.onNext(&quot;123&quot;);\nsubscriber.onNext(&quot;234&quot;);\nsubscriber.onCompleted();\n}\n});\n\nobservable.subscribe(new Action1&lt;String&gt;() {\n@Override\npublic void call(String s) {\nSystem.out.println(&quot;onNext&quot;+s);\n}\n}, new Action1&lt;Throwable&gt;() {\n@Override\npublic void call(Throwable throwable) {\nSystem.out.println(&quot;onError&quot;);\n}\n}, new Action0() {\n@Override\npublic void call() {\nSystem.out.println(&quot;onComplete&quot;);\n}\n});\n</code></pre><p>来看看源码中定义的使用方式</p>\n<pre><code>public final Subscription subscribe(final Action1&lt;? super T&gt; onNext) {\nif (onNext == null) {\nthrow new IllegalArgumentException(&quot;onNext can not be null&quot;);\n}\n\nAction1&lt;Throwable&gt; onError = InternalObservableUtils.ERROR_NOT_IMPLEMENTED;\nAction0 onCompleted = Actions.empty();\nreturn subscribe(new ActionSubscriber&lt;T&gt;(onNext, onError, onCompleted));\n}\n\npublic final Subscription subscribe(final Action1&lt;? super T&gt; onNext, final Action1&lt;Throwable&gt; onError) {\nif (onNext == null) {\nthrow new IllegalArgumentException(&quot;onNext can not be null&quot;);\n}\nif (onError == null) {\nthrow new IllegalArgumentException(&quot;onError can not be null&quot;);\n}\n\nAction0 onCompleted = Actions.empty();\nreturn subscribe(new ActionSubscriber&lt;T&gt;(onNext, onError, onCompleted));\n}\n\npublic final Subscription subscribe(final Action1&lt;? super T&gt; onNext, final Action1&lt;Throwable&gt; onError, final Action0 onCompleted) {\nif (onNext == null) {\nthrow new IllegalArgumentException(&quot;onNext can not be null&quot;);\n}\nif (onError == null) {\nthrow new IllegalArgumentException(&quot;onError can not be null&quot;);\n\nif (onCompleted == null) {\nthrow new IllegalArgumentException(&quot;onComplete can not be null&quot;);\n}\n\nreturn subscribe(new ActionSubscriber&lt;T&gt;(onNext, onError, onCompleted));\n}\n</code></pre><p>无论传入几个Action，最后都会返回<code>subscribe(new ActionSubscriber&lt;T&gt;(onNext, onError, onCompleted));</code><br>哎呀，听人家讲不如自己去看看源码，也没几行 (●ﾟωﾟ●)</p>\n<p>上面这些都只是皮毛啦，RxJava真正的意义在于<strong>异步</strong>，『后台处理，前台回调』，而要实现异步，则需要用到 RxJava 的另一个概念： Scheduler 。</p>\n<h3 id=\"线程控制Scheduler\"><a href=\"#线程控制Scheduler\" class=\"headerlink\" title=\"线程控制Scheduler\"></a>线程控制Scheduler</h3><p>用于指定每一段代码运行在什么样的线程之中。RxJava内置的Scheduler：</p>\n<ul>\n<li><code>Schedulers.immediate()</code>: 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。</li>\n<li><code>Schedulers.newThread()</code>: 总是启用新线程，并在新线程执行操作。</li>\n<li><code>Schedulers.io()</code>: I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。</li>\n<li>另外， Android 还有一个专用的 <code>AndroidSchedulers.mainThread()</code>，它指定的操作将在 Android 主线程运行。</li>\n</ul>\n<p>有了这些个SchedulerJ就可以用<code>subscribeOn `</code>observeOn `这两个方法来对线程进行控制了。分别指定<strong>观察者在主线程</strong>用于更新UI，<strong>被观察者位于io线程</strong>执行以下耗时的操作。<br>例子：</p>\n<pre><code>Observable.just(123, 123, 123)\n.subscribeOn(AndroidSchedulers.mainThread())\n.observeOn(Schedulers.io())\n.subscribe { integer -&gt; println(integer!!.toString()) }\n\n</code></pre>","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"<h1 id=\"RxJava-异步\"><a href=\"#RxJava-异步\" class=\"headerlink\" title=\"RxJava - 异步\"></a>RxJava - 异步</h1><h3 id=\"Observable-被观察者-的创建\"><a href=\"#Observable-被观察者-的创建\" class=\"headerlink\" title=\"Observable(被观察者)的创建\"></a>Observable(被观察者)的创建</h3><p>它没有公开的构造方法，是通过内部的Create方法来创建一个</p>\n<pre><code>Observable&lt;String&gt; observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() {\n@Override\npublic void call(Subscriber&lt;? super String&gt; subscriber) {}\n});\n</code></pre><p>我们可以看到，call方法的参数是是一个观察者，也就是持有<strong>观察者</strong>的引用，<strong>被观察者</strong>做了一些操作以后，通过<code>subscriber.onNext/onComplete</code> 来实现<strong>响应式</strong><br>","more":"</p>\n<h3 id=\"Subscriber-Observer-观察者-的创建\"><a href=\"#Subscriber-Observer-观察者-的创建\" class=\"headerlink\" title=\"Subscriber/Observer(观察者)的创建\"></a>Subscriber/Observer(观察者)的创建</h3><p>Subscriber 对 Observer 接口进行了一些扩展，但他们的基本使用方式是完全一样的</p>\n<pre><code>Subscriber&lt;String&gt; subscriber = new Subscriber&lt;String&gt;() {\n@Override\npublic void onCompleted() {\n\n}\n\n@Override\npublic void onError(Throwable e) {\n\n}\n\n@Override\npublic void onNext(String s) {\nSystem.out.println(&quot;subscriber&quot; + s);\n}\n};\n\nObserver&lt;String&gt; observer = new Observer&lt;String&gt;() {\n@Override\npublic void onCompleted() {\n\n}\n\n@Override\npublic void onError(Throwable e) {\n\n}\n\n@Override\npublic void onNext(String s) {\nSystem.out.println(&quot;observer&quot;+s);\n}\n};\n</code></pre><h3 id=\"观察者响应被观察者\"><a href=\"#观察者响应被观察者\" class=\"headerlink\" title=\"观察者响应被观察者\"></a>观察者响应被观察者</h3><p>我们知道<a href=\"https://o0o0oo00.github.io/2018/10/09/Observer/#more\">观察者模式</a>，是<strong>被观察者持有观察者</strong>的引用，进而遍历所有观察者，调用（通知）其方法来达到响应的目的。<br>所以我们看RxJava中的关联方式是通过<strong>被观察者订阅观察者</strong>observable.subscribe(observer/subscriber)来实现的。这个地方可能与概念有些不贴切，因为概念是观察者要响应的是被观察者，所以这里通过<strong>被观察者订阅观察者</strong>来达到<strong>观察者响应被观察者</strong>的目的</p>\n<ol>\n<li>创建被观察者<code>Observable</code>与观察者<code>Observer</code>对象</li>\n<li>观察者订阅被观察者，实际是<strong>观察者</strong>当做参数传入<strong>被观察者</strong> <code>observable.subscribe(observer);</code></li>\n<li><strong>被观察者</strong><code>Observable</code>的重写方法<code>call()</code>中调用<strong>观察者</strong><code>Observer</code>的<code>onNext</code>方法。然后<code>Observer</code><strong>重写</strong>的<code>onNext</code>进行相应的处理</li>\n</ol>\n<h3 id=\"Observable的其他创建方式\"><a href=\"#Observable的其他创建方式\" class=\"headerlink\" title=\"Observable的其他创建方式\"></a>Observable的其他创建方式</h3><h4 id=\"Observable-just-t-T-具有多个参数的重载方法，源码中就有多达10个参数的重载方法。\"><a href=\"#Observable-just-t-T-具有多个参数的重载方法，源码中就有多达10个参数的重载方法。\" class=\"headerlink\" title=\"Observable.just(t : T) 具有多个参数的重载方法，源码中就有多达10个参数的重载方法。\"></a>Observable.just(t : T) 具有多个参数的重载方法，源码中就有多达10个参数的重载方法。</h4><p>例如：相当于执行<code>call</code>方法中的<code>subscriber.`</code>onNext(“123”)<code>onNext(&quot;234&quot;)</code>onCompleted()`</p>\n<pre><code>Observable.just(&quot;123&quot;,&quot;234&quot;).subscribe(new Observer&lt;String&gt;() {\n@Override\npublic void onCompleted() {\n\n}\n\n@Override\npublic void onError(Throwable e) {\n\n}\n\n@Override\npublic void onNext(String s) {\nSystem.out.println(s);\n}\n});\n\n</code></pre><h4 id=\"Observable-from-Iterable-lt-extends-T-gt-iterable\"><a href=\"#Observable-from-Iterable-lt-extends-T-gt-iterable\" class=\"headerlink\" title=\"Observable.from(Iterable&lt;? extends T&gt; iterable)\"></a>Observable.from(Iterable&lt;? extends T&gt; iterable)</h4><p><code>from(Iterable&lt;? extends T&gt; iterable)</code><strong>支持从数组或者是实现了Iterator接口的集合中接收参数</strong><br>例如：这两种方式</p>\n<pre><code>Observable.from(new String[]{&quot;345&quot;,&quot;456&quot;}).subscribe(new Observer&lt;String&gt;() {\n@Override\npublic void onCompleted() {\n\n}\n\n@Override\npublic void onError(Throwable e) {\n\n}\n\n@Override\npublic void onNext(String s) {\nSystem.out.println(s);\n}\n});\n</code></pre><pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(&quot;567&quot;);\nlist.add(&quot;678&quot;);\nObservable.from(list).subscribe(new Observer&lt;String&gt;() {\n@Override\npublic void onCompleted() {\nSystem.out.println(&quot;onCompleted&quot;);\n}\n\n@Override\npublic void onError(Throwable e) {\n\n}\n\n@Override\npublic void onNext(String s) {\nSystem.out.println(s);\n}\n});\n</code></pre><p><strong>PostScript</strong>：当just参数在2个以上时，实际上内部调用的也是from(T[] array)方法。</p>\n<h4 id=\"Action0、Action1-lt-T-gt-…-Action9-lt-T1-T2-T3-T4-T5-T6-T7-T8-T9-gt\"><a href=\"#Action0、Action1-lt-T-gt-…-Action9-lt-T1-T2-T3-T4-T5-T6-T7-T8-T9-gt\" class=\"headerlink\" title=\"Action0、Action1&lt;T&gt; … Action9&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9&gt;\"></a><code>Action0</code>、<code>Action1&lt;T&gt;</code> … <code>Action9&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9&gt;</code></h4><p>0个参数的Action,1个参数的Action<br>Action0 可以被当成一个包装对象，将 onCompleted() 的内容打包起来将自己作为一个参数传入 subscribe() 以实现不完整定义的回调。由于 onNext(T obj) 和 onError(Throwable error) 也是单参数无返回值的，因此 Action1 可以将 onNext(obj) 和onError(error) 打包起来传入 subscribe() 以实现不完整定义的回调。</p>\n<pre><code>Observable&lt;String&gt; observable = Observable.create(new Observable.OnSubscribe&lt;String&gt;() {\n@Override\npublic void call(Subscriber&lt;? super String&gt; subscriber) {\nsubscriber.onNext(&quot;123&quot;);\nsubscriber.onNext(&quot;234&quot;);\nsubscriber.onCompleted();\n}\n});\n\nobservable.subscribe(new Action1&lt;String&gt;() {\n@Override\npublic void call(String s) {\nSystem.out.println(&quot;onNext&quot;+s);\n}\n}, new Action1&lt;Throwable&gt;() {\n@Override\npublic void call(Throwable throwable) {\nSystem.out.println(&quot;onError&quot;);\n}\n}, new Action0() {\n@Override\npublic void call() {\nSystem.out.println(&quot;onComplete&quot;);\n}\n});\n</code></pre><p>来看看源码中定义的使用方式</p>\n<pre><code>public final Subscription subscribe(final Action1&lt;? super T&gt; onNext) {\nif (onNext == null) {\nthrow new IllegalArgumentException(&quot;onNext can not be null&quot;);\n}\n\nAction1&lt;Throwable&gt; onError = InternalObservableUtils.ERROR_NOT_IMPLEMENTED;\nAction0 onCompleted = Actions.empty();\nreturn subscribe(new ActionSubscriber&lt;T&gt;(onNext, onError, onCompleted));\n}\n\npublic final Subscription subscribe(final Action1&lt;? super T&gt; onNext, final Action1&lt;Throwable&gt; onError) {\nif (onNext == null) {\nthrow new IllegalArgumentException(&quot;onNext can not be null&quot;);\n}\nif (onError == null) {\nthrow new IllegalArgumentException(&quot;onError can not be null&quot;);\n}\n\nAction0 onCompleted = Actions.empty();\nreturn subscribe(new ActionSubscriber&lt;T&gt;(onNext, onError, onCompleted));\n}\n\npublic final Subscription subscribe(final Action1&lt;? super T&gt; onNext, final Action1&lt;Throwable&gt; onError, final Action0 onCompleted) {\nif (onNext == null) {\nthrow new IllegalArgumentException(&quot;onNext can not be null&quot;);\n}\nif (onError == null) {\nthrow new IllegalArgumentException(&quot;onError can not be null&quot;);\n\nif (onCompleted == null) {\nthrow new IllegalArgumentException(&quot;onComplete can not be null&quot;);\n}\n\nreturn subscribe(new ActionSubscriber&lt;T&gt;(onNext, onError, onCompleted));\n}\n</code></pre><p>无论传入几个Action，最后都会返回<code>subscribe(new ActionSubscriber&lt;T&gt;(onNext, onError, onCompleted));</code><br>哎呀，听人家讲不如自己去看看源码，也没几行 (●ﾟωﾟ●)</p>\n<p>上面这些都只是皮毛啦，RxJava真正的意义在于<strong>异步</strong>，『后台处理，前台回调』，而要实现异步，则需要用到 RxJava 的另一个概念： Scheduler 。</p>\n<h3 id=\"线程控制Scheduler\"><a href=\"#线程控制Scheduler\" class=\"headerlink\" title=\"线程控制Scheduler\"></a>线程控制Scheduler</h3><p>用于指定每一段代码运行在什么样的线程之中。RxJava内置的Scheduler：</p>\n<ul>\n<li><code>Schedulers.immediate()</code>: 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。</li>\n<li><code>Schedulers.newThread()</code>: 总是启用新线程，并在新线程执行操作。</li>\n<li><code>Schedulers.io()</code>: I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。</li>\n<li>另外， Android 还有一个专用的 <code>AndroidSchedulers.mainThread()</code>，它指定的操作将在 Android 主线程运行。</li>\n</ul>\n<p>有了这些个SchedulerJ就可以用<code>subscribeOn `</code>observeOn `这两个方法来对线程进行控制了。分别指定<strong>观察者在主线程</strong>用于更新UI，<strong>被观察者位于io线程</strong>执行以下耗时的操作。<br>例子：</p>\n<pre><code>Observable.just(123, 123, 123)\n.subscribeOn(AndroidSchedulers.mainThread())\n.observeOn(Schedulers.io())\n.subscribe { integer -&gt; println(integer!!.toString()) }\n\n</code></pre>"},{"title":"RxJava操作符举例","date":"2018-10-16T07:59:39.000Z","_content":"### 变换与操作符\n**所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。**\n\n#### map()操作符\nfunc1有两个泛型，一个是输入泛型，一个是输出泛型，可以看到下面这个例子，输入的是Integer类型，在map的重写方法中进行一系列操作例如`integer.toString()`来将输入类型转换为输出类型。于是观察者收到的类型就变成了String\n\n```\nobservable.map(new Func1<Integer, String>() {\n@Override\npublic String call(Integer integer) {\nreturn integer.toString();\n}\n}).subscribe(new Action1<String>() {\n@Override\npublic void call(String s) {\nSystem.out.println(s);\n}\n});\n```\n<!--more-->\n### 操作符举例\n#### first()/last()\n只发射第一个数据项，或者是满足条件的第一个数据项。 \n附带一个`onCompleted`  \n\n```\nObservable.just(1,2,3,4,5)\n.first()\n.subscribe(new Action1<Integer>() {\n@Override\npublic void call(Integer integer) {\nSystem.out.println(integer.toString());\n}\n});\n}\n```\n结果 1\n#### merge()\n合并多个Observeable的发射数据。 可能交错发送\n\n```\nObservable<Integer> just = Observable.just(1, 2, 3);\nObservable<Integer> just1 = Observable.just(4, 5, 6);\nObservable.merge(just1, just).subscribe(new Action1<Integer>() {\n@Override\npublic void call(Integer integer) {\nSystem.out.println(integer.toString());\n}\n});\n```\n结果 456123\n#### concat()\n不同于merge,他是有序发送的\n#### zip()\n将两个发射项合并一起\n\n```\nObservable<Integer> just = Observable.just(1, 2, 3);\nObservable<String> just1 = Observable.just(\"a\", \"b\", \"c\");\nObservable.zip(just1, just, new Func2<String, Integer, String>() {\n@Override\npublic String call(String s, Integer integer) {\nreturn s + integer;//合并操作\n}\n}).subscribe(new Action1<String>() {\n@Override\npublic void call(String s) {\nSystem.out.println(s);\n}\n});\n```\n\n结果：a1 b2 c3\n\n#### repeat(times)\n#### range(start , count)\n\n```\nObservable.range(10,2).repeat(2).subscribe(new Action1<Integer>() {\n@Override\npublic void call(Integer integer) {\nSystem.out.println(integer);\n}\n});\n```\n结果为： 10 11 10 11\n\n#### flatMap(Func1)\n不同于map的一对一。他是一对多的关系。  \nA中有一个list，我们现在要发送一个A，但是观察者接收的要是其中的list,\n\n```\nclass A {\nList<String> list = new ArrayList<>();\npublic A() {\nfor (int i = 0; i < 10; i++) {\nlist.add(\"index \" + i);\n}\n}\n}\nObservable\n.just(new A())\n.flatMap(new Func1<A, Observable<String>>() {\n@Override\npublic Observable<String> call(A a) {\nreturn Observable.from(a.list);\n}\n})\n.subscribe(new Action1<String>() {\n@Override\npublic void call(String s) {\nSystem.out.println(s);\n}\n});\n\n```\n\n结果为：  \nindex 0 index 1 index 2 index 3 index 4 index 5 index 6 index 7 index 8 index 9\n\n#### timer / interval\ntimer():  \ndelay延迟后发送一个值为 long型的0 内部通过onSubscribeTimerOnce工作\n\n```\nObservable.timer(2, TimeUnit.SECONDS)\n.subscribe(new Action1<Long>() {\n@Override\npublic void call(Long aLong) {\nSystem.out.println(\"收到一个为\" + aLong + \"的值\");\n}\n});\n```\n\ninterval():\n间隔interval的时间发送一个从0开始的递增,内部通过OnSubscribeTimerPeriodically工作。\n\n```\nObservable.interval(2, TimeUnit.SECONDS).subscribe(new Action1<Long>() {\n@Override\npublic void call(Long aLong) {\nSystem.out.println(\"收到一个\" + aLong + \"的值\");\n}\n});\n```\n#### startWith\nstartWith： 在数据序列的开头增加一项数据。startWith的内部也是调用了concat\n#### ofType\n`ofType(final Class<R> klass)`\n与filter类似\n#### take(N) / takeLast(N)\n只发射前/后N个数据\n#### skip（N）/ skipLast\n跳过前/后N项\n#### ignoreElements\n丢弃所有数据，只发射错误或正常终止的通知。内部通过OperatorIgnoreElements实现。\n#### distinct / distinctUntilChanged\n过滤重复数据 / 过滤掉连续重复的数据\n#### reduce \n对数据进行聚合操作，只返回最终结果\n\n```\nObservable.just(1, 2, 3, 4, 5)\n.reduce(new Func2<Integer, Integer, Integer>() {\n@Override\npublic Integer call(Integer integer, Integer integer2) {\nreturn (integer + integer2);\n}\n}).subscribe(new Action1<Integer>() {\n@Override\npublic void call(Integer integer) {\nSystem.out.println(integer);\n}\n});\n```\n#### collect\n\n```\nObservable.just(1, 2, 3, 4, 5)\n.collect(new Func0<List<Integer>>() {\n@Override\npublic List<Integer> call() {\nreturn new ArrayList<>();\n}\n}, new Action2<List<Integer>, Integer>() {\n@Override\npublic void call(List<Integer> o, Integer integer) {\no.add(integer);\n}\n})\n.subscribe(new Action1<List<Integer>>() {\n@Override\npublic void call(List<Integer> o) {\nSystem.out.println(o.toString());\n}\n});\n```\n结果：[1, 2, 3, 4, 5]\n\n#### toList / toSortedList / toMap\n\n```\nObservable.just(1,3,4,5,6).toList().subscribe(new Action1<List<Integer>>() {\n@Override\npublic void call(List<Integer> integers) {\nSystem.out.println(integers.toString());\n}\n});\n```\n\n\n### 最后来一个例子\n\n```\nfinal String memoryCache = null;\nfinal String diskCache = \"从磁盘缓存中获取数据\";\nObservable<String> memory = Observable.create(new Observable.OnSubscribe<String>() {\n@Override\npublic void call(Subscriber<? super String> subscriber) {\nif (memoryCache == null) {\nsubscriber.onCompleted();\n} else {\nsubscriber.onNext(memoryCache);\n}\n}\n});\n\nObservable<String> disk = Observable.create(new Observable.OnSubscribe<String>() {\n@Override\npublic void call(Subscriber<? super String> subscriber) {\nif (diskCache == null){\nsubscriber.onCompleted();\n}else{\nsubscriber.onNext(diskCache);\n}\n}\n});\n\nObservable<String> net = Observable.just(\"从NET中获取数据\");\n\nObservable.concat(memory,disk,net)\n//                .first()\n.subscribe(new Observer<String>() {\n@Override\npublic void onCompleted() {\nSystem.out.println(\"onCompleted\");\n}\n\n@Override\npublic void onError(Throwable e) {\nSystem.out.println(\"onError\");\n}\n\n@Override\npublic void onNext(String s) {\nSystem.out.println(\"最终是 \" + s);\n}\n});\n\n```\n**Attention ！！** \n\nconcat 就是如果前一个不发送onComplete那么后一个是不会执行的。\n","source":"_posts/rxoperator.md","raw":"---\ntitle: RxJava操作符举例\ndate: 2018-10-16 15:59:39\ncategories: 技术\ntag : kotlin\n---\n### 变换与操作符\n**所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。**\n\n#### map()操作符\nfunc1有两个泛型，一个是输入泛型，一个是输出泛型，可以看到下面这个例子，输入的是Integer类型，在map的重写方法中进行一系列操作例如`integer.toString()`来将输入类型转换为输出类型。于是观察者收到的类型就变成了String\n\n```\nobservable.map(new Func1<Integer, String>() {\n@Override\npublic String call(Integer integer) {\nreturn integer.toString();\n}\n}).subscribe(new Action1<String>() {\n@Override\npublic void call(String s) {\nSystem.out.println(s);\n}\n});\n```\n<!--more-->\n### 操作符举例\n#### first()/last()\n只发射第一个数据项，或者是满足条件的第一个数据项。 \n附带一个`onCompleted`  \n\n```\nObservable.just(1,2,3,4,5)\n.first()\n.subscribe(new Action1<Integer>() {\n@Override\npublic void call(Integer integer) {\nSystem.out.println(integer.toString());\n}\n});\n}\n```\n结果 1\n#### merge()\n合并多个Observeable的发射数据。 可能交错发送\n\n```\nObservable<Integer> just = Observable.just(1, 2, 3);\nObservable<Integer> just1 = Observable.just(4, 5, 6);\nObservable.merge(just1, just).subscribe(new Action1<Integer>() {\n@Override\npublic void call(Integer integer) {\nSystem.out.println(integer.toString());\n}\n});\n```\n结果 456123\n#### concat()\n不同于merge,他是有序发送的\n#### zip()\n将两个发射项合并一起\n\n```\nObservable<Integer> just = Observable.just(1, 2, 3);\nObservable<String> just1 = Observable.just(\"a\", \"b\", \"c\");\nObservable.zip(just1, just, new Func2<String, Integer, String>() {\n@Override\npublic String call(String s, Integer integer) {\nreturn s + integer;//合并操作\n}\n}).subscribe(new Action1<String>() {\n@Override\npublic void call(String s) {\nSystem.out.println(s);\n}\n});\n```\n\n结果：a1 b2 c3\n\n#### repeat(times)\n#### range(start , count)\n\n```\nObservable.range(10,2).repeat(2).subscribe(new Action1<Integer>() {\n@Override\npublic void call(Integer integer) {\nSystem.out.println(integer);\n}\n});\n```\n结果为： 10 11 10 11\n\n#### flatMap(Func1)\n不同于map的一对一。他是一对多的关系。  \nA中有一个list，我们现在要发送一个A，但是观察者接收的要是其中的list,\n\n```\nclass A {\nList<String> list = new ArrayList<>();\npublic A() {\nfor (int i = 0; i < 10; i++) {\nlist.add(\"index \" + i);\n}\n}\n}\nObservable\n.just(new A())\n.flatMap(new Func1<A, Observable<String>>() {\n@Override\npublic Observable<String> call(A a) {\nreturn Observable.from(a.list);\n}\n})\n.subscribe(new Action1<String>() {\n@Override\npublic void call(String s) {\nSystem.out.println(s);\n}\n});\n\n```\n\n结果为：  \nindex 0 index 1 index 2 index 3 index 4 index 5 index 6 index 7 index 8 index 9\n\n#### timer / interval\ntimer():  \ndelay延迟后发送一个值为 long型的0 内部通过onSubscribeTimerOnce工作\n\n```\nObservable.timer(2, TimeUnit.SECONDS)\n.subscribe(new Action1<Long>() {\n@Override\npublic void call(Long aLong) {\nSystem.out.println(\"收到一个为\" + aLong + \"的值\");\n}\n});\n```\n\ninterval():\n间隔interval的时间发送一个从0开始的递增,内部通过OnSubscribeTimerPeriodically工作。\n\n```\nObservable.interval(2, TimeUnit.SECONDS).subscribe(new Action1<Long>() {\n@Override\npublic void call(Long aLong) {\nSystem.out.println(\"收到一个\" + aLong + \"的值\");\n}\n});\n```\n#### startWith\nstartWith： 在数据序列的开头增加一项数据。startWith的内部也是调用了concat\n#### ofType\n`ofType(final Class<R> klass)`\n与filter类似\n#### take(N) / takeLast(N)\n只发射前/后N个数据\n#### skip（N）/ skipLast\n跳过前/后N项\n#### ignoreElements\n丢弃所有数据，只发射错误或正常终止的通知。内部通过OperatorIgnoreElements实现。\n#### distinct / distinctUntilChanged\n过滤重复数据 / 过滤掉连续重复的数据\n#### reduce \n对数据进行聚合操作，只返回最终结果\n\n```\nObservable.just(1, 2, 3, 4, 5)\n.reduce(new Func2<Integer, Integer, Integer>() {\n@Override\npublic Integer call(Integer integer, Integer integer2) {\nreturn (integer + integer2);\n}\n}).subscribe(new Action1<Integer>() {\n@Override\npublic void call(Integer integer) {\nSystem.out.println(integer);\n}\n});\n```\n#### collect\n\n```\nObservable.just(1, 2, 3, 4, 5)\n.collect(new Func0<List<Integer>>() {\n@Override\npublic List<Integer> call() {\nreturn new ArrayList<>();\n}\n}, new Action2<List<Integer>, Integer>() {\n@Override\npublic void call(List<Integer> o, Integer integer) {\no.add(integer);\n}\n})\n.subscribe(new Action1<List<Integer>>() {\n@Override\npublic void call(List<Integer> o) {\nSystem.out.println(o.toString());\n}\n});\n```\n结果：[1, 2, 3, 4, 5]\n\n#### toList / toSortedList / toMap\n\n```\nObservable.just(1,3,4,5,6).toList().subscribe(new Action1<List<Integer>>() {\n@Override\npublic void call(List<Integer> integers) {\nSystem.out.println(integers.toString());\n}\n});\n```\n\n\n### 最后来一个例子\n\n```\nfinal String memoryCache = null;\nfinal String diskCache = \"从磁盘缓存中获取数据\";\nObservable<String> memory = Observable.create(new Observable.OnSubscribe<String>() {\n@Override\npublic void call(Subscriber<? super String> subscriber) {\nif (memoryCache == null) {\nsubscriber.onCompleted();\n} else {\nsubscriber.onNext(memoryCache);\n}\n}\n});\n\nObservable<String> disk = Observable.create(new Observable.OnSubscribe<String>() {\n@Override\npublic void call(Subscriber<? super String> subscriber) {\nif (diskCache == null){\nsubscriber.onCompleted();\n}else{\nsubscriber.onNext(diskCache);\n}\n}\n});\n\nObservable<String> net = Observable.just(\"从NET中获取数据\");\n\nObservable.concat(memory,disk,net)\n//                .first()\n.subscribe(new Observer<String>() {\n@Override\npublic void onCompleted() {\nSystem.out.println(\"onCompleted\");\n}\n\n@Override\npublic void onError(Throwable e) {\nSystem.out.println(\"onError\");\n}\n\n@Override\npublic void onNext(String s) {\nSystem.out.println(\"最终是 \" + s);\n}\n});\n\n```\n**Attention ！！** \n\nconcat 就是如果前一个不发送onComplete那么后一个是不会执行的。\n","slug":"rxoperator","published":1,"updated":"2019-02-28T09:09:25.688Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf127001w5l266q3plqkg","content":"<h3 id=\"变换与操作符\"><a href=\"#变换与操作符\" class=\"headerlink\" title=\"变换与操作符\"></a>变换与操作符</h3><p><strong>所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。</strong></p>\n<h4 id=\"map-操作符\"><a href=\"#map-操作符\" class=\"headerlink\" title=\"map()操作符\"></a>map()操作符</h4><p>func1有两个泛型，一个是输入泛型，一个是输出泛型，可以看到下面这个例子，输入的是Integer类型，在map的重写方法中进行一系列操作例如<code>integer.toString()</code>来将输入类型转换为输出类型。于是观察者收到的类型就变成了String</p>\n<pre><code>observable.map(new Func1&lt;Integer, String&gt;() {\n@Override\npublic String call(Integer integer) {\nreturn integer.toString();\n}\n}).subscribe(new Action1&lt;String&gt;() {\n@Override\npublic void call(String s) {\nSystem.out.println(s);\n}\n});\n</code></pre><a id=\"more\"></a>\n<h3 id=\"操作符举例\"><a href=\"#操作符举例\" class=\"headerlink\" title=\"操作符举例\"></a>操作符举例</h3><h4 id=\"first-last\"><a href=\"#first-last\" class=\"headerlink\" title=\"first()/last()\"></a>first()/last()</h4><p>只发射第一个数据项，或者是满足条件的第一个数据项。<br>附带一个<code>onCompleted</code>  </p>\n<pre><code>Observable.just(1,2,3,4,5)\n.first()\n.subscribe(new Action1&lt;Integer&gt;() {\n@Override\npublic void call(Integer integer) {\nSystem.out.println(integer.toString());\n}\n});\n}\n</code></pre><p>结果 1</p>\n<h4 id=\"merge\"><a href=\"#merge\" class=\"headerlink\" title=\"merge()\"></a>merge()</h4><p>合并多个Observeable的发射数据。 可能交错发送</p>\n<pre><code>Observable&lt;Integer&gt; just = Observable.just(1, 2, 3);\nObservable&lt;Integer&gt; just1 = Observable.just(4, 5, 6);\nObservable.merge(just1, just).subscribe(new Action1&lt;Integer&gt;() {\n@Override\npublic void call(Integer integer) {\nSystem.out.println(integer.toString());\n}\n});\n</code></pre><p>结果 456123</p>\n<h4 id=\"concat\"><a href=\"#concat\" class=\"headerlink\" title=\"concat()\"></a>concat()</h4><p>不同于merge,他是有序发送的</p>\n<h4 id=\"zip\"><a href=\"#zip\" class=\"headerlink\" title=\"zip()\"></a>zip()</h4><p>将两个发射项合并一起</p>\n<pre><code>Observable&lt;Integer&gt; just = Observable.just(1, 2, 3);\nObservable&lt;String&gt; just1 = Observable.just(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);\nObservable.zip(just1, just, new Func2&lt;String, Integer, String&gt;() {\n@Override\npublic String call(String s, Integer integer) {\nreturn s + integer;//合并操作\n}\n}).subscribe(new Action1&lt;String&gt;() {\n@Override\npublic void call(String s) {\nSystem.out.println(s);\n}\n});\n</code></pre><p>结果：a1 b2 c3</p>\n<h4 id=\"repeat-times\"><a href=\"#repeat-times\" class=\"headerlink\" title=\"repeat(times)\"></a>repeat(times)</h4><h4 id=\"range-start-count\"><a href=\"#range-start-count\" class=\"headerlink\" title=\"range(start , count)\"></a>range(start , count)</h4><pre><code>Observable.range(10,2).repeat(2).subscribe(new Action1&lt;Integer&gt;() {\n@Override\npublic void call(Integer integer) {\nSystem.out.println(integer);\n}\n});\n</code></pre><p>结果为： 10 11 10 11</p>\n<h4 id=\"flatMap-Func1\"><a href=\"#flatMap-Func1\" class=\"headerlink\" title=\"flatMap(Func1)\"></a>flatMap(Func1)</h4><p>不同于map的一对一。他是一对多的关系。<br>A中有一个list，我们现在要发送一个A，但是观察者接收的要是其中的list,</p>\n<pre><code>class A {\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\npublic A() {\nfor (int i = 0; i &lt; 10; i++) {\nlist.add(&quot;index &quot; + i);\n}\n}\n}\nObservable\n.just(new A())\n.flatMap(new Func1&lt;A, Observable&lt;String&gt;&gt;() {\n@Override\npublic Observable&lt;String&gt; call(A a) {\nreturn Observable.from(a.list);\n}\n})\n.subscribe(new Action1&lt;String&gt;() {\n@Override\npublic void call(String s) {\nSystem.out.println(s);\n}\n});\n\n</code></pre><p>结果为：<br>index 0 index 1 index 2 index 3 index 4 index 5 index 6 index 7 index 8 index 9</p>\n<h4 id=\"timer-interval\"><a href=\"#timer-interval\" class=\"headerlink\" title=\"timer / interval\"></a>timer / interval</h4><p>timer():<br>delay延迟后发送一个值为 long型的0 内部通过onSubscribeTimerOnce工作</p>\n<pre><code>Observable.timer(2, TimeUnit.SECONDS)\n.subscribe(new Action1&lt;Long&gt;() {\n@Override\npublic void call(Long aLong) {\nSystem.out.println(&quot;收到一个为&quot; + aLong + &quot;的值&quot;);\n}\n});\n</code></pre><p>interval():<br>间隔interval的时间发送一个从0开始的递增,内部通过OnSubscribeTimerPeriodically工作。</p>\n<pre><code>Observable.interval(2, TimeUnit.SECONDS).subscribe(new Action1&lt;Long&gt;() {\n@Override\npublic void call(Long aLong) {\nSystem.out.println(&quot;收到一个&quot; + aLong + &quot;的值&quot;);\n}\n});\n</code></pre><h4 id=\"startWith\"><a href=\"#startWith\" class=\"headerlink\" title=\"startWith\"></a>startWith</h4><p>startWith： 在数据序列的开头增加一项数据。startWith的内部也是调用了concat</p>\n<h4 id=\"ofType\"><a href=\"#ofType\" class=\"headerlink\" title=\"ofType\"></a>ofType</h4><p><code>ofType(final Class&lt;R&gt; klass)</code><br>与filter类似</p>\n<h4 id=\"take-N-takeLast-N\"><a href=\"#take-N-takeLast-N\" class=\"headerlink\" title=\"take(N) / takeLast(N)\"></a>take(N) / takeLast(N)</h4><p>只发射前/后N个数据</p>\n<h4 id=\"skip（N）-skipLast\"><a href=\"#skip（N）-skipLast\" class=\"headerlink\" title=\"skip（N）/ skipLast\"></a>skip（N）/ skipLast</h4><p>跳过前/后N项</p>\n<h4 id=\"ignoreElements\"><a href=\"#ignoreElements\" class=\"headerlink\" title=\"ignoreElements\"></a>ignoreElements</h4><p>丢弃所有数据，只发射错误或正常终止的通知。内部通过OperatorIgnoreElements实现。</p>\n<h4 id=\"distinct-distinctUntilChanged\"><a href=\"#distinct-distinctUntilChanged\" class=\"headerlink\" title=\"distinct / distinctUntilChanged\"></a>distinct / distinctUntilChanged</h4><p>过滤重复数据 / 过滤掉连续重复的数据</p>\n<h4 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h4><p>对数据进行聚合操作，只返回最终结果</p>\n<pre><code>Observable.just(1, 2, 3, 4, 5)\n.reduce(new Func2&lt;Integer, Integer, Integer&gt;() {\n@Override\npublic Integer call(Integer integer, Integer integer2) {\nreturn (integer + integer2);\n}\n}).subscribe(new Action1&lt;Integer&gt;() {\n@Override\npublic void call(Integer integer) {\nSystem.out.println(integer);\n}\n});\n</code></pre><h4 id=\"collect\"><a href=\"#collect\" class=\"headerlink\" title=\"collect\"></a>collect</h4><pre><code>Observable.just(1, 2, 3, 4, 5)\n.collect(new Func0&lt;List&lt;Integer&gt;&gt;() {\n@Override\npublic List&lt;Integer&gt; call() {\nreturn new ArrayList&lt;&gt;();\n}\n}, new Action2&lt;List&lt;Integer&gt;, Integer&gt;() {\n@Override\npublic void call(List&lt;Integer&gt; o, Integer integer) {\no.add(integer);\n}\n})\n.subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {\n@Override\npublic void call(List&lt;Integer&gt; o) {\nSystem.out.println(o.toString());\n}\n});\n</code></pre><p>结果：[1, 2, 3, 4, 5]</p>\n<h4 id=\"toList-toSortedList-toMap\"><a href=\"#toList-toSortedList-toMap\" class=\"headerlink\" title=\"toList / toSortedList / toMap\"></a>toList / toSortedList / toMap</h4><pre><code>Observable.just(1,3,4,5,6).toList().subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {\n@Override\npublic void call(List&lt;Integer&gt; integers) {\nSystem.out.println(integers.toString());\n}\n});\n</code></pre><h3 id=\"最后来一个例子\"><a href=\"#最后来一个例子\" class=\"headerlink\" title=\"最后来一个例子\"></a>最后来一个例子</h3><pre><code>final String memoryCache = null;\nfinal String diskCache = &quot;从磁盘缓存中获取数据&quot;;\nObservable&lt;String&gt; memory = Observable.create(new Observable.OnSubscribe&lt;String&gt;() {\n@Override\npublic void call(Subscriber&lt;? super String&gt; subscriber) {\nif (memoryCache == null) {\nsubscriber.onCompleted();\n} else {\nsubscriber.onNext(memoryCache);\n}\n}\n});\n\nObservable&lt;String&gt; disk = Observable.create(new Observable.OnSubscribe&lt;String&gt;() {\n@Override\npublic void call(Subscriber&lt;? super String&gt; subscriber) {\nif (diskCache == null){\nsubscriber.onCompleted();\n}else{\nsubscriber.onNext(diskCache);\n}\n}\n});\n\nObservable&lt;String&gt; net = Observable.just(&quot;从NET中获取数据&quot;);\n\nObservable.concat(memory,disk,net)\n//                .first()\n.subscribe(new Observer&lt;String&gt;() {\n@Override\npublic void onCompleted() {\nSystem.out.println(&quot;onCompleted&quot;);\n}\n\n@Override\npublic void onError(Throwable e) {\nSystem.out.println(&quot;onError&quot;);\n}\n\n@Override\npublic void onNext(String s) {\nSystem.out.println(&quot;最终是 &quot; + s);\n}\n});\n\n</code></pre><p><strong>Attention ！！</strong> </p>\n<p>concat 就是如果前一个不发送onComplete那么后一个是不会执行的。</p>\n","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"<h3 id=\"变换与操作符\"><a href=\"#变换与操作符\" class=\"headerlink\" title=\"变换与操作符\"></a>变换与操作符</h3><p><strong>所谓变换，就是将事件序列中的对象或整个序列进行加工处理，转换成不同的事件或事件序列。</strong></p>\n<h4 id=\"map-操作符\"><a href=\"#map-操作符\" class=\"headerlink\" title=\"map()操作符\"></a>map()操作符</h4><p>func1有两个泛型，一个是输入泛型，一个是输出泛型，可以看到下面这个例子，输入的是Integer类型，在map的重写方法中进行一系列操作例如<code>integer.toString()</code>来将输入类型转换为输出类型。于是观察者收到的类型就变成了String</p>\n<pre><code>observable.map(new Func1&lt;Integer, String&gt;() {\n@Override\npublic String call(Integer integer) {\nreturn integer.toString();\n}\n}).subscribe(new Action1&lt;String&gt;() {\n@Override\npublic void call(String s) {\nSystem.out.println(s);\n}\n});\n</code></pre>","more":"<h3 id=\"操作符举例\"><a href=\"#操作符举例\" class=\"headerlink\" title=\"操作符举例\"></a>操作符举例</h3><h4 id=\"first-last\"><a href=\"#first-last\" class=\"headerlink\" title=\"first()/last()\"></a>first()/last()</h4><p>只发射第一个数据项，或者是满足条件的第一个数据项。<br>附带一个<code>onCompleted</code>  </p>\n<pre><code>Observable.just(1,2,3,4,5)\n.first()\n.subscribe(new Action1&lt;Integer&gt;() {\n@Override\npublic void call(Integer integer) {\nSystem.out.println(integer.toString());\n}\n});\n}\n</code></pre><p>结果 1</p>\n<h4 id=\"merge\"><a href=\"#merge\" class=\"headerlink\" title=\"merge()\"></a>merge()</h4><p>合并多个Observeable的发射数据。 可能交错发送</p>\n<pre><code>Observable&lt;Integer&gt; just = Observable.just(1, 2, 3);\nObservable&lt;Integer&gt; just1 = Observable.just(4, 5, 6);\nObservable.merge(just1, just).subscribe(new Action1&lt;Integer&gt;() {\n@Override\npublic void call(Integer integer) {\nSystem.out.println(integer.toString());\n}\n});\n</code></pre><p>结果 456123</p>\n<h4 id=\"concat\"><a href=\"#concat\" class=\"headerlink\" title=\"concat()\"></a>concat()</h4><p>不同于merge,他是有序发送的</p>\n<h4 id=\"zip\"><a href=\"#zip\" class=\"headerlink\" title=\"zip()\"></a>zip()</h4><p>将两个发射项合并一起</p>\n<pre><code>Observable&lt;Integer&gt; just = Observable.just(1, 2, 3);\nObservable&lt;String&gt; just1 = Observable.just(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);\nObservable.zip(just1, just, new Func2&lt;String, Integer, String&gt;() {\n@Override\npublic String call(String s, Integer integer) {\nreturn s + integer;//合并操作\n}\n}).subscribe(new Action1&lt;String&gt;() {\n@Override\npublic void call(String s) {\nSystem.out.println(s);\n}\n});\n</code></pre><p>结果：a1 b2 c3</p>\n<h4 id=\"repeat-times\"><a href=\"#repeat-times\" class=\"headerlink\" title=\"repeat(times)\"></a>repeat(times)</h4><h4 id=\"range-start-count\"><a href=\"#range-start-count\" class=\"headerlink\" title=\"range(start , count)\"></a>range(start , count)</h4><pre><code>Observable.range(10,2).repeat(2).subscribe(new Action1&lt;Integer&gt;() {\n@Override\npublic void call(Integer integer) {\nSystem.out.println(integer);\n}\n});\n</code></pre><p>结果为： 10 11 10 11</p>\n<h4 id=\"flatMap-Func1\"><a href=\"#flatMap-Func1\" class=\"headerlink\" title=\"flatMap(Func1)\"></a>flatMap(Func1)</h4><p>不同于map的一对一。他是一对多的关系。<br>A中有一个list，我们现在要发送一个A，但是观察者接收的要是其中的list,</p>\n<pre><code>class A {\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\npublic A() {\nfor (int i = 0; i &lt; 10; i++) {\nlist.add(&quot;index &quot; + i);\n}\n}\n}\nObservable\n.just(new A())\n.flatMap(new Func1&lt;A, Observable&lt;String&gt;&gt;() {\n@Override\npublic Observable&lt;String&gt; call(A a) {\nreturn Observable.from(a.list);\n}\n})\n.subscribe(new Action1&lt;String&gt;() {\n@Override\npublic void call(String s) {\nSystem.out.println(s);\n}\n});\n\n</code></pre><p>结果为：<br>index 0 index 1 index 2 index 3 index 4 index 5 index 6 index 7 index 8 index 9</p>\n<h4 id=\"timer-interval\"><a href=\"#timer-interval\" class=\"headerlink\" title=\"timer / interval\"></a>timer / interval</h4><p>timer():<br>delay延迟后发送一个值为 long型的0 内部通过onSubscribeTimerOnce工作</p>\n<pre><code>Observable.timer(2, TimeUnit.SECONDS)\n.subscribe(new Action1&lt;Long&gt;() {\n@Override\npublic void call(Long aLong) {\nSystem.out.println(&quot;收到一个为&quot; + aLong + &quot;的值&quot;);\n}\n});\n</code></pre><p>interval():<br>间隔interval的时间发送一个从0开始的递增,内部通过OnSubscribeTimerPeriodically工作。</p>\n<pre><code>Observable.interval(2, TimeUnit.SECONDS).subscribe(new Action1&lt;Long&gt;() {\n@Override\npublic void call(Long aLong) {\nSystem.out.println(&quot;收到一个&quot; + aLong + &quot;的值&quot;);\n}\n});\n</code></pre><h4 id=\"startWith\"><a href=\"#startWith\" class=\"headerlink\" title=\"startWith\"></a>startWith</h4><p>startWith： 在数据序列的开头增加一项数据。startWith的内部也是调用了concat</p>\n<h4 id=\"ofType\"><a href=\"#ofType\" class=\"headerlink\" title=\"ofType\"></a>ofType</h4><p><code>ofType(final Class&lt;R&gt; klass)</code><br>与filter类似</p>\n<h4 id=\"take-N-takeLast-N\"><a href=\"#take-N-takeLast-N\" class=\"headerlink\" title=\"take(N) / takeLast(N)\"></a>take(N) / takeLast(N)</h4><p>只发射前/后N个数据</p>\n<h4 id=\"skip（N）-skipLast\"><a href=\"#skip（N）-skipLast\" class=\"headerlink\" title=\"skip（N）/ skipLast\"></a>skip（N）/ skipLast</h4><p>跳过前/后N项</p>\n<h4 id=\"ignoreElements\"><a href=\"#ignoreElements\" class=\"headerlink\" title=\"ignoreElements\"></a>ignoreElements</h4><p>丢弃所有数据，只发射错误或正常终止的通知。内部通过OperatorIgnoreElements实现。</p>\n<h4 id=\"distinct-distinctUntilChanged\"><a href=\"#distinct-distinctUntilChanged\" class=\"headerlink\" title=\"distinct / distinctUntilChanged\"></a>distinct / distinctUntilChanged</h4><p>过滤重复数据 / 过滤掉连续重复的数据</p>\n<h4 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h4><p>对数据进行聚合操作，只返回最终结果</p>\n<pre><code>Observable.just(1, 2, 3, 4, 5)\n.reduce(new Func2&lt;Integer, Integer, Integer&gt;() {\n@Override\npublic Integer call(Integer integer, Integer integer2) {\nreturn (integer + integer2);\n}\n}).subscribe(new Action1&lt;Integer&gt;() {\n@Override\npublic void call(Integer integer) {\nSystem.out.println(integer);\n}\n});\n</code></pre><h4 id=\"collect\"><a href=\"#collect\" class=\"headerlink\" title=\"collect\"></a>collect</h4><pre><code>Observable.just(1, 2, 3, 4, 5)\n.collect(new Func0&lt;List&lt;Integer&gt;&gt;() {\n@Override\npublic List&lt;Integer&gt; call() {\nreturn new ArrayList&lt;&gt;();\n}\n}, new Action2&lt;List&lt;Integer&gt;, Integer&gt;() {\n@Override\npublic void call(List&lt;Integer&gt; o, Integer integer) {\no.add(integer);\n}\n})\n.subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {\n@Override\npublic void call(List&lt;Integer&gt; o) {\nSystem.out.println(o.toString());\n}\n});\n</code></pre><p>结果：[1, 2, 3, 4, 5]</p>\n<h4 id=\"toList-toSortedList-toMap\"><a href=\"#toList-toSortedList-toMap\" class=\"headerlink\" title=\"toList / toSortedList / toMap\"></a>toList / toSortedList / toMap</h4><pre><code>Observable.just(1,3,4,5,6).toList().subscribe(new Action1&lt;List&lt;Integer&gt;&gt;() {\n@Override\npublic void call(List&lt;Integer&gt; integers) {\nSystem.out.println(integers.toString());\n}\n});\n</code></pre><h3 id=\"最后来一个例子\"><a href=\"#最后来一个例子\" class=\"headerlink\" title=\"最后来一个例子\"></a>最后来一个例子</h3><pre><code>final String memoryCache = null;\nfinal String diskCache = &quot;从磁盘缓存中获取数据&quot;;\nObservable&lt;String&gt; memory = Observable.create(new Observable.OnSubscribe&lt;String&gt;() {\n@Override\npublic void call(Subscriber&lt;? super String&gt; subscriber) {\nif (memoryCache == null) {\nsubscriber.onCompleted();\n} else {\nsubscriber.onNext(memoryCache);\n}\n}\n});\n\nObservable&lt;String&gt; disk = Observable.create(new Observable.OnSubscribe&lt;String&gt;() {\n@Override\npublic void call(Subscriber&lt;? super String&gt; subscriber) {\nif (diskCache == null){\nsubscriber.onCompleted();\n}else{\nsubscriber.onNext(diskCache);\n}\n}\n});\n\nObservable&lt;String&gt; net = Observable.just(&quot;从NET中获取数据&quot;);\n\nObservable.concat(memory,disk,net)\n//                .first()\n.subscribe(new Observer&lt;String&gt;() {\n@Override\npublic void onCompleted() {\nSystem.out.println(&quot;onCompleted&quot;);\n}\n\n@Override\npublic void onError(Throwable e) {\nSystem.out.println(&quot;onError&quot;);\n}\n\n@Override\npublic void onNext(String s) {\nSystem.out.println(&quot;最终是 &quot; + s);\n}\n});\n\n</code></pre><p><strong>Attention ！！</strong> </p>\n<p>concat 就是如果前一个不发送onComplete那么后一个是不会执行的。</p>"},{"_content":"## 仿写RHine 所需要积累的知识点\n\n### DataBinding\n### LiveData\n### ViewModel\n### Kodein\n### RxJava的各种操作符及其封装\n#### compose\n#### fold\n#### startWith\n#### autoDisposable\n","source":"_posts/仿写RHine 所需要积累的知识点.md","raw":"## 仿写RHine 所需要积累的知识点\n\n### DataBinding\n### LiveData\n### ViewModel\n### Kodein\n### RxJava的各种操作符及其封装\n#### compose\n#### fold\n#### startWith\n#### autoDisposable\n","slug":"仿写RHine 所需要积累的知识点","published":1,"date":"2019-02-20T10:38:19.030Z","updated":"2019-02-20T10:38:19.030Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf12900205l26nbatl0cb","content":"<h2 id=\"仿写RHine-所需要积累的知识点\"><a href=\"#仿写RHine-所需要积累的知识点\" class=\"headerlink\" title=\"仿写RHine 所需要积累的知识点\"></a>仿写RHine 所需要积累的知识点</h2><h3 id=\"DataBinding\"><a href=\"#DataBinding\" class=\"headerlink\" title=\"DataBinding\"></a>DataBinding</h3><h3 id=\"LiveData\"><a href=\"#LiveData\" class=\"headerlink\" title=\"LiveData\"></a>LiveData</h3><h3 id=\"ViewModel\"><a href=\"#ViewModel\" class=\"headerlink\" title=\"ViewModel\"></a>ViewModel</h3><h3 id=\"Kodein\"><a href=\"#Kodein\" class=\"headerlink\" title=\"Kodein\"></a>Kodein</h3><h3 id=\"RxJava的各种操作符及其封装\"><a href=\"#RxJava的各种操作符及其封装\" class=\"headerlink\" title=\"RxJava的各种操作符及其封装\"></a>RxJava的各种操作符及其封装</h3><h4 id=\"compose\"><a href=\"#compose\" class=\"headerlink\" title=\"compose\"></a>compose</h4><h4 id=\"fold\"><a href=\"#fold\" class=\"headerlink\" title=\"fold\"></a>fold</h4><h4 id=\"startWith\"><a href=\"#startWith\" class=\"headerlink\" title=\"startWith\"></a>startWith</h4><h4 id=\"autoDisposable\"><a href=\"#autoDisposable\" class=\"headerlink\" title=\"autoDisposable\"></a>autoDisposable</h4>","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"","more":"<h2 id=\"仿写RHine-所需要积累的知识点\"><a href=\"#仿写RHine-所需要积累的知识点\" class=\"headerlink\" title=\"仿写RHine 所需要积累的知识点\"></a>仿写RHine 所需要积累的知识点</h2><h3 id=\"DataBinding\"><a href=\"#DataBinding\" class=\"headerlink\" title=\"DataBinding\"></a>DataBinding</h3><h3 id=\"LiveData\"><a href=\"#LiveData\" class=\"headerlink\" title=\"LiveData\"></a>LiveData</h3><h3 id=\"ViewModel\"><a href=\"#ViewModel\" class=\"headerlink\" title=\"ViewModel\"></a>ViewModel</h3><h3 id=\"Kodein\"><a href=\"#Kodein\" class=\"headerlink\" title=\"Kodein\"></a>Kodein</h3><h3 id=\"RxJava的各种操作符及其封装\"><a href=\"#RxJava的各种操作符及其封装\" class=\"headerlink\" title=\"RxJava的各种操作符及其封装\"></a>RxJava的各种操作符及其封装</h3><h4 id=\"compose\"><a href=\"#compose\" class=\"headerlink\" title=\"compose\"></a>compose</h4><h4 id=\"fold\"><a href=\"#fold\" class=\"headerlink\" title=\"fold\"></a>fold</h4><h4 id=\"startWith\"><a href=\"#startWith\" class=\"headerlink\" title=\"startWith\"></a>startWith</h4><h4 id=\"autoDisposable\"><a href=\"#autoDisposable\" class=\"headerlink\" title=\"autoDisposable\"></a>autoDisposable</h4>"},{"title":"FAMOUS QUOTATION","date":"2019-02-14T10:30:10.000Z","_content":"\n<!--more-->\n\n过多的选择，会让最终被选择的“幸运儿”魅力大减，从而满足感更低 \n\n假装无情，其实是痛恨自己的深情\n我以为人生的意义在于四处游荡流亡，其实只是掩饰至今没有找到愿意驻足的地方。\n\n我希望我是一个让你心动的人，而不是权衡利弊之后觉得还不错得人\n\n其实你不喜欢我，我也不会死。但是如果你肯喜欢我，我一定会死在你手里。\n\n\n语言很多时候都是假的，只有一起的经历才是真的\n\n人觉得自己什么事情都没有做，是因为把时间都分散到小的事情上面，而最终能被人记忆的只有最好的，最坏的，以及最后的\n\n让我痛苦的不是这个世界背后的丑陋，而是它所戴面具的美丽\n\n时间会让我们相遇，会把你和我变成我们。♥️\n\n喜欢的话有很多，但是喜欢的人只有你\n\n每个人多少都会有丧气的时候，因为我们害怕去承担，害怕压力，但是并没有必要去羞愧，因为这个世界没有谁生下来就是勇敢的，而人在什么时候会选择勇敢呢？对我而言，我想就是我遇见你的那一刻\n\n\n春风十里，原来是你\n山高水阔，最后一起\n\n天青色等烟雨\n\nfor you ，one thousand miles\n\n我把我整个灵魂都给你，连同它的怪癖，耍小脾气，忽明忽暗，一千八百种坏毛病。它真讨厌，只有一点好，爱你。\n\n\n我是个俗气至顶的人，见山是山，见海是海，见花便是花。唯独见了你，云海开始翻涌，江潮开始澎湃，昆虫的小触须挠着全世界的痒。你无需开口，我和天地万物便通通奔向你。\n\n不知道现在是怎么了，你让我夜不能寐，让我脑袋里面全是如何表现自己，以及怀疑你到底爱不爱我，我想我应该是疯了，可能这是每个人都会经历的阶段吧，恨不得把所有的东西都掏出来给你看，企图证明我对你的爱，我知道我这是有些急于求成，但总是控制不住去想你，去计划我们的未来，迫切的在寻找能够让我们呆在一起的机会。我觉得我好幼稚的，\n\n\n我们是不是该见个面，把我对你的思念再说一遍。\n\n你给了我如此美好的向往，却也让我有了因得不到而产生的懊恼。\n\n就像一个一半青涩，一半红嫩的桃子，充满了诱惑，让人想咬上一口，\n\n你是非常可爱的人，真应该遇到最好的人，我也真希望我就是。\n\n疑虑，是因为对自己的估计价值低于对方的价值，所以才会产生怀疑，努力提升自己的实力，价值，这个问题自然就不存在了。\n\n正是因为不去盲目期许未来，所以任何的一件小事情都会成为惊喜。\n\n\n\n\n沉没成本：\n我已经投入的时间，精力，心思，等无法撤回的成本都属于沉没成本，而做选择的时候，不可以考虑沉没成本，因为沉没成本已经无法挽回，那么久没有选择的余地，所以本不应该计入选择时候的参考范围，\n\n反向利用：\n让别人付出很大的沉没成本，进而提升他人对我的黏性，比如讲价，可以一直让卖家说说说，他不断的付出沉没成本，就在感觉我马上要买的时候开始杀价，然后卖家因为付出的沉没成本很高，所以很有可能会给降价很多\n\n\n边际效用：\n边际是新增带来的新增，边际收益，就是每新增一个成本，所新增的收益。\n\n如果把每一个单位的成本，花在收益最大的事情上面，那么总收益就会达到最大值。\n\n效用利用：\n提升自己所能提供的单位成本所能带来的收益，比如玩一下新花样，制造新鲜感，让自己的边际收益大过其他，\n\n我们未必是一个好人，只是我们选择作为一个好人。\n我们未必不是一个坏人，只是选择作为好人的利益更大。\n\n年轻人总是以为自己已经足够成熟，去向人们证明自己，但是往往对成熟一无所知\n\n房价的泡沫，参考如果人口流量一直递减，但是房价还是不断暴增，那么就是有泡沫的。\n\nCEO这个位置，小企业里就是老板的位置，是有魔性的。可以扭曲人的理智。每个老板都是赌徒。某个项目，我没成为企业实际控制人的时候，经过对竞对和同行以及客户心态的调查，对他的评价是必死无疑。但我成为CEO的那一夜，一切并没有改变，市场还是那么糟糕，客户还是不知道我们是干嘛的，竞对还是做得有群众基础，我们也没盈利，但我改变了看法，觉得还有机会和希望能一搏，还不一定死。\n \n这就像赌徒，没上牌卓的时候嘴上说着今晚咱们肯定要大捞一笔，但心里很清楚就自己那点斤两，输光了走人的概率最大。上了牌桌骰盅握在手里筹码摆在面前的一刻，心态就变了，觉得自己肯定有很大概率会赢。这是典型的控制错觉，自我安慰效应，就像渔夫出海不许说翻，遇到怪浪就扔猪头下去祭祀河神，去挖坟的都要带点金佛玉佛，手里有了可控制的东西，好像自己真的有了可以取胜的筹码，实际是人类通过虚假控制行为降低失败的概率。\n\n\n比如你卖苹果给一个人，说这个苹果便宜，一个可以省一块钱，很好吃，买的人也许还要掂量掂量，考虑一下；\n但如果你说，和我一起卖这个苹果，很好卖，一个可以赚一块钱，绝对很多人追着你。\n","source":"_posts/名人名言.md","raw":"---\ntitle: FAMOUS QUOTATION\ndate: 2019-02-14 18:30:10\ntags: FAMOUS QUOTATION\n---\n\n<!--more-->\n\n过多的选择，会让最终被选择的“幸运儿”魅力大减，从而满足感更低 \n\n假装无情，其实是痛恨自己的深情\n我以为人生的意义在于四处游荡流亡，其实只是掩饰至今没有找到愿意驻足的地方。\n\n我希望我是一个让你心动的人，而不是权衡利弊之后觉得还不错得人\n\n其实你不喜欢我，我也不会死。但是如果你肯喜欢我，我一定会死在你手里。\n\n\n语言很多时候都是假的，只有一起的经历才是真的\n\n人觉得自己什么事情都没有做，是因为把时间都分散到小的事情上面，而最终能被人记忆的只有最好的，最坏的，以及最后的\n\n让我痛苦的不是这个世界背后的丑陋，而是它所戴面具的美丽\n\n时间会让我们相遇，会把你和我变成我们。♥️\n\n喜欢的话有很多，但是喜欢的人只有你\n\n每个人多少都会有丧气的时候，因为我们害怕去承担，害怕压力，但是并没有必要去羞愧，因为这个世界没有谁生下来就是勇敢的，而人在什么时候会选择勇敢呢？对我而言，我想就是我遇见你的那一刻\n\n\n春风十里，原来是你\n山高水阔，最后一起\n\n天青色等烟雨\n\nfor you ，one thousand miles\n\n我把我整个灵魂都给你，连同它的怪癖，耍小脾气，忽明忽暗，一千八百种坏毛病。它真讨厌，只有一点好，爱你。\n\n\n我是个俗气至顶的人，见山是山，见海是海，见花便是花。唯独见了你，云海开始翻涌，江潮开始澎湃，昆虫的小触须挠着全世界的痒。你无需开口，我和天地万物便通通奔向你。\n\n不知道现在是怎么了，你让我夜不能寐，让我脑袋里面全是如何表现自己，以及怀疑你到底爱不爱我，我想我应该是疯了，可能这是每个人都会经历的阶段吧，恨不得把所有的东西都掏出来给你看，企图证明我对你的爱，我知道我这是有些急于求成，但总是控制不住去想你，去计划我们的未来，迫切的在寻找能够让我们呆在一起的机会。我觉得我好幼稚的，\n\n\n我们是不是该见个面，把我对你的思念再说一遍。\n\n你给了我如此美好的向往，却也让我有了因得不到而产生的懊恼。\n\n就像一个一半青涩，一半红嫩的桃子，充满了诱惑，让人想咬上一口，\n\n你是非常可爱的人，真应该遇到最好的人，我也真希望我就是。\n\n疑虑，是因为对自己的估计价值低于对方的价值，所以才会产生怀疑，努力提升自己的实力，价值，这个问题自然就不存在了。\n\n正是因为不去盲目期许未来，所以任何的一件小事情都会成为惊喜。\n\n\n\n\n沉没成本：\n我已经投入的时间，精力，心思，等无法撤回的成本都属于沉没成本，而做选择的时候，不可以考虑沉没成本，因为沉没成本已经无法挽回，那么久没有选择的余地，所以本不应该计入选择时候的参考范围，\n\n反向利用：\n让别人付出很大的沉没成本，进而提升他人对我的黏性，比如讲价，可以一直让卖家说说说，他不断的付出沉没成本，就在感觉我马上要买的时候开始杀价，然后卖家因为付出的沉没成本很高，所以很有可能会给降价很多\n\n\n边际效用：\n边际是新增带来的新增，边际收益，就是每新增一个成本，所新增的收益。\n\n如果把每一个单位的成本，花在收益最大的事情上面，那么总收益就会达到最大值。\n\n效用利用：\n提升自己所能提供的单位成本所能带来的收益，比如玩一下新花样，制造新鲜感，让自己的边际收益大过其他，\n\n我们未必是一个好人，只是我们选择作为一个好人。\n我们未必不是一个坏人，只是选择作为好人的利益更大。\n\n年轻人总是以为自己已经足够成熟，去向人们证明自己，但是往往对成熟一无所知\n\n房价的泡沫，参考如果人口流量一直递减，但是房价还是不断暴增，那么就是有泡沫的。\n\nCEO这个位置，小企业里就是老板的位置，是有魔性的。可以扭曲人的理智。每个老板都是赌徒。某个项目，我没成为企业实际控制人的时候，经过对竞对和同行以及客户心态的调查，对他的评价是必死无疑。但我成为CEO的那一夜，一切并没有改变，市场还是那么糟糕，客户还是不知道我们是干嘛的，竞对还是做得有群众基础，我们也没盈利，但我改变了看法，觉得还有机会和希望能一搏，还不一定死。\n \n这就像赌徒，没上牌卓的时候嘴上说着今晚咱们肯定要大捞一笔，但心里很清楚就自己那点斤两，输光了走人的概率最大。上了牌桌骰盅握在手里筹码摆在面前的一刻，心态就变了，觉得自己肯定有很大概率会赢。这是典型的控制错觉，自我安慰效应，就像渔夫出海不许说翻，遇到怪浪就扔猪头下去祭祀河神，去挖坟的都要带点金佛玉佛，手里有了可控制的东西，好像自己真的有了可以取胜的筹码，实际是人类通过虚假控制行为降低失败的概率。\n\n\n比如你卖苹果给一个人，说这个苹果便宜，一个可以省一块钱，很好吃，买的人也许还要掂量掂量，考虑一下；\n但如果你说，和我一起卖这个苹果，很好卖，一个可以赚一块钱，绝对很多人追着你。\n","slug":"名人名言","published":1,"updated":"2019-02-14T10:58:08.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf12a00235l26fibx0bto","content":"<a id=\"more\"></a>\n<p>过多的选择，会让最终被选择的“幸运儿”魅力大减，从而满足感更低 </p>\n<p>假装无情，其实是痛恨自己的深情<br>我以为人生的意义在于四处游荡流亡，其实只是掩饰至今没有找到愿意驻足的地方。</p>\n<p>我希望我是一个让你心动的人，而不是权衡利弊之后觉得还不错得人</p>\n<p>其实你不喜欢我，我也不会死。但是如果你肯喜欢我，我一定会死在你手里。</p>\n<p>语言很多时候都是假的，只有一起的经历才是真的</p>\n<p>人觉得自己什么事情都没有做，是因为把时间都分散到小的事情上面，而最终能被人记忆的只有最好的，最坏的，以及最后的</p>\n<p>让我痛苦的不是这个世界背后的丑陋，而是它所戴面具的美丽</p>\n<p>时间会让我们相遇，会把你和我变成我们。♥️</p>\n<p>喜欢的话有很多，但是喜欢的人只有你</p>\n<p>每个人多少都会有丧气的时候，因为我们害怕去承担，害怕压力，但是并没有必要去羞愧，因为这个世界没有谁生下来就是勇敢的，而人在什么时候会选择勇敢呢？对我而言，我想就是我遇见你的那一刻</p>\n<p>春风十里，原来是你<br>山高水阔，最后一起</p>\n<p>天青色等烟雨</p>\n<p>for you ，one thousand miles</p>\n<p>我把我整个灵魂都给你，连同它的怪癖，耍小脾气，忽明忽暗，一千八百种坏毛病。它真讨厌，只有一点好，爱你。</p>\n<p>我是个俗气至顶的人，见山是山，见海是海，见花便是花。唯独见了你，云海开始翻涌，江潮开始澎湃，昆虫的小触须挠着全世界的痒。你无需开口，我和天地万物便通通奔向你。</p>\n<p>不知道现在是怎么了，你让我夜不能寐，让我脑袋里面全是如何表现自己，以及怀疑你到底爱不爱我，我想我应该是疯了，可能这是每个人都会经历的阶段吧，恨不得把所有的东西都掏出来给你看，企图证明我对你的爱，我知道我这是有些急于求成，但总是控制不住去想你，去计划我们的未来，迫切的在寻找能够让我们呆在一起的机会。我觉得我好幼稚的，</p>\n<p>我们是不是该见个面，把我对你的思念再说一遍。</p>\n<p>你给了我如此美好的向往，却也让我有了因得不到而产生的懊恼。</p>\n<p>就像一个一半青涩，一半红嫩的桃子，充满了诱惑，让人想咬上一口，</p>\n<p>你是非常可爱的人，真应该遇到最好的人，我也真希望我就是。</p>\n<p>疑虑，是因为对自己的估计价值低于对方的价值，所以才会产生怀疑，努力提升自己的实力，价值，这个问题自然就不存在了。</p>\n<p>正是因为不去盲目期许未来，所以任何的一件小事情都会成为惊喜。</p>\n<p>沉没成本：<br>我已经投入的时间，精力，心思，等无法撤回的成本都属于沉没成本，而做选择的时候，不可以考虑沉没成本，因为沉没成本已经无法挽回，那么久没有选择的余地，所以本不应该计入选择时候的参考范围，</p>\n<p>反向利用：<br>让别人付出很大的沉没成本，进而提升他人对我的黏性，比如讲价，可以一直让卖家说说说，他不断的付出沉没成本，就在感觉我马上要买的时候开始杀价，然后卖家因为付出的沉没成本很高，所以很有可能会给降价很多</p>\n<p>边际效用：<br>边际是新增带来的新增，边际收益，就是每新增一个成本，所新增的收益。</p>\n<p>如果把每一个单位的成本，花在收益最大的事情上面，那么总收益就会达到最大值。</p>\n<p>效用利用：<br>提升自己所能提供的单位成本所能带来的收益，比如玩一下新花样，制造新鲜感，让自己的边际收益大过其他，</p>\n<p>我们未必是一个好人，只是我们选择作为一个好人。<br>我们未必不是一个坏人，只是选择作为好人的利益更大。</p>\n<p>年轻人总是以为自己已经足够成熟，去向人们证明自己，但是往往对成熟一无所知</p>\n<p>房价的泡沫，参考如果人口流量一直递减，但是房价还是不断暴增，那么就是有泡沫的。</p>\n<p>CEO这个位置，小企业里就是老板的位置，是有魔性的。可以扭曲人的理智。每个老板都是赌徒。某个项目，我没成为企业实际控制人的时候，经过对竞对和同行以及客户心态的调查，对他的评价是必死无疑。但我成为CEO的那一夜，一切并没有改变，市场还是那么糟糕，客户还是不知道我们是干嘛的，竞对还是做得有群众基础，我们也没盈利，但我改变了看法，觉得还有机会和希望能一搏，还不一定死。<br> <br>这就像赌徒，没上牌卓的时候嘴上说着今晚咱们肯定要大捞一笔，但心里很清楚就自己那点斤两，输光了走人的概率最大。上了牌桌骰盅握在手里筹码摆在面前的一刻，心态就变了，觉得自己肯定有很大概率会赢。这是典型的控制错觉，自我安慰效应，就像渔夫出海不许说翻，遇到怪浪就扔猪头下去祭祀河神，去挖坟的都要带点金佛玉佛，手里有了可控制的东西，好像自己真的有了可以取胜的筹码，实际是人类通过虚假控制行为降低失败的概率。</p>\n<p>比如你卖苹果给一个人，说这个苹果便宜，一个可以省一块钱，很好吃，买的人也许还要掂量掂量，考虑一下；<br>但如果你说，和我一起卖这个苹果，很好卖，一个可以赚一块钱，绝对很多人追着你。</p>\n","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"","more":"<p>过多的选择，会让最终被选择的“幸运儿”魅力大减，从而满足感更低 </p>\n<p>假装无情，其实是痛恨自己的深情<br>我以为人生的意义在于四处游荡流亡，其实只是掩饰至今没有找到愿意驻足的地方。</p>\n<p>我希望我是一个让你心动的人，而不是权衡利弊之后觉得还不错得人</p>\n<p>其实你不喜欢我，我也不会死。但是如果你肯喜欢我，我一定会死在你手里。</p>\n<p>语言很多时候都是假的，只有一起的经历才是真的</p>\n<p>人觉得自己什么事情都没有做，是因为把时间都分散到小的事情上面，而最终能被人记忆的只有最好的，最坏的，以及最后的</p>\n<p>让我痛苦的不是这个世界背后的丑陋，而是它所戴面具的美丽</p>\n<p>时间会让我们相遇，会把你和我变成我们。♥️</p>\n<p>喜欢的话有很多，但是喜欢的人只有你</p>\n<p>每个人多少都会有丧气的时候，因为我们害怕去承担，害怕压力，但是并没有必要去羞愧，因为这个世界没有谁生下来就是勇敢的，而人在什么时候会选择勇敢呢？对我而言，我想就是我遇见你的那一刻</p>\n<p>春风十里，原来是你<br>山高水阔，最后一起</p>\n<p>天青色等烟雨</p>\n<p>for you ，one thousand miles</p>\n<p>我把我整个灵魂都给你，连同它的怪癖，耍小脾气，忽明忽暗，一千八百种坏毛病。它真讨厌，只有一点好，爱你。</p>\n<p>我是个俗气至顶的人，见山是山，见海是海，见花便是花。唯独见了你，云海开始翻涌，江潮开始澎湃，昆虫的小触须挠着全世界的痒。你无需开口，我和天地万物便通通奔向你。</p>\n<p>不知道现在是怎么了，你让我夜不能寐，让我脑袋里面全是如何表现自己，以及怀疑你到底爱不爱我，我想我应该是疯了，可能这是每个人都会经历的阶段吧，恨不得把所有的东西都掏出来给你看，企图证明我对你的爱，我知道我这是有些急于求成，但总是控制不住去想你，去计划我们的未来，迫切的在寻找能够让我们呆在一起的机会。我觉得我好幼稚的，</p>\n<p>我们是不是该见个面，把我对你的思念再说一遍。</p>\n<p>你给了我如此美好的向往，却也让我有了因得不到而产生的懊恼。</p>\n<p>就像一个一半青涩，一半红嫩的桃子，充满了诱惑，让人想咬上一口，</p>\n<p>你是非常可爱的人，真应该遇到最好的人，我也真希望我就是。</p>\n<p>疑虑，是因为对自己的估计价值低于对方的价值，所以才会产生怀疑，努力提升自己的实力，价值，这个问题自然就不存在了。</p>\n<p>正是因为不去盲目期许未来，所以任何的一件小事情都会成为惊喜。</p>\n<p>沉没成本：<br>我已经投入的时间，精力，心思，等无法撤回的成本都属于沉没成本，而做选择的时候，不可以考虑沉没成本，因为沉没成本已经无法挽回，那么久没有选择的余地，所以本不应该计入选择时候的参考范围，</p>\n<p>反向利用：<br>让别人付出很大的沉没成本，进而提升他人对我的黏性，比如讲价，可以一直让卖家说说说，他不断的付出沉没成本，就在感觉我马上要买的时候开始杀价，然后卖家因为付出的沉没成本很高，所以很有可能会给降价很多</p>\n<p>边际效用：<br>边际是新增带来的新增，边际收益，就是每新增一个成本，所新增的收益。</p>\n<p>如果把每一个单位的成本，花在收益最大的事情上面，那么总收益就会达到最大值。</p>\n<p>效用利用：<br>提升自己所能提供的单位成本所能带来的收益，比如玩一下新花样，制造新鲜感，让自己的边际收益大过其他，</p>\n<p>我们未必是一个好人，只是我们选择作为一个好人。<br>我们未必不是一个坏人，只是选择作为好人的利益更大。</p>\n<p>年轻人总是以为自己已经足够成熟，去向人们证明自己，但是往往对成熟一无所知</p>\n<p>房价的泡沫，参考如果人口流量一直递减，但是房价还是不断暴增，那么就是有泡沫的。</p>\n<p>CEO这个位置，小企业里就是老板的位置，是有魔性的。可以扭曲人的理智。每个老板都是赌徒。某个项目，我没成为企业实际控制人的时候，经过对竞对和同行以及客户心态的调查，对他的评价是必死无疑。但我成为CEO的那一夜，一切并没有改变，市场还是那么糟糕，客户还是不知道我们是干嘛的，竞对还是做得有群众基础，我们也没盈利，但我改变了看法，觉得还有机会和希望能一搏，还不一定死。<br> <br>这就像赌徒，没上牌卓的时候嘴上说着今晚咱们肯定要大捞一笔，但心里很清楚就自己那点斤两，输光了走人的概率最大。上了牌桌骰盅握在手里筹码摆在面前的一刻，心态就变了，觉得自己肯定有很大概率会赢。这是典型的控制错觉，自我安慰效应，就像渔夫出海不许说翻，遇到怪浪就扔猪头下去祭祀河神，去挖坟的都要带点金佛玉佛，手里有了可控制的东西，好像自己真的有了可以取胜的筹码，实际是人类通过虚假控制行为降低失败的概率。</p>\n<p>比如你卖苹果给一个人，说这个苹果便宜，一个可以省一块钱，很好吃，买的人也许还要掂量掂量，考虑一下；<br>但如果你说，和我一起卖这个苹果，很好卖，一个可以赚一块钱，绝对很多人追着你。</p>"},{"title":"2018-09-25 天气好好","date":"2018-09-25T11:06:41.000Z","_content":"\n<!--more-->\n\n","source":"_posts/天气好好.md","raw":"---\ntitle: 2018-09-25 天气好好\ndate: 2018-09-25 19:06:41\ncategories: Diary\ntag: diary\n---\n\n<!--more-->\n\n","slug":"天气好好","published":1,"updated":"2019-02-28T09:05:32.125Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf12b00255l26o7sy25l9","content":"<a id=\"more\"></a>\n","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"","more":""},{"title":"2018-09-27 小雨","date":"2018-09-27T11:52:29.000Z","_content":"\n<center>过多的选择，会让最终被选择的“幸运儿”魅力大减，从而满足感更低</center>\n","source":"_posts/小雨.md","raw":"---\ntitle: 2018-09-27 小雨\ndate: 2018-09-27 19:52:29\ncategories: Diary\ntag: diary\n---\n\n<center>过多的选择，会让最终被选择的“幸运儿”魅力大减，从而满足感更低</center>\n","slug":"小雨","published":1,"updated":"2019-02-28T09:05:38.117Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf12c00295l262lo867ng","content":"<center>过多的选择，会让最终被选择的“幸运儿”魅力大减，从而满足感更低</center>\n","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"","more":"<center>过多的选择，会让最终被选择的“幸运儿”魅力大减，从而满足感更低</center>\n"},{"title":"2018.9.23 有风冷了","date":"2018-09-23T00:25:32.000Z","comment":false,"_content":"<center>正是因为不去盲目期许未来，所以任何的一件小事情都会成为惊喜。</center>\n","source":"_posts/有风冷了.md","raw":"---\ntitle: 2018.9.23 有风冷了\ndate: 2018-09-23 08:25:32\ncategories: Diary\ncomment: false\ntag: diary\n---\n<center>正是因为不去盲目期许未来，所以任何的一件小事情都会成为惊喜。</center>\n","slug":"有风冷了","published":1,"updated":"2019-02-28T09:05:43.391Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf12d002c5l26y90f6byq","content":"<center>正是因为不去盲目期许未来，所以任何的一件小事情都会成为惊喜。</center>\n","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"","more":"<center>正是因为不去盲目期许未来，所以任何的一件小事情都会成为惊喜。</center>\n"},{"title":"Meet Kotlin","_content":"\n### Kotlin的几个特性\n#### 扩展函数\n#### 尾随闭包\n当最后一个参数是一个方法或者闭包，可以把方法和闭包提到括号外面。\n#### 标准函数\n* with\n* apply\n* run\n* let\n\n#### data class\n参数中可定义成员变量、可选参数、命名参数等\n\n#### apply plugin: 'kotlin-android-extensions'\n直接使用id作为view对象，无需findviewbyid\n#### 简化lambda表达式\n\n```\nview.setOnClickListener {\n             ....\n        }\n```\n\n##### 配合RxJava\n\n\n```\nObservable.create(ObservableOnSubscribe<Long>{\n    Log.e(TAG, \"发射 线程为：${Thread.currentThread().name} \")\n    it.onNext(12L)\n})\n    .filter {\n        Log.e(TAG, \"filter 线程为：${Thread.currentThread().name} $it \")\n        return@filter it > 10\n    }\n    .subscribeOn(Schedulers.io())\n    .map(Function<Long, String> {\n        Log.e(TAG, \"map 线程为：${Thread.currentThread().name} $it \")\n        return@Function it.toString()\n    })\n    .observeOn(AndroidSchedulers.mainThread())\n    .subscribe {\n        Log.e(TAG, \"处理 线程为：${Thread.currentThread().name} $it \")\n    }\n\n```\n\n#### 空安全\n* `？`\n* `！！`\n\n#### 延迟初始化\n* `lateinit` 用于修饰`var` 如果不初始化 会报异常\n* `by laze{}` 用于修饰`val` 变量 在第一次调用的时候会执行其中代码，并返回一个值，之后再调用都只会返回这个值\n\n#### 委托属性\nget{} / set{}\n\n<hr>\n**详细笔记：**\n\n\n1. 函数参数可以添加默认值，这样可以不穿这个参数，相当于是重载的一种方式\n2. 如果没有任何指定，类的属性会默认的使用getter和setter方法，当然也可以自定义setter方法与getter方法， \n<!--more-->\n```\nvar name: String = \"\"\n        get() = field.toUpperCase()\n        set(value){\n            field = \"Name: $value\"\n        }\n```\n那么既然直接使用点来代替setter方法，那么需要访问属性的时候需要使用，filed来作为属性本来的值。\n\n覆盖方法总是使用与基类型相同的默认值\n\n调用混位置参数时候，命名参数要放在默认位置参数之后，例如：允许：（1，x = 1）不允许 （x = 1 , 1）  \n\n单个表达式函数，可以省略花括号，直接在等号后面接表达式，作为函数体，当返回值类型编译器可以推断出来的时候，可以不同指定函数的返回值类型  \n\n具有代码块的函数需要显示的指定返回值类型， \n\n可变数量的参数Varargs\n\n```\nfun <T> asList(vararg ts:T): List<T> {\n    val result = ArrayList<T>()\n    for(t in ts)//ts is an array\n        result.add(t)\n    return result\n}\n```\n\n\n#### 扩展函数\n```\nfun Context.toast(message: CharSequence, duration: Int = Toast.LENGTH_SHORT) {\n    Toast.makeText(this, message, duration).show()\n}\n```\n扩展了Context，直接使用this，来代表context的实例\n\n** 映射对象到变量中**\n```\nval f1 = Forecast(Date(), 27.5f, \"Shiny day\")\nval (date, temperature, details) = f1\n\nfor ((key, value) in map) {\n    Log.d(\"map\", \"key:$key, value:$value\")\n}\n```\n### 扩展函数\n扩展函数是指在一个类上面增加一种新的行为，它就表现的像是属于这个类一样，而且可以使用this关键字调用类的所有public方法.它可以被任何类和类的扩展子类调用。  \n\n扩展函数是静态解析的，即使是在运行时参数传入其他类型，得出的结果仍然是声明时候的参数类型  \n**扩展函数中的操作符**：  \n```\noperator fun ViewGroup.get(position: Int): View = getChildAt(position)  \n\nval container: ViewGroup = find(R.id.container)\nval view = container[2]\n```\n\n### Lambdas\n定义一个匿名函数，\n在箭头的左边指定参数，在箭头的右边返回函数执行的结果。  \n一直简写，可以写成这样\n```\nview.setOnClickListener { toast(\"Click\") }\n```\n\n```\nfun main(args: Array<String>) {\n   val result = {msg : String -> print(msg)}\n   result(\"hello\")\n}\n```\n**语法糖**   \n\n* 当参数只有一个的时候，声明中可以不用显示的声明参数，在使用参数的时候可以使用it来代替这个唯一的参数\n* 当有多个参数用户到的时候，可以使用下划线来代替参数名，但是如果已经使用下划线来省略参数时候，是不能用it来代替当前参数的\n* Lambda 最后一条语句的执行结果，表示这个表达式的返回值\n\n\n### 高阶函数\n当函数的参数为闭包时，称这个函数为高阶函数  \n\n```\nval printMsg = {str : String -> print(str)}\nval log = { str: String , log:(String)-> Unit -> log(str) }\n\nfun main(args: Array<String>) {\n log(\"hello\",printMsg)\n}\n```\nprintMsg 是一个 lambda表达式 参数为 String  \nlog是一个lambda表达式 参数为 String和一个函数  \n\n***TODO***\n\n### 单例模式\nobject 可以定义在全局也可以在类的内部使用  \nobject 就是单例模式的化身  \nobject 可以实现 Java 中的匿名类  \ncompanion object 就是 Java 中的 static 变量  \ncompanion object 只能定义在对应的类中 \n\n### 委托属性\nKotlin 的属性是天生再带set、get方法的，如果要重写他们的时候需要用到field这个东西，field就是该属性本身的意思。  \n***TODO***\n\n### 集合和函数操作符\n#### 总数操作符：  \nany，至少有一个符合要求返回rue  \nall，全部都要符合要求返回true  \ncount，返回条件判断的总数  \nfold，从第一项，到底i项  \nfoldRight，从最后一项，到第n-i项  \nforEach，遍历所有元素  \nforEachIndexed，  \n#### 过滤操作符：\n* drop，去掉前n个元素 \n* dropWhile从第一项开始去掉指定元素的列表 \n* dropLastWhile 从最后一项开始\n* filter 过滤掉所有符合函数条件的元素\n* filterNot 过滤掉所有不符合条件的元素\n* slice 过滤一个list中指定index的元素\n* take 返回从第一开元素开始的n个元素\n* takeLast 返回从最后一个元素开始的n个元素\n* takeWhile 返回从第一个元素开始符合条件的元素\n#### 映射操作符：\n* flatMap 为每一个元素通过函数省城新的元素集合\n* groupBy 返回一个根据给定函数分组后的map\n* map 返回每一个元素根据给定的函数所转换成的list\n* mapIndexed 返回一个每一个\n* mapNotNull 返回每一个飞null元素根据指定的函数所转换成的list\n#### 元素操作符\n* contains 如果指定元素可以在集合中找到返回true\n* elementAt 返回给定index对应的元素，注意不能越界\n* elementAtOrElse 如果越界返回默认值\n* elementAtOrNull \n* first 返回符合给定函数的第一个元素\n* firstOrNull 没有返回null\n* indexOf 返回指定元素的第一个index 不存在-1\n* indexOfFirst  返回符合条件的第一个元素的index 没有-1\n* indexOfLast 返回最后一个符合给定函数的元素的index 没有-1\n* last 返回符合给定函数的最后一个元素\n* single 返回符合非定函数的单个元素，\n\n\n#### 生产操作符\n* merge 把两个集合合并成一个新的，相同的index的元素通过给定的函数进行合并成新的元素，作为新的元素几个的一个元素，返回这个新的集合，新的集合的大小有最小的那个集合大小决定。\n* partition 通过非定的函数条件，把一个给定的集合分割成两个\n* plus + 两个集合相加\n\n#### 顺序操作符\n* reverse 返回一个翻转原list的list\n* sort 排序\n* sortBy 根据指定函数排序\n* sortDescending 降序排列\n* sortDescendingBy 。。\n\n### 空安全\n```\nval a : Int? = null\n```\n* 通过在类型的后面增加一个问号，就表示允许这个变量为null  \n* 一个可null的变量，在没有检查之前就去使用它，是不能通过编译的。\n* 还有一个特性就是，当我们检查了变量是否为null之后，就可以自动推导出变量不可为null，进而可以使用，编译通过。  \n\n  \n这里使用**安全访问操作符（？）**，来达到判断并推导出可null类型。  \n如果我们确定正在使用一个非null得变量，但是他的类型却是可null类型的，我们可以强制使用！！来使编译器执行可null类型，来跳过限制检查。\n\n### 委托模式\n他可以用来从类中抽取出主要负责的部分。\n委托者只需要指定实现的接口的实例，我们可以使用接口指示鸟可飞行，但是鸟的飞行方式呗定义在一个委托中，这个委托定义在构造函数中，所以我们可以针对不同的鸟使用不同的飞行方式，动物使用翅膀飞行的方式被定义在另一个类中，  \n***TODO***\n\n\n## 泛型\n\n可以使用任何类型初始化\n```\nclass TypedClass<T>(parameter: T) {  \n    val value: T = parameter\n}\n```\n如果在初始化的时候可以推断出参数的类型，甚至可以不需要去指定泛型\n```\nval t1 = TypedClass<String>(\"Hello World!\")\nval t2 = TypedClass<Int>(25)  \nval t2 = TypedClass<Int>(25)\n```\n如果是一个null，则不能推断出他的类型，所以必须要加上？  \n函数中也可以使用泛型  \n\n\n","source":"_posts/blog.md","raw":"---\ntitle: Meet Kotlin\ncategories: \"技术\"\ntag: kotlin\n\n---\n\n### Kotlin的几个特性\n#### 扩展函数\n#### 尾随闭包\n当最后一个参数是一个方法或者闭包，可以把方法和闭包提到括号外面。\n#### 标准函数\n* with\n* apply\n* run\n* let\n\n#### data class\n参数中可定义成员变量、可选参数、命名参数等\n\n#### apply plugin: 'kotlin-android-extensions'\n直接使用id作为view对象，无需findviewbyid\n#### 简化lambda表达式\n\n```\nview.setOnClickListener {\n             ....\n        }\n```\n\n##### 配合RxJava\n\n\n```\nObservable.create(ObservableOnSubscribe<Long>{\n    Log.e(TAG, \"发射 线程为：${Thread.currentThread().name} \")\n    it.onNext(12L)\n})\n    .filter {\n        Log.e(TAG, \"filter 线程为：${Thread.currentThread().name} $it \")\n        return@filter it > 10\n    }\n    .subscribeOn(Schedulers.io())\n    .map(Function<Long, String> {\n        Log.e(TAG, \"map 线程为：${Thread.currentThread().name} $it \")\n        return@Function it.toString()\n    })\n    .observeOn(AndroidSchedulers.mainThread())\n    .subscribe {\n        Log.e(TAG, \"处理 线程为：${Thread.currentThread().name} $it \")\n    }\n\n```\n\n#### 空安全\n* `？`\n* `！！`\n\n#### 延迟初始化\n* `lateinit` 用于修饰`var` 如果不初始化 会报异常\n* `by laze{}` 用于修饰`val` 变量 在第一次调用的时候会执行其中代码，并返回一个值，之后再调用都只会返回这个值\n\n#### 委托属性\nget{} / set{}\n\n<hr>\n**详细笔记：**\n\n\n1. 函数参数可以添加默认值，这样可以不穿这个参数，相当于是重载的一种方式\n2. 如果没有任何指定，类的属性会默认的使用getter和setter方法，当然也可以自定义setter方法与getter方法， \n<!--more-->\n```\nvar name: String = \"\"\n        get() = field.toUpperCase()\n        set(value){\n            field = \"Name: $value\"\n        }\n```\n那么既然直接使用点来代替setter方法，那么需要访问属性的时候需要使用，filed来作为属性本来的值。\n\n覆盖方法总是使用与基类型相同的默认值\n\n调用混位置参数时候，命名参数要放在默认位置参数之后，例如：允许：（1，x = 1）不允许 （x = 1 , 1）  \n\n单个表达式函数，可以省略花括号，直接在等号后面接表达式，作为函数体，当返回值类型编译器可以推断出来的时候，可以不同指定函数的返回值类型  \n\n具有代码块的函数需要显示的指定返回值类型， \n\n可变数量的参数Varargs\n\n```\nfun <T> asList(vararg ts:T): List<T> {\n    val result = ArrayList<T>()\n    for(t in ts)//ts is an array\n        result.add(t)\n    return result\n}\n```\n\n\n#### 扩展函数\n```\nfun Context.toast(message: CharSequence, duration: Int = Toast.LENGTH_SHORT) {\n    Toast.makeText(this, message, duration).show()\n}\n```\n扩展了Context，直接使用this，来代表context的实例\n\n** 映射对象到变量中**\n```\nval f1 = Forecast(Date(), 27.5f, \"Shiny day\")\nval (date, temperature, details) = f1\n\nfor ((key, value) in map) {\n    Log.d(\"map\", \"key:$key, value:$value\")\n}\n```\n### 扩展函数\n扩展函数是指在一个类上面增加一种新的行为，它就表现的像是属于这个类一样，而且可以使用this关键字调用类的所有public方法.它可以被任何类和类的扩展子类调用。  \n\n扩展函数是静态解析的，即使是在运行时参数传入其他类型，得出的结果仍然是声明时候的参数类型  \n**扩展函数中的操作符**：  \n```\noperator fun ViewGroup.get(position: Int): View = getChildAt(position)  \n\nval container: ViewGroup = find(R.id.container)\nval view = container[2]\n```\n\n### Lambdas\n定义一个匿名函数，\n在箭头的左边指定参数，在箭头的右边返回函数执行的结果。  \n一直简写，可以写成这样\n```\nview.setOnClickListener { toast(\"Click\") }\n```\n\n```\nfun main(args: Array<String>) {\n   val result = {msg : String -> print(msg)}\n   result(\"hello\")\n}\n```\n**语法糖**   \n\n* 当参数只有一个的时候，声明中可以不用显示的声明参数，在使用参数的时候可以使用it来代替这个唯一的参数\n* 当有多个参数用户到的时候，可以使用下划线来代替参数名，但是如果已经使用下划线来省略参数时候，是不能用it来代替当前参数的\n* Lambda 最后一条语句的执行结果，表示这个表达式的返回值\n\n\n### 高阶函数\n当函数的参数为闭包时，称这个函数为高阶函数  \n\n```\nval printMsg = {str : String -> print(str)}\nval log = { str: String , log:(String)-> Unit -> log(str) }\n\nfun main(args: Array<String>) {\n log(\"hello\",printMsg)\n}\n```\nprintMsg 是一个 lambda表达式 参数为 String  \nlog是一个lambda表达式 参数为 String和一个函数  \n\n***TODO***\n\n### 单例模式\nobject 可以定义在全局也可以在类的内部使用  \nobject 就是单例模式的化身  \nobject 可以实现 Java 中的匿名类  \ncompanion object 就是 Java 中的 static 变量  \ncompanion object 只能定义在对应的类中 \n\n### 委托属性\nKotlin 的属性是天生再带set、get方法的，如果要重写他们的时候需要用到field这个东西，field就是该属性本身的意思。  \n***TODO***\n\n### 集合和函数操作符\n#### 总数操作符：  \nany，至少有一个符合要求返回rue  \nall，全部都要符合要求返回true  \ncount，返回条件判断的总数  \nfold，从第一项，到底i项  \nfoldRight，从最后一项，到第n-i项  \nforEach，遍历所有元素  \nforEachIndexed，  \n#### 过滤操作符：\n* drop，去掉前n个元素 \n* dropWhile从第一项开始去掉指定元素的列表 \n* dropLastWhile 从最后一项开始\n* filter 过滤掉所有符合函数条件的元素\n* filterNot 过滤掉所有不符合条件的元素\n* slice 过滤一个list中指定index的元素\n* take 返回从第一开元素开始的n个元素\n* takeLast 返回从最后一个元素开始的n个元素\n* takeWhile 返回从第一个元素开始符合条件的元素\n#### 映射操作符：\n* flatMap 为每一个元素通过函数省城新的元素集合\n* groupBy 返回一个根据给定函数分组后的map\n* map 返回每一个元素根据给定的函数所转换成的list\n* mapIndexed 返回一个每一个\n* mapNotNull 返回每一个飞null元素根据指定的函数所转换成的list\n#### 元素操作符\n* contains 如果指定元素可以在集合中找到返回true\n* elementAt 返回给定index对应的元素，注意不能越界\n* elementAtOrElse 如果越界返回默认值\n* elementAtOrNull \n* first 返回符合给定函数的第一个元素\n* firstOrNull 没有返回null\n* indexOf 返回指定元素的第一个index 不存在-1\n* indexOfFirst  返回符合条件的第一个元素的index 没有-1\n* indexOfLast 返回最后一个符合给定函数的元素的index 没有-1\n* last 返回符合给定函数的最后一个元素\n* single 返回符合非定函数的单个元素，\n\n\n#### 生产操作符\n* merge 把两个集合合并成一个新的，相同的index的元素通过给定的函数进行合并成新的元素，作为新的元素几个的一个元素，返回这个新的集合，新的集合的大小有最小的那个集合大小决定。\n* partition 通过非定的函数条件，把一个给定的集合分割成两个\n* plus + 两个集合相加\n\n#### 顺序操作符\n* reverse 返回一个翻转原list的list\n* sort 排序\n* sortBy 根据指定函数排序\n* sortDescending 降序排列\n* sortDescendingBy 。。\n\n### 空安全\n```\nval a : Int? = null\n```\n* 通过在类型的后面增加一个问号，就表示允许这个变量为null  \n* 一个可null的变量，在没有检查之前就去使用它，是不能通过编译的。\n* 还有一个特性就是，当我们检查了变量是否为null之后，就可以自动推导出变量不可为null，进而可以使用，编译通过。  \n\n  \n这里使用**安全访问操作符（？）**，来达到判断并推导出可null类型。  \n如果我们确定正在使用一个非null得变量，但是他的类型却是可null类型的，我们可以强制使用！！来使编译器执行可null类型，来跳过限制检查。\n\n### 委托模式\n他可以用来从类中抽取出主要负责的部分。\n委托者只需要指定实现的接口的实例，我们可以使用接口指示鸟可飞行，但是鸟的飞行方式呗定义在一个委托中，这个委托定义在构造函数中，所以我们可以针对不同的鸟使用不同的飞行方式，动物使用翅膀飞行的方式被定义在另一个类中，  \n***TODO***\n\n\n## 泛型\n\n可以使用任何类型初始化\n```\nclass TypedClass<T>(parameter: T) {  \n    val value: T = parameter\n}\n```\n如果在初始化的时候可以推断出参数的类型，甚至可以不需要去指定泛型\n```\nval t1 = TypedClass<String>(\"Hello World!\")\nval t2 = TypedClass<Int>(25)  \nval t2 = TypedClass<Int>(25)\n```\n如果是一个null，则不能推断出他的类型，所以必须要加上？  \n函数中也可以使用泛型  \n\n\n","slug":"blog","published":1,"date":"2018-09-17T07:43:28.000Z","updated":"2019-02-28T09:28:44.217Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf12p002j5l26qi70wu7m","content":"<h3 id=\"Kotlin的几个特性\"><a href=\"#Kotlin的几个特性\" class=\"headerlink\" title=\"Kotlin的几个特性\"></a>Kotlin的几个特性</h3><h4 id=\"扩展函数\"><a href=\"#扩展函数\" class=\"headerlink\" title=\"扩展函数\"></a>扩展函数</h4><h4 id=\"尾随闭包\"><a href=\"#尾随闭包\" class=\"headerlink\" title=\"尾随闭包\"></a>尾随闭包</h4><p>当最后一个参数是一个方法或者闭包，可以把方法和闭包提到括号外面。</p>\n<h4 id=\"标准函数\"><a href=\"#标准函数\" class=\"headerlink\" title=\"标准函数\"></a>标准函数</h4><ul>\n<li>with</li>\n<li>apply</li>\n<li>run</li>\n<li>let</li>\n</ul>\n<h4 id=\"data-class\"><a href=\"#data-class\" class=\"headerlink\" title=\"data class\"></a>data class</h4><p>参数中可定义成员变量、可选参数、命名参数等</p>\n<h4 id=\"apply-plugin-‘kotlin-android-extensions’\"><a href=\"#apply-plugin-‘kotlin-android-extensions’\" class=\"headerlink\" title=\"apply plugin: ‘kotlin-android-extensions’\"></a>apply plugin: ‘kotlin-android-extensions’</h4><p>直接使用id作为view对象，无需findviewbyid</p>\n<h4 id=\"简化lambda表达式\"><a href=\"#简化lambda表达式\" class=\"headerlink\" title=\"简化lambda表达式\"></a>简化lambda表达式</h4><pre><code>view.setOnClickListener {\n             ....\n        }\n</code></pre><h5 id=\"配合RxJava\"><a href=\"#配合RxJava\" class=\"headerlink\" title=\"配合RxJava\"></a>配合RxJava</h5><pre><code>Observable.create(ObservableOnSubscribe&lt;Long&gt;{\n    Log.e(TAG, &quot;发射 线程为：${Thread.currentThread().name} &quot;)\n    it.onNext(12L)\n})\n    .filter {\n        Log.e(TAG, &quot;filter 线程为：${Thread.currentThread().name} $it &quot;)\n        return@filter it &gt; 10\n    }\n    .subscribeOn(Schedulers.io())\n    .map(Function&lt;Long, String&gt; {\n        Log.e(TAG, &quot;map 线程为：${Thread.currentThread().name} $it &quot;)\n        return@Function it.toString()\n    })\n    .observeOn(AndroidSchedulers.mainThread())\n    .subscribe {\n        Log.e(TAG, &quot;处理 线程为：${Thread.currentThread().name} $it &quot;)\n    }\n\n</code></pre><h4 id=\"空安全\"><a href=\"#空安全\" class=\"headerlink\" title=\"空安全\"></a>空安全</h4><ul>\n<li><code>？</code></li>\n<li><code>！！</code></li>\n</ul>\n<h4 id=\"延迟初始化\"><a href=\"#延迟初始化\" class=\"headerlink\" title=\"延迟初始化\"></a>延迟初始化</h4><ul>\n<li><code>lateinit</code> 用于修饰<code>var</code> 如果不初始化 会报异常</li>\n<li><code>by laze{}</code> 用于修饰<code>val</code> 变量 在第一次调用的时候会执行其中代码，并返回一个值，之后再调用都只会返回这个值</li>\n</ul>\n<h4 id=\"委托属性\"><a href=\"#委托属性\" class=\"headerlink\" title=\"委托属性\"></a>委托属性</h4><p>get{} / set{}</p>\n<p><hr><br><strong>详细笔记：</strong></p>\n<ol>\n<li>函数参数可以添加默认值，这样可以不穿这个参数，相当于是重载的一种方式</li>\n<li>如果没有任何指定，类的属性会默认的使用getter和setter方法，当然也可以自定义setter方法与getter方法， <a id=\"more\"></a>\n<pre><code>var name: String = &quot;&quot;\n     get() = field.toUpperCase()\n     set(value){\n         field = &quot;Name: $value&quot;\n     }\n</code></pre>那么既然直接使用点来代替setter方法，那么需要访问属性的时候需要使用，filed来作为属性本来的值。</li>\n</ol>\n<p>覆盖方法总是使用与基类型相同的默认值</p>\n<p>调用混位置参数时候，命名参数要放在默认位置参数之后，例如：允许：（1，x = 1）不允许 （x = 1 , 1）  </p>\n<p>单个表达式函数，可以省略花括号，直接在等号后面接表达式，作为函数体，当返回值类型编译器可以推断出来的时候，可以不同指定函数的返回值类型  </p>\n<p>具有代码块的函数需要显示的指定返回值类型， </p>\n<p>可变数量的参数Varargs</p>\n<pre><code>fun &lt;T&gt; asList(vararg ts:T): List&lt;T&gt; {\n    val result = ArrayList&lt;T&gt;()\n    for(t in ts)//ts is an array\n        result.add(t)\n    return result\n}\n</code></pre><h4 id=\"扩展函数-1\"><a href=\"#扩展函数-1\" class=\"headerlink\" title=\"扩展函数\"></a>扩展函数</h4><pre><code>fun Context.toast(message: CharSequence, duration: Int = Toast.LENGTH_SHORT) {\n    Toast.makeText(this, message, duration).show()\n}\n</code></pre><p>扩展了Context，直接使用this，来代表context的实例</p>\n<p><strong> 映射对象到变量中</strong></p>\n<pre><code>val f1 = Forecast(Date(), 27.5f, &quot;Shiny day&quot;)\nval (date, temperature, details) = f1\n\nfor ((key, value) in map) {\n    Log.d(&quot;map&quot;, &quot;key:$key, value:$value&quot;)\n}\n</code></pre><h3 id=\"扩展函数-2\"><a href=\"#扩展函数-2\" class=\"headerlink\" title=\"扩展函数\"></a>扩展函数</h3><p>扩展函数是指在一个类上面增加一种新的行为，它就表现的像是属于这个类一样，而且可以使用this关键字调用类的所有public方法.它可以被任何类和类的扩展子类调用。  </p>\n<p>扩展函数是静态解析的，即使是在运行时参数传入其他类型，得出的结果仍然是声明时候的参数类型<br><strong>扩展函数中的操作符</strong>：  </p>\n<pre><code>operator fun ViewGroup.get(position: Int): View = getChildAt(position)  \n\nval container: ViewGroup = find(R.id.container)\nval view = container[2]\n</code></pre><h3 id=\"Lambdas\"><a href=\"#Lambdas\" class=\"headerlink\" title=\"Lambdas\"></a>Lambdas</h3><p>定义一个匿名函数，<br>在箭头的左边指定参数，在箭头的右边返回函数执行的结果。<br>一直简写，可以写成这样</p>\n<pre><code>view.setOnClickListener { toast(&quot;Click&quot;) }\n</code></pre><pre><code>fun main(args: Array&lt;String&gt;) {\n   val result = {msg : String -&gt; print(msg)}\n   result(&quot;hello&quot;)\n}\n</code></pre><p><strong>语法糖</strong>   </p>\n<ul>\n<li>当参数只有一个的时候，声明中可以不用显示的声明参数，在使用参数的时候可以使用it来代替这个唯一的参数</li>\n<li>当有多个参数用户到的时候，可以使用下划线来代替参数名，但是如果已经使用下划线来省略参数时候，是不能用it来代替当前参数的</li>\n<li>Lambda 最后一条语句的执行结果，表示这个表达式的返回值</li>\n</ul>\n<h3 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h3><p>当函数的参数为闭包时，称这个函数为高阶函数  </p>\n<pre><code>val printMsg = {str : String -&gt; print(str)}\nval log = { str: String , log:(String)-&gt; Unit -&gt; log(str) }\n\nfun main(args: Array&lt;String&gt;) {\n log(&quot;hello&quot;,printMsg)\n}\n</code></pre><p>printMsg 是一个 lambda表达式 参数为 String<br>log是一个lambda表达式 参数为 String和一个函数  </p>\n<p><strong><em>TODO</em></strong></p>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><p>object 可以定义在全局也可以在类的内部使用<br>object 就是单例模式的化身<br>object 可以实现 Java 中的匿名类<br>companion object 就是 Java 中的 static 变量<br>companion object 只能定义在对应的类中 </p>\n<h3 id=\"委托属性-1\"><a href=\"#委托属性-1\" class=\"headerlink\" title=\"委托属性\"></a>委托属性</h3><p>Kotlin 的属性是天生再带set、get方法的，如果要重写他们的时候需要用到field这个东西，field就是该属性本身的意思。<br><strong><em>TODO</em></strong></p>\n<h3 id=\"集合和函数操作符\"><a href=\"#集合和函数操作符\" class=\"headerlink\" title=\"集合和函数操作符\"></a>集合和函数操作符</h3><h4 id=\"总数操作符：\"><a href=\"#总数操作符：\" class=\"headerlink\" title=\"总数操作符：\"></a>总数操作符：</h4><p>any，至少有一个符合要求返回rue<br>all，全部都要符合要求返回true<br>count，返回条件判断的总数<br>fold，从第一项，到底i项<br>foldRight，从最后一项，到第n-i项<br>forEach，遍历所有元素<br>forEachIndexed，  </p>\n<h4 id=\"过滤操作符：\"><a href=\"#过滤操作符：\" class=\"headerlink\" title=\"过滤操作符：\"></a>过滤操作符：</h4><ul>\n<li>drop，去掉前n个元素 </li>\n<li>dropWhile从第一项开始去掉指定元素的列表 </li>\n<li>dropLastWhile 从最后一项开始</li>\n<li>filter 过滤掉所有符合函数条件的元素</li>\n<li>filterNot 过滤掉所有不符合条件的元素</li>\n<li>slice 过滤一个list中指定index的元素</li>\n<li>take 返回从第一开元素开始的n个元素</li>\n<li>takeLast 返回从最后一个元素开始的n个元素</li>\n<li>takeWhile 返回从第一个元素开始符合条件的元素<h4 id=\"映射操作符：\"><a href=\"#映射操作符：\" class=\"headerlink\" title=\"映射操作符：\"></a>映射操作符：</h4></li>\n<li>flatMap 为每一个元素通过函数省城新的元素集合</li>\n<li>groupBy 返回一个根据给定函数分组后的map</li>\n<li>map 返回每一个元素根据给定的函数所转换成的list</li>\n<li>mapIndexed 返回一个每一个</li>\n<li>mapNotNull 返回每一个飞null元素根据指定的函数所转换成的list<h4 id=\"元素操作符\"><a href=\"#元素操作符\" class=\"headerlink\" title=\"元素操作符\"></a>元素操作符</h4></li>\n<li>contains 如果指定元素可以在集合中找到返回true</li>\n<li>elementAt 返回给定index对应的元素，注意不能越界</li>\n<li>elementAtOrElse 如果越界返回默认值</li>\n<li>elementAtOrNull </li>\n<li>first 返回符合给定函数的第一个元素</li>\n<li>firstOrNull 没有返回null</li>\n<li>indexOf 返回指定元素的第一个index 不存在-1</li>\n<li>indexOfFirst  返回符合条件的第一个元素的index 没有-1</li>\n<li>indexOfLast 返回最后一个符合给定函数的元素的index 没有-1</li>\n<li>last 返回符合给定函数的最后一个元素</li>\n<li>single 返回符合非定函数的单个元素，</li>\n</ul>\n<h4 id=\"生产操作符\"><a href=\"#生产操作符\" class=\"headerlink\" title=\"生产操作符\"></a>生产操作符</h4><ul>\n<li>merge 把两个集合合并成一个新的，相同的index的元素通过给定的函数进行合并成新的元素，作为新的元素几个的一个元素，返回这个新的集合，新的集合的大小有最小的那个集合大小决定。</li>\n<li>partition 通过非定的函数条件，把一个给定的集合分割成两个</li>\n<li>plus + 两个集合相加</li>\n</ul>\n<h4 id=\"顺序操作符\"><a href=\"#顺序操作符\" class=\"headerlink\" title=\"顺序操作符\"></a>顺序操作符</h4><ul>\n<li>reverse 返回一个翻转原list的list</li>\n<li>sort 排序</li>\n<li>sortBy 根据指定函数排序</li>\n<li>sortDescending 降序排列</li>\n<li>sortDescendingBy 。。</li>\n</ul>\n<h3 id=\"空安全-1\"><a href=\"#空安全-1\" class=\"headerlink\" title=\"空安全\"></a>空安全</h3><pre><code>val a : Int? = null\n</code></pre><ul>\n<li>通过在类型的后面增加一个问号，就表示允许这个变量为null  </li>\n<li>一个可null的变量，在没有检查之前就去使用它，是不能通过编译的。</li>\n<li>还有一个特性就是，当我们检查了变量是否为null之后，就可以自动推导出变量不可为null，进而可以使用，编译通过。  </li>\n</ul>\n<p>这里使用<strong>安全访问操作符（？）</strong>，来达到判断并推导出可null类型。<br>如果我们确定正在使用一个非null得变量，但是他的类型却是可null类型的，我们可以强制使用！！来使编译器执行可null类型，来跳过限制检查。</p>\n<h3 id=\"委托模式\"><a href=\"#委托模式\" class=\"headerlink\" title=\"委托模式\"></a>委托模式</h3><p>他可以用来从类中抽取出主要负责的部分。<br>委托者只需要指定实现的接口的实例，我们可以使用接口指示鸟可飞行，但是鸟的飞行方式呗定义在一个委托中，这个委托定义在构造函数中，所以我们可以针对不同的鸟使用不同的飞行方式，动物使用翅膀飞行的方式被定义在另一个类中，<br><strong><em>TODO</em></strong></p>\n<h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><p>可以使用任何类型初始化</p>\n<pre><code>class TypedClass&lt;T&gt;(parameter: T) {  \n    val value: T = parameter\n}\n</code></pre><p>如果在初始化的时候可以推断出参数的类型，甚至可以不需要去指定泛型</p>\n<pre><code>val t1 = TypedClass&lt;String&gt;(&quot;Hello World!&quot;)\nval t2 = TypedClass&lt;Int&gt;(25)  \nval t2 = TypedClass&lt;Int&gt;(25)\n</code></pre><p>如果是一个null，则不能推断出他的类型，所以必须要加上？<br>函数中也可以使用泛型  </p>\n","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"<h3 id=\"Kotlin的几个特性\"><a href=\"#Kotlin的几个特性\" class=\"headerlink\" title=\"Kotlin的几个特性\"></a>Kotlin的几个特性</h3><h4 id=\"扩展函数\"><a href=\"#扩展函数\" class=\"headerlink\" title=\"扩展函数\"></a>扩展函数</h4><h4 id=\"尾随闭包\"><a href=\"#尾随闭包\" class=\"headerlink\" title=\"尾随闭包\"></a>尾随闭包</h4><p>当最后一个参数是一个方法或者闭包，可以把方法和闭包提到括号外面。</p>\n<h4 id=\"标准函数\"><a href=\"#标准函数\" class=\"headerlink\" title=\"标准函数\"></a>标准函数</h4><ul>\n<li>with</li>\n<li>apply</li>\n<li>run</li>\n<li>let</li>\n</ul>\n<h4 id=\"data-class\"><a href=\"#data-class\" class=\"headerlink\" title=\"data class\"></a>data class</h4><p>参数中可定义成员变量、可选参数、命名参数等</p>\n<h4 id=\"apply-plugin-‘kotlin-android-extensions’\"><a href=\"#apply-plugin-‘kotlin-android-extensions’\" class=\"headerlink\" title=\"apply plugin: ‘kotlin-android-extensions’\"></a>apply plugin: ‘kotlin-android-extensions’</h4><p>直接使用id作为view对象，无需findviewbyid</p>\n<h4 id=\"简化lambda表达式\"><a href=\"#简化lambda表达式\" class=\"headerlink\" title=\"简化lambda表达式\"></a>简化lambda表达式</h4><pre><code>view.setOnClickListener {\n             ....\n        }\n</code></pre><h5 id=\"配合RxJava\"><a href=\"#配合RxJava\" class=\"headerlink\" title=\"配合RxJava\"></a>配合RxJava</h5><pre><code>Observable.create(ObservableOnSubscribe&lt;Long&gt;{\n    Log.e(TAG, &quot;发射 线程为：${Thread.currentThread().name} &quot;)\n    it.onNext(12L)\n})\n    .filter {\n        Log.e(TAG, &quot;filter 线程为：${Thread.currentThread().name} $it &quot;)\n        return@filter it &gt; 10\n    }\n    .subscribeOn(Schedulers.io())\n    .map(Function&lt;Long, String&gt; {\n        Log.e(TAG, &quot;map 线程为：${Thread.currentThread().name} $it &quot;)\n        return@Function it.toString()\n    })\n    .observeOn(AndroidSchedulers.mainThread())\n    .subscribe {\n        Log.e(TAG, &quot;处理 线程为：${Thread.currentThread().name} $it &quot;)\n    }\n\n</code></pre><h4 id=\"空安全\"><a href=\"#空安全\" class=\"headerlink\" title=\"空安全\"></a>空安全</h4><ul>\n<li><code>？</code></li>\n<li><code>！！</code></li>\n</ul>\n<h4 id=\"延迟初始化\"><a href=\"#延迟初始化\" class=\"headerlink\" title=\"延迟初始化\"></a>延迟初始化</h4><ul>\n<li><code>lateinit</code> 用于修饰<code>var</code> 如果不初始化 会报异常</li>\n<li><code>by laze{}</code> 用于修饰<code>val</code> 变量 在第一次调用的时候会执行其中代码，并返回一个值，之后再调用都只会返回这个值</li>\n</ul>\n<h4 id=\"委托属性\"><a href=\"#委托属性\" class=\"headerlink\" title=\"委托属性\"></a>委托属性</h4><p>get{} / set{}</p>\n<p><hr><br><strong>详细笔记：</strong></p>\n<ol>\n<li>函数参数可以添加默认值，这样可以不穿这个参数，相当于是重载的一种方式</li>\n<li>如果没有任何指定，类的属性会默认的使用getter和setter方法，当然也可以自定义setter方法与getter方法，","more":"<pre><code>var name: String = &quot;&quot;\n     get() = field.toUpperCase()\n     set(value){\n         field = &quot;Name: $value&quot;\n     }\n</code></pre>那么既然直接使用点来代替setter方法，那么需要访问属性的时候需要使用，filed来作为属性本来的值。</li>\n</ol>\n<p>覆盖方法总是使用与基类型相同的默认值</p>\n<p>调用混位置参数时候，命名参数要放在默认位置参数之后，例如：允许：（1，x = 1）不允许 （x = 1 , 1）  </p>\n<p>单个表达式函数，可以省略花括号，直接在等号后面接表达式，作为函数体，当返回值类型编译器可以推断出来的时候，可以不同指定函数的返回值类型  </p>\n<p>具有代码块的函数需要显示的指定返回值类型， </p>\n<p>可变数量的参数Varargs</p>\n<pre><code>fun &lt;T&gt; asList(vararg ts:T): List&lt;T&gt; {\n    val result = ArrayList&lt;T&gt;()\n    for(t in ts)//ts is an array\n        result.add(t)\n    return result\n}\n</code></pre><h4 id=\"扩展函数-1\"><a href=\"#扩展函数-1\" class=\"headerlink\" title=\"扩展函数\"></a>扩展函数</h4><pre><code>fun Context.toast(message: CharSequence, duration: Int = Toast.LENGTH_SHORT) {\n    Toast.makeText(this, message, duration).show()\n}\n</code></pre><p>扩展了Context，直接使用this，来代表context的实例</p>\n<p><strong> 映射对象到变量中</strong></p>\n<pre><code>val f1 = Forecast(Date(), 27.5f, &quot;Shiny day&quot;)\nval (date, temperature, details) = f1\n\nfor ((key, value) in map) {\n    Log.d(&quot;map&quot;, &quot;key:$key, value:$value&quot;)\n}\n</code></pre><h3 id=\"扩展函数-2\"><a href=\"#扩展函数-2\" class=\"headerlink\" title=\"扩展函数\"></a>扩展函数</h3><p>扩展函数是指在一个类上面增加一种新的行为，它就表现的像是属于这个类一样，而且可以使用this关键字调用类的所有public方法.它可以被任何类和类的扩展子类调用。  </p>\n<p>扩展函数是静态解析的，即使是在运行时参数传入其他类型，得出的结果仍然是声明时候的参数类型<br><strong>扩展函数中的操作符</strong>：  </p>\n<pre><code>operator fun ViewGroup.get(position: Int): View = getChildAt(position)  \n\nval container: ViewGroup = find(R.id.container)\nval view = container[2]\n</code></pre><h3 id=\"Lambdas\"><a href=\"#Lambdas\" class=\"headerlink\" title=\"Lambdas\"></a>Lambdas</h3><p>定义一个匿名函数，<br>在箭头的左边指定参数，在箭头的右边返回函数执行的结果。<br>一直简写，可以写成这样</p>\n<pre><code>view.setOnClickListener { toast(&quot;Click&quot;) }\n</code></pre><pre><code>fun main(args: Array&lt;String&gt;) {\n   val result = {msg : String -&gt; print(msg)}\n   result(&quot;hello&quot;)\n}\n</code></pre><p><strong>语法糖</strong>   </p>\n<ul>\n<li>当参数只有一个的时候，声明中可以不用显示的声明参数，在使用参数的时候可以使用it来代替这个唯一的参数</li>\n<li>当有多个参数用户到的时候，可以使用下划线来代替参数名，但是如果已经使用下划线来省略参数时候，是不能用it来代替当前参数的</li>\n<li>Lambda 最后一条语句的执行结果，表示这个表达式的返回值</li>\n</ul>\n<h3 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h3><p>当函数的参数为闭包时，称这个函数为高阶函数  </p>\n<pre><code>val printMsg = {str : String -&gt; print(str)}\nval log = { str: String , log:(String)-&gt; Unit -&gt; log(str) }\n\nfun main(args: Array&lt;String&gt;) {\n log(&quot;hello&quot;,printMsg)\n}\n</code></pre><p>printMsg 是一个 lambda表达式 参数为 String<br>log是一个lambda表达式 参数为 String和一个函数  </p>\n<p><strong><em>TODO</em></strong></p>\n<h3 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h3><p>object 可以定义在全局也可以在类的内部使用<br>object 就是单例模式的化身<br>object 可以实现 Java 中的匿名类<br>companion object 就是 Java 中的 static 变量<br>companion object 只能定义在对应的类中 </p>\n<h3 id=\"委托属性-1\"><a href=\"#委托属性-1\" class=\"headerlink\" title=\"委托属性\"></a>委托属性</h3><p>Kotlin 的属性是天生再带set、get方法的，如果要重写他们的时候需要用到field这个东西，field就是该属性本身的意思。<br><strong><em>TODO</em></strong></p>\n<h3 id=\"集合和函数操作符\"><a href=\"#集合和函数操作符\" class=\"headerlink\" title=\"集合和函数操作符\"></a>集合和函数操作符</h3><h4 id=\"总数操作符：\"><a href=\"#总数操作符：\" class=\"headerlink\" title=\"总数操作符：\"></a>总数操作符：</h4><p>any，至少有一个符合要求返回rue<br>all，全部都要符合要求返回true<br>count，返回条件判断的总数<br>fold，从第一项，到底i项<br>foldRight，从最后一项，到第n-i项<br>forEach，遍历所有元素<br>forEachIndexed，  </p>\n<h4 id=\"过滤操作符：\"><a href=\"#过滤操作符：\" class=\"headerlink\" title=\"过滤操作符：\"></a>过滤操作符：</h4><ul>\n<li>drop，去掉前n个元素 </li>\n<li>dropWhile从第一项开始去掉指定元素的列表 </li>\n<li>dropLastWhile 从最后一项开始</li>\n<li>filter 过滤掉所有符合函数条件的元素</li>\n<li>filterNot 过滤掉所有不符合条件的元素</li>\n<li>slice 过滤一个list中指定index的元素</li>\n<li>take 返回从第一开元素开始的n个元素</li>\n<li>takeLast 返回从最后一个元素开始的n个元素</li>\n<li>takeWhile 返回从第一个元素开始符合条件的元素<h4 id=\"映射操作符：\"><a href=\"#映射操作符：\" class=\"headerlink\" title=\"映射操作符：\"></a>映射操作符：</h4></li>\n<li>flatMap 为每一个元素通过函数省城新的元素集合</li>\n<li>groupBy 返回一个根据给定函数分组后的map</li>\n<li>map 返回每一个元素根据给定的函数所转换成的list</li>\n<li>mapIndexed 返回一个每一个</li>\n<li>mapNotNull 返回每一个飞null元素根据指定的函数所转换成的list<h4 id=\"元素操作符\"><a href=\"#元素操作符\" class=\"headerlink\" title=\"元素操作符\"></a>元素操作符</h4></li>\n<li>contains 如果指定元素可以在集合中找到返回true</li>\n<li>elementAt 返回给定index对应的元素，注意不能越界</li>\n<li>elementAtOrElse 如果越界返回默认值</li>\n<li>elementAtOrNull </li>\n<li>first 返回符合给定函数的第一个元素</li>\n<li>firstOrNull 没有返回null</li>\n<li>indexOf 返回指定元素的第一个index 不存在-1</li>\n<li>indexOfFirst  返回符合条件的第一个元素的index 没有-1</li>\n<li>indexOfLast 返回最后一个符合给定函数的元素的index 没有-1</li>\n<li>last 返回符合给定函数的最后一个元素</li>\n<li>single 返回符合非定函数的单个元素，</li>\n</ul>\n<h4 id=\"生产操作符\"><a href=\"#生产操作符\" class=\"headerlink\" title=\"生产操作符\"></a>生产操作符</h4><ul>\n<li>merge 把两个集合合并成一个新的，相同的index的元素通过给定的函数进行合并成新的元素，作为新的元素几个的一个元素，返回这个新的集合，新的集合的大小有最小的那个集合大小决定。</li>\n<li>partition 通过非定的函数条件，把一个给定的集合分割成两个</li>\n<li>plus + 两个集合相加</li>\n</ul>\n<h4 id=\"顺序操作符\"><a href=\"#顺序操作符\" class=\"headerlink\" title=\"顺序操作符\"></a>顺序操作符</h4><ul>\n<li>reverse 返回一个翻转原list的list</li>\n<li>sort 排序</li>\n<li>sortBy 根据指定函数排序</li>\n<li>sortDescending 降序排列</li>\n<li>sortDescendingBy 。。</li>\n</ul>\n<h3 id=\"空安全-1\"><a href=\"#空安全-1\" class=\"headerlink\" title=\"空安全\"></a>空安全</h3><pre><code>val a : Int? = null\n</code></pre><ul>\n<li>通过在类型的后面增加一个问号，就表示允许这个变量为null  </li>\n<li>一个可null的变量，在没有检查之前就去使用它，是不能通过编译的。</li>\n<li>还有一个特性就是，当我们检查了变量是否为null之后，就可以自动推导出变量不可为null，进而可以使用，编译通过。  </li>\n</ul>\n<p>这里使用<strong>安全访问操作符（？）</strong>，来达到判断并推导出可null类型。<br>如果我们确定正在使用一个非null得变量，但是他的类型却是可null类型的，我们可以强制使用！！来使编译器执行可null类型，来跳过限制检查。</p>\n<h3 id=\"委托模式\"><a href=\"#委托模式\" class=\"headerlink\" title=\"委托模式\"></a>委托模式</h3><p>他可以用来从类中抽取出主要负责的部分。<br>委托者只需要指定实现的接口的实例，我们可以使用接口指示鸟可飞行，但是鸟的飞行方式呗定义在一个委托中，这个委托定义在构造函数中，所以我们可以针对不同的鸟使用不同的飞行方式，动物使用翅膀飞行的方式被定义在另一个类中，<br><strong><em>TODO</em></strong></p>\n<h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><p>可以使用任何类型初始化</p>\n<pre><code>class TypedClass&lt;T&gt;(parameter: T) {  \n    val value: T = parameter\n}\n</code></pre><p>如果在初始化的时候可以推断出参数的类型，甚至可以不需要去指定泛型</p>\n<pre><code>val t1 = TypedClass&lt;String&gt;(&quot;Hello World!&quot;)\nval t2 = TypedClass&lt;Int&gt;(25)  \nval t2 = TypedClass&lt;Int&gt;(25)\n</code></pre><p>如果是一个null，则不能推断出他的类型，所以必须要加上？<br>函数中也可以使用泛型  </p>"},{"title":"Java反射","date":"2018-10-12T09:50:17.000Z","_content":"### Java反射\n\n#### Class的获取\n* Class是一个类，不同于小写的class是关键字，不过它没有公开的构造方法，所以只能用`getClass()`方法获取相应的Class对象。\n\n```\nClass aClass = new car().getClass();\n```\n<!--more-->\n**Attention~**\n\n* 这种方法不适合基本类型如 int、float 等等，也可以用\n`.class`来获取\n\n```\nClass aClass = new car().getClass();\nClass aClass1 = car.class;\nClass aClass2 = int.class;\nClass aClass3 = String.class;\n```\n* `Class.forName(包名+类名)`例如某些类加上了@hide注解，表示这个类不会出现在SDK中，那么我们没办法获得Car，索性就直接传入它的名字好了。\n\n#### Class的名字\n1. `getName()`获取到的名字包含包名\n2. `getSimpleName()` 相较于`getName()`去掉了包名，注意，匿名内部类获取的simpleName是一个空的字符串\n3. ` getCanonicalName()`官方名字，如果没有返回null\n\n#### Class获取修饰符\nJava中对于一个类的修饰符有很多\n我们可以这样获取他们\n\n```\nSystem.out.println(Modifier.toString(testModeify.class.getModifiers()));\n```\n结果为：public abstract  \n还提供了一系列的判断方法如：\nisInterface、isAbstract、isSynchronized、isFinal等等\n```\nSystem.out.println(Modifier.isPrivate(testModeify.class.getModifiers()));\n```\n结果为false\n\n#### 获取Class成员\n##### 获取属性\n* `getDeclaredField(String name) `获取的是Class中的属性，不包含父类中的属性。\n* `getField() `获取Class中的Public属性，并且如果获取不到的话，会向其父类获取。 \n*  `public Field[] getDeclaredFields()`获取所有的属性，但不包括从父类继承下来的属性\n*  `public Field[] getFields()`获取自身的所有的 public 属性，包括从父类继承下来的。\nLook at these 注释掉的是不合法的。留下的就一目了然了。\n\n```\nClass son =  Son.class;\ntry {\nSystem.out.println(son.getDeclaredField(\"sonStrDef\"));\nSystem.out.println(son.getDeclaredField(\"sonPub\"));\nSystem.out.println(son.getDeclaredField(\"sonPro\"));\nSystem.out.println(son.getDeclaredField(\"sonPri\"));\n//            System.out.println(son.getDeclaredField(\"fatherStr\"));//error\n//            System.out.println(son.getDeclaredField(\"fatherPub\"));\n//            System.out.println(son.getDeclaredField(\"fatherPri\"));\n//            System.out.println(son.getDeclaredField(\"fatherProt\"));\n\n//            System.out.println(son.getField(\"sonStrDef\"));\nSystem.out.println(son.getField(\"sonPub\"));\n//            System.out.println(son.getField(\"sonPro\"));\n//            System.out.println(son.getField(\"sonPri\"));\n//            System.out.println(son.getField(\"fatherStr\"));\nSystem.out.println(son.getField(\"fatherPub\"));\n//            System.out.println(son.getField(\"fatherPri\"));\n//            System.out.println(son.getField(\"fatherProt\"));\n\n} catch (NoSuchFieldException e) {\ne.printStackTrace();\n}\n```\n\n##### 获取方法\n与获取属性一样\n\n* `getDeclaredMethod`\n* `getMethod `\n* `getDeclaredMethods `\n* `getMethod `\n\n##### 获取构造方法\n一样\n\n#### Field类型的获取\n* `public Type getGenericType() {}`\n* `public Class<?> getType() {} `\n\n不同的是两者**返回的类型**不一样，`getGenericType()` 方法能够获取到**泛型**类型。\n\n看一个例子：\n\n* 定义一个公开list集合\n\n```\npublic List<String> strs = new ArrayList<>();\n```\n\n* 然后通过反射获取这个属性\n\n```\nfor (Field field : son.getFields()) {\nSystem.out.println(field.getName());\nSystem.out.println(field.getType());\nSystem.out.println(field.getGenericType());\n}\n\n```\n输出为：\n\n```\nstrs\ninterface java.util.List\njava.util.List<java.lang.String>\n```\n#### Field读取与赋值\nField这个类定义了一系列的`set/get`方法来获取不同类型的值。  \n例如：  \n`public Object get(Object obj);`\n`public void set(Object obj, Object value);`   \nObject参数的作用是为了精确到到底修改的是哪一个对象\n>Class 本身不对成员进行储存，它只提供检索，所以需要用 Field、Method、Constructor 对象来承载这些成员，所以，针对成员的操作时，一般需要为成员指定类的实例引用。如果难于理解的话，可以这样理解，班级这个概念是一个类，一个班级有几十名学生，现在有A、B、C 3 个班级，将所有班级的学生抽出来集合到一个场地来考试，但是学生在试卷上写上自己名字的时候，还要指定自己的班级，这里涉及到的 Object 其实就是类似的作用，表示这个成员是具体属于哪个 Object。这个是为了精确定位。  \n\n###### 例子\n修改一个类中的Public属性值\n\n```\nClass son =  Son.class;//Class\nSon s = new Son();// Object 用于精确修改的位置\nSon s2 = new Son();// Object 用于精确修改的位置\ns.sonInt = 111;\ns2.sonInt = 222;\ntry {\nField field = son.getField(\"sonInt\");\nint a = field.getInt(s);\nint a1 = field.getInt(s2);\nSystem.out.println(\"field a = \" + a);\nSystem.out.println(\"field a1 = \" + a1);\nfield.setInt(s,1111);\nfield.setInt(s2,2222);\nSystem.out.println(\"field s.sonInt = \" + s.sonInt);\nSystem.out.println(\"field s2.sonInt = \" + s2.sonInt);\n} catch (NoSuchFieldException e) {\ne.printStackTrace();\n} catch (IllegalAccessException e) {\ne.printStackTrace();\n}\n```\n\n```\nfield a = 111\nfield a1 = 222\nfield s.sonInt = 1111\nfield s2.sonInt = 2222\n```\n可以看到，一个field可以根据Object的参数不同，获取的值也不同，同样修改的值也不同。\n\n上面是修改的Public的属性值，如果要修改private属性的话，直接用上面的方法会报错。`can not access a member`\n应该加上**`field.setAccessible(true);`**就万事大吉了。\n\n#### 获取方法参数\n* `public Parameter[] getParameters() {}`\n* Parameter.java\n* `public String getName() {}`// 获取参数名字\n* `public Class<?> getType() {}`// 获取参数类型\n* `public int getModifiers() {}`// 获取参数的修饰符\n* Method.java\n* `public Class<?>[] getParameterTypes() {}`// 获取所有的参数类型\n* `public Type[] getGenericParameterTypes() {}`// 获取所有的参数类型，包括泛型\n\n看一组例子：  \nSon.java\n\n```\npublic class Son extends Father {\n\nvoid normalMethod(String name, int num) {\n}\n\npublic void test(String[] paraa, List<String> b, HashMap<Integer, Son> maps) {\n}\n\npublic void exe() {\nSystem.out.println(\"exexexeexexeexeexeexeee\");\n}\n}\n```\n```\nClass son = Son.class;\n\nMethod[] declaredMethods = son.getDeclaredMethods();\nfor (Method method : declaredMethods) {\nSystem.out.println(method.getName());\n// 参数类型\nParameter[] parameters = method.getParameters();\nfor (Parameter parameter : parameters) {\nSystem.out.println(\"parameter name = \" + parameter.getName() + \" \" + parameter.getType().getName());\n}\n\nClass<?>[] parameterTypes = method.getParameterTypes();\nSystem.out.println(\"method para types:\");\nfor (Class<?> type : parameterTypes) {\nSystem.out.print(\" \" + type.getName());\n}\nSystem.out.println();\n\nType[] genericParameterTypes = method.getGenericParameterTypes();\nSystem.out.println(\"method para generic types:\");\nfor (Type type : genericParameterTypes) {\nSystem.out.print(\" \" + type.getTypeName());\n}\nSystem.out.println();\nSystem.out.println(\"==========================================\");\n\n}\n```\n来看一下输出，很清晰\n\n```\ntest\nparameter name = arg0 [Ljava.lang.String;\nparameter name = arg1 java.util.List\nparameter name = arg2 java.util.HashMap\nmethod para types:\n[Ljava.lang.String; java.util.List java.util.HashMap\nmethod para generic types:\njava.lang.String[] java.util.List<java.lang.String> java.util.HashMap<java.lang.Integer, com.zcy.nidavellir.javaworld.Reflection.Son>\n==========================================\nnormalMethod\nparameter name = arg0 java.lang.String\nparameter name = arg1 int\nmethod para types:\njava.lang.String int\nmethod para generic types:\njava.lang.String int\n==========================================\nexe\nmethod para types:\n\nmethod para generic types:\n\n==========================================\n```\n#### Method 获取返回值类型\n* `public Class<?> getReturnType() {}`// 获取返回值类型\n* `public Type getGenericReturnType() {}`// 获取返回值类型包括泛型\n\n#### Method 获取修饰符\n* `public int getModifiers() {}`\n\n#### Method 获取异常类型\n* `public Class<?>[] getExceptionTypes() {}`\n* `public Type[] getGenericExceptionTypes() {}`\n\n#### Method 方法的执行\n* `public Object invoke(Object obj, Object... args) {}`\n\n说明一下:\n\n* 第一个参数是反射Class对应类的一个实例。如果是静态方法，那么传`null`。后面的参数对应方法Method的参数\n* `invoke()` 返回的对象是 Object，所以实际上执行的时候要进行强制转换。\n* 在对 Method 调用 `invoke()` 的时候，如果方法本身会抛出异常，那么这个异常就会经过包装，由 Method 统一抛出 `InvocationTargetException`。而通过 `InvocationTargetException.getCause()` 可以获取真正的异常。 \n* \n例子：\n\n```\npublic class testInvoke {\npublic static void staticMethod(){\nSystem.out.println(\"我是个静态方法，我被调用啦\");\n}\n\nprivate  int add (int a,int b ) {\nreturn a + b;\n}\n\npublic void testException () throws IllegalAccessException {\nthrow new IllegalAccessException(\"You have some problem.\");\n}\n}\n\n```\n\n我们来验证一下：\n\n```\nClass cls = testInvoke.class;\ntry {\n\nMethod method = cls.getMethod(\"staticMethod\", null);// 参数类型的Class，没有参数所以null\nmethod.invoke(null, null);// 静态方法，没有参数，所以都是null\n\ntestInvoke testInvoke = new testInvoke();\nMethod method1 = cls.getDeclaredMethod(\"add\", int.class, int.class);\nmethod1.setAccessible(true);\nint result = (int) method1.invoke(testInvoke, 2, 3);\nSystem.out.println(\"result = \" + result);\n\nMethod method2 = cls.getDeclaredMethod(\"testException\", null);\nmethod2.invoke(testInvoke, null);\n\n} catch (NoSuchMethodException e) {\ne.printStackTrace();\n} catch (SecurityException e) {\ne.printStackTrace();\n} catch (IllegalAccessException e) {\ne.printStackTrace();\n} catch (IllegalArgumentException e) {\ne.printStackTrace();\n} catch (InvocationTargetException e) {\n// 通过 InvocationTargetException.getCause() 获取被包装的异常\nSystem.out.println(\"testException occur some error,Error type is :\" + e.getCause().getClass().getName());\nSystem.out.println(\"Error message is :\" + e.getCause().getMessage());\ne.printStackTrace();\n}\n```\n输出：\n\n```\n我是个静态方法，我被调用啦\n我是add方法，我被调用啦\nresult = 5\n我是testException方法，我被调用啦\ntestException occur some error,Error type is :java.lang.IllegalAccessException\nError message is :You have some problem.\njava.lang.reflect.InvocationTargetException\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:498)\nat com.zcy.nidavellir.javaworld.Reflection.main.main(main.java:110)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:498)\nat com.intellij.rt.execution.application.AppMainV2.main(AppMainV2.java:131)\nCaused by: java.lang.IllegalAccessException: You have some problem.\nat com.zcy.nidavellir.javaworld.Reflection.testInvoke.testException(testInvoke.java:20)\n... 10 more\n\n\n```\n","source":"_posts/reflection.md","raw":"---\ntitle: Java反射\ndate: 2018-10-12 17:50:17\ncategories: 技术\ntag: 技术\n---\n### Java反射\n\n#### Class的获取\n* Class是一个类，不同于小写的class是关键字，不过它没有公开的构造方法，所以只能用`getClass()`方法获取相应的Class对象。\n\n```\nClass aClass = new car().getClass();\n```\n<!--more-->\n**Attention~**\n\n* 这种方法不适合基本类型如 int、float 等等，也可以用\n`.class`来获取\n\n```\nClass aClass = new car().getClass();\nClass aClass1 = car.class;\nClass aClass2 = int.class;\nClass aClass3 = String.class;\n```\n* `Class.forName(包名+类名)`例如某些类加上了@hide注解，表示这个类不会出现在SDK中，那么我们没办法获得Car，索性就直接传入它的名字好了。\n\n#### Class的名字\n1. `getName()`获取到的名字包含包名\n2. `getSimpleName()` 相较于`getName()`去掉了包名，注意，匿名内部类获取的simpleName是一个空的字符串\n3. ` getCanonicalName()`官方名字，如果没有返回null\n\n#### Class获取修饰符\nJava中对于一个类的修饰符有很多\n我们可以这样获取他们\n\n```\nSystem.out.println(Modifier.toString(testModeify.class.getModifiers()));\n```\n结果为：public abstract  \n还提供了一系列的判断方法如：\nisInterface、isAbstract、isSynchronized、isFinal等等\n```\nSystem.out.println(Modifier.isPrivate(testModeify.class.getModifiers()));\n```\n结果为false\n\n#### 获取Class成员\n##### 获取属性\n* `getDeclaredField(String name) `获取的是Class中的属性，不包含父类中的属性。\n* `getField() `获取Class中的Public属性，并且如果获取不到的话，会向其父类获取。 \n*  `public Field[] getDeclaredFields()`获取所有的属性，但不包括从父类继承下来的属性\n*  `public Field[] getFields()`获取自身的所有的 public 属性，包括从父类继承下来的。\nLook at these 注释掉的是不合法的。留下的就一目了然了。\n\n```\nClass son =  Son.class;\ntry {\nSystem.out.println(son.getDeclaredField(\"sonStrDef\"));\nSystem.out.println(son.getDeclaredField(\"sonPub\"));\nSystem.out.println(son.getDeclaredField(\"sonPro\"));\nSystem.out.println(son.getDeclaredField(\"sonPri\"));\n//            System.out.println(son.getDeclaredField(\"fatherStr\"));//error\n//            System.out.println(son.getDeclaredField(\"fatherPub\"));\n//            System.out.println(son.getDeclaredField(\"fatherPri\"));\n//            System.out.println(son.getDeclaredField(\"fatherProt\"));\n\n//            System.out.println(son.getField(\"sonStrDef\"));\nSystem.out.println(son.getField(\"sonPub\"));\n//            System.out.println(son.getField(\"sonPro\"));\n//            System.out.println(son.getField(\"sonPri\"));\n//            System.out.println(son.getField(\"fatherStr\"));\nSystem.out.println(son.getField(\"fatherPub\"));\n//            System.out.println(son.getField(\"fatherPri\"));\n//            System.out.println(son.getField(\"fatherProt\"));\n\n} catch (NoSuchFieldException e) {\ne.printStackTrace();\n}\n```\n\n##### 获取方法\n与获取属性一样\n\n* `getDeclaredMethod`\n* `getMethod `\n* `getDeclaredMethods `\n* `getMethod `\n\n##### 获取构造方法\n一样\n\n#### Field类型的获取\n* `public Type getGenericType() {}`\n* `public Class<?> getType() {} `\n\n不同的是两者**返回的类型**不一样，`getGenericType()` 方法能够获取到**泛型**类型。\n\n看一个例子：\n\n* 定义一个公开list集合\n\n```\npublic List<String> strs = new ArrayList<>();\n```\n\n* 然后通过反射获取这个属性\n\n```\nfor (Field field : son.getFields()) {\nSystem.out.println(field.getName());\nSystem.out.println(field.getType());\nSystem.out.println(field.getGenericType());\n}\n\n```\n输出为：\n\n```\nstrs\ninterface java.util.List\njava.util.List<java.lang.String>\n```\n#### Field读取与赋值\nField这个类定义了一系列的`set/get`方法来获取不同类型的值。  \n例如：  \n`public Object get(Object obj);`\n`public void set(Object obj, Object value);`   \nObject参数的作用是为了精确到到底修改的是哪一个对象\n>Class 本身不对成员进行储存，它只提供检索，所以需要用 Field、Method、Constructor 对象来承载这些成员，所以，针对成员的操作时，一般需要为成员指定类的实例引用。如果难于理解的话，可以这样理解，班级这个概念是一个类，一个班级有几十名学生，现在有A、B、C 3 个班级，将所有班级的学生抽出来集合到一个场地来考试，但是学生在试卷上写上自己名字的时候，还要指定自己的班级，这里涉及到的 Object 其实就是类似的作用，表示这个成员是具体属于哪个 Object。这个是为了精确定位。  \n\n###### 例子\n修改一个类中的Public属性值\n\n```\nClass son =  Son.class;//Class\nSon s = new Son();// Object 用于精确修改的位置\nSon s2 = new Son();// Object 用于精确修改的位置\ns.sonInt = 111;\ns2.sonInt = 222;\ntry {\nField field = son.getField(\"sonInt\");\nint a = field.getInt(s);\nint a1 = field.getInt(s2);\nSystem.out.println(\"field a = \" + a);\nSystem.out.println(\"field a1 = \" + a1);\nfield.setInt(s,1111);\nfield.setInt(s2,2222);\nSystem.out.println(\"field s.sonInt = \" + s.sonInt);\nSystem.out.println(\"field s2.sonInt = \" + s2.sonInt);\n} catch (NoSuchFieldException e) {\ne.printStackTrace();\n} catch (IllegalAccessException e) {\ne.printStackTrace();\n}\n```\n\n```\nfield a = 111\nfield a1 = 222\nfield s.sonInt = 1111\nfield s2.sonInt = 2222\n```\n可以看到，一个field可以根据Object的参数不同，获取的值也不同，同样修改的值也不同。\n\n上面是修改的Public的属性值，如果要修改private属性的话，直接用上面的方法会报错。`can not access a member`\n应该加上**`field.setAccessible(true);`**就万事大吉了。\n\n#### 获取方法参数\n* `public Parameter[] getParameters() {}`\n* Parameter.java\n* `public String getName() {}`// 获取参数名字\n* `public Class<?> getType() {}`// 获取参数类型\n* `public int getModifiers() {}`// 获取参数的修饰符\n* Method.java\n* `public Class<?>[] getParameterTypes() {}`// 获取所有的参数类型\n* `public Type[] getGenericParameterTypes() {}`// 获取所有的参数类型，包括泛型\n\n看一组例子：  \nSon.java\n\n```\npublic class Son extends Father {\n\nvoid normalMethod(String name, int num) {\n}\n\npublic void test(String[] paraa, List<String> b, HashMap<Integer, Son> maps) {\n}\n\npublic void exe() {\nSystem.out.println(\"exexexeexexeexeexeexeee\");\n}\n}\n```\n```\nClass son = Son.class;\n\nMethod[] declaredMethods = son.getDeclaredMethods();\nfor (Method method : declaredMethods) {\nSystem.out.println(method.getName());\n// 参数类型\nParameter[] parameters = method.getParameters();\nfor (Parameter parameter : parameters) {\nSystem.out.println(\"parameter name = \" + parameter.getName() + \" \" + parameter.getType().getName());\n}\n\nClass<?>[] parameterTypes = method.getParameterTypes();\nSystem.out.println(\"method para types:\");\nfor (Class<?> type : parameterTypes) {\nSystem.out.print(\" \" + type.getName());\n}\nSystem.out.println();\n\nType[] genericParameterTypes = method.getGenericParameterTypes();\nSystem.out.println(\"method para generic types:\");\nfor (Type type : genericParameterTypes) {\nSystem.out.print(\" \" + type.getTypeName());\n}\nSystem.out.println();\nSystem.out.println(\"==========================================\");\n\n}\n```\n来看一下输出，很清晰\n\n```\ntest\nparameter name = arg0 [Ljava.lang.String;\nparameter name = arg1 java.util.List\nparameter name = arg2 java.util.HashMap\nmethod para types:\n[Ljava.lang.String; java.util.List java.util.HashMap\nmethod para generic types:\njava.lang.String[] java.util.List<java.lang.String> java.util.HashMap<java.lang.Integer, com.zcy.nidavellir.javaworld.Reflection.Son>\n==========================================\nnormalMethod\nparameter name = arg0 java.lang.String\nparameter name = arg1 int\nmethod para types:\njava.lang.String int\nmethod para generic types:\njava.lang.String int\n==========================================\nexe\nmethod para types:\n\nmethod para generic types:\n\n==========================================\n```\n#### Method 获取返回值类型\n* `public Class<?> getReturnType() {}`// 获取返回值类型\n* `public Type getGenericReturnType() {}`// 获取返回值类型包括泛型\n\n#### Method 获取修饰符\n* `public int getModifiers() {}`\n\n#### Method 获取异常类型\n* `public Class<?>[] getExceptionTypes() {}`\n* `public Type[] getGenericExceptionTypes() {}`\n\n#### Method 方法的执行\n* `public Object invoke(Object obj, Object... args) {}`\n\n说明一下:\n\n* 第一个参数是反射Class对应类的一个实例。如果是静态方法，那么传`null`。后面的参数对应方法Method的参数\n* `invoke()` 返回的对象是 Object，所以实际上执行的时候要进行强制转换。\n* 在对 Method 调用 `invoke()` 的时候，如果方法本身会抛出异常，那么这个异常就会经过包装，由 Method 统一抛出 `InvocationTargetException`。而通过 `InvocationTargetException.getCause()` 可以获取真正的异常。 \n* \n例子：\n\n```\npublic class testInvoke {\npublic static void staticMethod(){\nSystem.out.println(\"我是个静态方法，我被调用啦\");\n}\n\nprivate  int add (int a,int b ) {\nreturn a + b;\n}\n\npublic void testException () throws IllegalAccessException {\nthrow new IllegalAccessException(\"You have some problem.\");\n}\n}\n\n```\n\n我们来验证一下：\n\n```\nClass cls = testInvoke.class;\ntry {\n\nMethod method = cls.getMethod(\"staticMethod\", null);// 参数类型的Class，没有参数所以null\nmethod.invoke(null, null);// 静态方法，没有参数，所以都是null\n\ntestInvoke testInvoke = new testInvoke();\nMethod method1 = cls.getDeclaredMethod(\"add\", int.class, int.class);\nmethod1.setAccessible(true);\nint result = (int) method1.invoke(testInvoke, 2, 3);\nSystem.out.println(\"result = \" + result);\n\nMethod method2 = cls.getDeclaredMethod(\"testException\", null);\nmethod2.invoke(testInvoke, null);\n\n} catch (NoSuchMethodException e) {\ne.printStackTrace();\n} catch (SecurityException e) {\ne.printStackTrace();\n} catch (IllegalAccessException e) {\ne.printStackTrace();\n} catch (IllegalArgumentException e) {\ne.printStackTrace();\n} catch (InvocationTargetException e) {\n// 通过 InvocationTargetException.getCause() 获取被包装的异常\nSystem.out.println(\"testException occur some error,Error type is :\" + e.getCause().getClass().getName());\nSystem.out.println(\"Error message is :\" + e.getCause().getMessage());\ne.printStackTrace();\n}\n```\n输出：\n\n```\n我是个静态方法，我被调用啦\n我是add方法，我被调用啦\nresult = 5\n我是testException方法，我被调用啦\ntestException occur some error,Error type is :java.lang.IllegalAccessException\nError message is :You have some problem.\njava.lang.reflect.InvocationTargetException\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:498)\nat com.zcy.nidavellir.javaworld.Reflection.main.main(main.java:110)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:498)\nat com.intellij.rt.execution.application.AppMainV2.main(AppMainV2.java:131)\nCaused by: java.lang.IllegalAccessException: You have some problem.\nat com.zcy.nidavellir.javaworld.Reflection.testInvoke.testException(testInvoke.java:20)\n... 10 more\n\n\n```\n","slug":"reflection","published":1,"updated":"2019-02-28T09:09:02.903Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf12q002k5l26mm66ei3n","content":"<h3 id=\"Java反射\"><a href=\"#Java反射\" class=\"headerlink\" title=\"Java反射\"></a>Java反射</h3><h4 id=\"Class的获取\"><a href=\"#Class的获取\" class=\"headerlink\" title=\"Class的获取\"></a>Class的获取</h4><ul>\n<li>Class是一个类，不同于小写的class是关键字，不过它没有公开的构造方法，所以只能用<code>getClass()</code>方法获取相应的Class对象。</li>\n</ul>\n<pre><code>Class aClass = new car().getClass();\n</code></pre><a id=\"more\"></a>\n<p><strong>Attention~</strong></p>\n<ul>\n<li>这种方法不适合基本类型如 int、float 等等，也可以用<br><code>.class</code>来获取</li>\n</ul>\n<pre><code>Class aClass = new car().getClass();\nClass aClass1 = car.class;\nClass aClass2 = int.class;\nClass aClass3 = String.class;\n</code></pre><ul>\n<li><code>Class.forName(包名+类名)</code>例如某些类加上了@hide注解，表示这个类不会出现在SDK中，那么我们没办法获得Car，索性就直接传入它的名字好了。</li>\n</ul>\n<h4 id=\"Class的名字\"><a href=\"#Class的名字\" class=\"headerlink\" title=\"Class的名字\"></a>Class的名字</h4><ol>\n<li><code>getName()</code>获取到的名字包含包名</li>\n<li><code>getSimpleName()</code> 相较于<code>getName()</code>去掉了包名，注意，匿名内部类获取的simpleName是一个空的字符串</li>\n<li><code>getCanonicalName()</code>官方名字，如果没有返回null</li>\n</ol>\n<h4 id=\"Class获取修饰符\"><a href=\"#Class获取修饰符\" class=\"headerlink\" title=\"Class获取修饰符\"></a>Class获取修饰符</h4><p>Java中对于一个类的修饰符有很多<br>我们可以这样获取他们</p>\n<pre><code>System.out.println(Modifier.toString(testModeify.class.getModifiers()));\n</code></pre><p>结果为：public abstract<br>还提供了一系列的判断方法如：<br>isInterface、isAbstract、isSynchronized、isFinal等等</p>\n<pre><code>System.out.println(Modifier.isPrivate(testModeify.class.getModifiers()));\n</code></pre><p>结果为false</p>\n<h4 id=\"获取Class成员\"><a href=\"#获取Class成员\" class=\"headerlink\" title=\"获取Class成员\"></a>获取Class成员</h4><h5 id=\"获取属性\"><a href=\"#获取属性\" class=\"headerlink\" title=\"获取属性\"></a>获取属性</h5><ul>\n<li><code>getDeclaredField(String name)</code>获取的是Class中的属性，不包含父类中的属性。</li>\n<li><code>getField()</code>获取Class中的Public属性，并且如果获取不到的话，会向其父类获取。 </li>\n<li><code>public Field[] getDeclaredFields()</code>获取所有的属性，但不包括从父类继承下来的属性</li>\n<li><code>public Field[] getFields()</code>获取自身的所有的 public 属性，包括从父类继承下来的。<br>Look at these 注释掉的是不合法的。留下的就一目了然了。</li>\n</ul>\n<pre><code>Class son =  Son.class;\ntry {\nSystem.out.println(son.getDeclaredField(&quot;sonStrDef&quot;));\nSystem.out.println(son.getDeclaredField(&quot;sonPub&quot;));\nSystem.out.println(son.getDeclaredField(&quot;sonPro&quot;));\nSystem.out.println(son.getDeclaredField(&quot;sonPri&quot;));\n//            System.out.println(son.getDeclaredField(&quot;fatherStr&quot;));//error\n//            System.out.println(son.getDeclaredField(&quot;fatherPub&quot;));\n//            System.out.println(son.getDeclaredField(&quot;fatherPri&quot;));\n//            System.out.println(son.getDeclaredField(&quot;fatherProt&quot;));\n\n//            System.out.println(son.getField(&quot;sonStrDef&quot;));\nSystem.out.println(son.getField(&quot;sonPub&quot;));\n//            System.out.println(son.getField(&quot;sonPro&quot;));\n//            System.out.println(son.getField(&quot;sonPri&quot;));\n//            System.out.println(son.getField(&quot;fatherStr&quot;));\nSystem.out.println(son.getField(&quot;fatherPub&quot;));\n//            System.out.println(son.getField(&quot;fatherPri&quot;));\n//            System.out.println(son.getField(&quot;fatherProt&quot;));\n\n} catch (NoSuchFieldException e) {\ne.printStackTrace();\n}\n</code></pre><h5 id=\"获取方法\"><a href=\"#获取方法\" class=\"headerlink\" title=\"获取方法\"></a>获取方法</h5><p>与获取属性一样</p>\n<ul>\n<li><code>getDeclaredMethod</code></li>\n<li><code>getMethod</code></li>\n<li><code>getDeclaredMethods</code></li>\n<li><code>getMethod</code></li>\n</ul>\n<h5 id=\"获取构造方法\"><a href=\"#获取构造方法\" class=\"headerlink\" title=\"获取构造方法\"></a>获取构造方法</h5><p>一样</p>\n<h4 id=\"Field类型的获取\"><a href=\"#Field类型的获取\" class=\"headerlink\" title=\"Field类型的获取\"></a>Field类型的获取</h4><ul>\n<li><code>public Type getGenericType() {}</code></li>\n<li><code>public Class&lt;?&gt; getType() {}</code></li>\n</ul>\n<p>不同的是两者<strong>返回的类型</strong>不一样，<code>getGenericType()</code> 方法能够获取到<strong>泛型</strong>类型。</p>\n<p>看一个例子：</p>\n<ul>\n<li>定义一个公开list集合</li>\n</ul>\n<pre><code>public List&lt;String&gt; strs = new ArrayList&lt;&gt;();\n</code></pre><ul>\n<li>然后通过反射获取这个属性</li>\n</ul>\n<pre><code>for (Field field : son.getFields()) {\nSystem.out.println(field.getName());\nSystem.out.println(field.getType());\nSystem.out.println(field.getGenericType());\n}\n\n</code></pre><p>输出为：</p>\n<pre><code>strs\ninterface java.util.List\njava.util.List&lt;java.lang.String&gt;\n</code></pre><h4 id=\"Field读取与赋值\"><a href=\"#Field读取与赋值\" class=\"headerlink\" title=\"Field读取与赋值\"></a>Field读取与赋值</h4><p>Field这个类定义了一系列的<code>set/get</code>方法来获取不同类型的值。<br>例如：<br><code>public Object get(Object obj);</code><br><code>public void set(Object obj, Object value);</code><br>Object参数的作用是为了精确到到底修改的是哪一个对象</p>\n<blockquote>\n<p>Class 本身不对成员进行储存，它只提供检索，所以需要用 Field、Method、Constructor 对象来承载这些成员，所以，针对成员的操作时，一般需要为成员指定类的实例引用。如果难于理解的话，可以这样理解，班级这个概念是一个类，一个班级有几十名学生，现在有A、B、C 3 个班级，将所有班级的学生抽出来集合到一个场地来考试，但是学生在试卷上写上自己名字的时候，还要指定自己的班级，这里涉及到的 Object 其实就是类似的作用，表示这个成员是具体属于哪个 Object。这个是为了精确定位。  </p>\n</blockquote>\n<h6 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h6><p>修改一个类中的Public属性值</p>\n<pre><code>Class son =  Son.class;//Class\nSon s = new Son();// Object 用于精确修改的位置\nSon s2 = new Son();// Object 用于精确修改的位置\ns.sonInt = 111;\ns2.sonInt = 222;\ntry {\nField field = son.getField(&quot;sonInt&quot;);\nint a = field.getInt(s);\nint a1 = field.getInt(s2);\nSystem.out.println(&quot;field a = &quot; + a);\nSystem.out.println(&quot;field a1 = &quot; + a1);\nfield.setInt(s,1111);\nfield.setInt(s2,2222);\nSystem.out.println(&quot;field s.sonInt = &quot; + s.sonInt);\nSystem.out.println(&quot;field s2.sonInt = &quot; + s2.sonInt);\n} catch (NoSuchFieldException e) {\ne.printStackTrace();\n} catch (IllegalAccessException e) {\ne.printStackTrace();\n}\n</code></pre><pre><code>field a = 111\nfield a1 = 222\nfield s.sonInt = 1111\nfield s2.sonInt = 2222\n</code></pre><p>可以看到，一个field可以根据Object的参数不同，获取的值也不同，同样修改的值也不同。</p>\n<p>上面是修改的Public的属性值，如果要修改private属性的话，直接用上面的方法会报错。<code>can not access a member</code><br>应该加上<strong><code>field.setAccessible(true);</code></strong>就万事大吉了。</p>\n<h4 id=\"获取方法参数\"><a href=\"#获取方法参数\" class=\"headerlink\" title=\"获取方法参数\"></a>获取方法参数</h4><ul>\n<li><code>public Parameter[] getParameters() {}</code></li>\n<li>Parameter.java</li>\n<li><code>public String getName() {}</code>// 获取参数名字</li>\n<li><code>public Class&lt;?&gt; getType() {}</code>// 获取参数类型</li>\n<li><code>public int getModifiers() {}</code>// 获取参数的修饰符</li>\n<li>Method.java</li>\n<li><code>public Class&lt;?&gt;[] getParameterTypes() {}</code>// 获取所有的参数类型</li>\n<li><code>public Type[] getGenericParameterTypes() {}</code>// 获取所有的参数类型，包括泛型</li>\n</ul>\n<p>看一组例子：<br>Son.java</p>\n<pre><code>public class Son extends Father {\n\nvoid normalMethod(String name, int num) {\n}\n\npublic void test(String[] paraa, List&lt;String&gt; b, HashMap&lt;Integer, Son&gt; maps) {\n}\n\npublic void exe() {\nSystem.out.println(&quot;exexexeexexeexeexeexeee&quot;);\n}\n}\n</code></pre><pre><code>Class son = Son.class;\n\nMethod[] declaredMethods = son.getDeclaredMethods();\nfor (Method method : declaredMethods) {\nSystem.out.println(method.getName());\n// 参数类型\nParameter[] parameters = method.getParameters();\nfor (Parameter parameter : parameters) {\nSystem.out.println(&quot;parameter name = &quot; + parameter.getName() + &quot; &quot; + parameter.getType().getName());\n}\n\nClass&lt;?&gt;[] parameterTypes = method.getParameterTypes();\nSystem.out.println(&quot;method para types:&quot;);\nfor (Class&lt;?&gt; type : parameterTypes) {\nSystem.out.print(&quot; &quot; + type.getName());\n}\nSystem.out.println();\n\nType[] genericParameterTypes = method.getGenericParameterTypes();\nSystem.out.println(&quot;method para generic types:&quot;);\nfor (Type type : genericParameterTypes) {\nSystem.out.print(&quot; &quot; + type.getTypeName());\n}\nSystem.out.println();\nSystem.out.println(&quot;==========================================&quot;);\n\n}\n</code></pre><p>来看一下输出，很清晰</p>\n<pre><code>test\nparameter name = arg0 [Ljava.lang.String;\nparameter name = arg1 java.util.List\nparameter name = arg2 java.util.HashMap\nmethod para types:\n[Ljava.lang.String; java.util.List java.util.HashMap\nmethod para generic types:\njava.lang.String[] java.util.List&lt;java.lang.String&gt; java.util.HashMap&lt;java.lang.Integer, com.zcy.nidavellir.javaworld.Reflection.Son&gt;\n==========================================\nnormalMethod\nparameter name = arg0 java.lang.String\nparameter name = arg1 int\nmethod para types:\njava.lang.String int\nmethod para generic types:\njava.lang.String int\n==========================================\nexe\nmethod para types:\n\nmethod para generic types:\n\n==========================================\n</code></pre><h4 id=\"Method-获取返回值类型\"><a href=\"#Method-获取返回值类型\" class=\"headerlink\" title=\"Method 获取返回值类型\"></a>Method 获取返回值类型</h4><ul>\n<li><code>public Class&lt;?&gt; getReturnType() {}</code>// 获取返回值类型</li>\n<li><code>public Type getGenericReturnType() {}</code>// 获取返回值类型包括泛型</li>\n</ul>\n<h4 id=\"Method-获取修饰符\"><a href=\"#Method-获取修饰符\" class=\"headerlink\" title=\"Method 获取修饰符\"></a>Method 获取修饰符</h4><ul>\n<li><code>public int getModifiers() {}</code></li>\n</ul>\n<h4 id=\"Method-获取异常类型\"><a href=\"#Method-获取异常类型\" class=\"headerlink\" title=\"Method 获取异常类型\"></a>Method 获取异常类型</h4><ul>\n<li><code>public Class&lt;?&gt;[] getExceptionTypes() {}</code></li>\n<li><code>public Type[] getGenericExceptionTypes() {}</code></li>\n</ul>\n<h4 id=\"Method-方法的执行\"><a href=\"#Method-方法的执行\" class=\"headerlink\" title=\"Method 方法的执行\"></a>Method 方法的执行</h4><ul>\n<li><code>public Object invoke(Object obj, Object... args) {}</code></li>\n</ul>\n<p>说明一下:</p>\n<ul>\n<li>第一个参数是反射Class对应类的一个实例。如果是静态方法，那么传<code>null</code>。后面的参数对应方法Method的参数</li>\n<li><code>invoke()</code> 返回的对象是 Object，所以实际上执行的时候要进行强制转换。</li>\n<li>在对 Method 调用 <code>invoke()</code> 的时候，如果方法本身会抛出异常，那么这个异常就会经过包装，由 Method 统一抛出 <code>InvocationTargetException</code>。而通过 <code>InvocationTargetException.getCause()</code> 可以获取真正的异常。 </li>\n<li>例子：</li>\n</ul>\n<pre><code>public class testInvoke {\npublic static void staticMethod(){\nSystem.out.println(&quot;我是个静态方法，我被调用啦&quot;);\n}\n\nprivate  int add (int a,int b ) {\nreturn a + b;\n}\n\npublic void testException () throws IllegalAccessException {\nthrow new IllegalAccessException(&quot;You have some problem.&quot;);\n}\n}\n\n</code></pre><p>我们来验证一下：</p>\n<pre><code>Class cls = testInvoke.class;\ntry {\n\nMethod method = cls.getMethod(&quot;staticMethod&quot;, null);// 参数类型的Class，没有参数所以null\nmethod.invoke(null, null);// 静态方法，没有参数，所以都是null\n\ntestInvoke testInvoke = new testInvoke();\nMethod method1 = cls.getDeclaredMethod(&quot;add&quot;, int.class, int.class);\nmethod1.setAccessible(true);\nint result = (int) method1.invoke(testInvoke, 2, 3);\nSystem.out.println(&quot;result = &quot; + result);\n\nMethod method2 = cls.getDeclaredMethod(&quot;testException&quot;, null);\nmethod2.invoke(testInvoke, null);\n\n} catch (NoSuchMethodException e) {\ne.printStackTrace();\n} catch (SecurityException e) {\ne.printStackTrace();\n} catch (IllegalAccessException e) {\ne.printStackTrace();\n} catch (IllegalArgumentException e) {\ne.printStackTrace();\n} catch (InvocationTargetException e) {\n// 通过 InvocationTargetException.getCause() 获取被包装的异常\nSystem.out.println(&quot;testException occur some error,Error type is :&quot; + e.getCause().getClass().getName());\nSystem.out.println(&quot;Error message is :&quot; + e.getCause().getMessage());\ne.printStackTrace();\n}\n</code></pre><p>输出：</p>\n<pre><code>我是个静态方法，我被调用啦\n我是add方法，我被调用啦\nresult = 5\n我是testException方法，我被调用啦\ntestException occur some error,Error type is :java.lang.IllegalAccessException\nError message is :You have some problem.\njava.lang.reflect.InvocationTargetException\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:498)\nat com.zcy.nidavellir.javaworld.Reflection.main.main(main.java:110)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:498)\nat com.intellij.rt.execution.application.AppMainV2.main(AppMainV2.java:131)\nCaused by: java.lang.IllegalAccessException: You have some problem.\nat com.zcy.nidavellir.javaworld.Reflection.testInvoke.testException(testInvoke.java:20)\n... 10 more\n\n\n</code></pre>","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"<h3 id=\"Java反射\"><a href=\"#Java反射\" class=\"headerlink\" title=\"Java反射\"></a>Java反射</h3><h4 id=\"Class的获取\"><a href=\"#Class的获取\" class=\"headerlink\" title=\"Class的获取\"></a>Class的获取</h4><ul>\n<li>Class是一个类，不同于小写的class是关键字，不过它没有公开的构造方法，所以只能用<code>getClass()</code>方法获取相应的Class对象。</li>\n</ul>\n<pre><code>Class aClass = new car().getClass();\n</code></pre>","more":"<p><strong>Attention~</strong></p>\n<ul>\n<li>这种方法不适合基本类型如 int、float 等等，也可以用<br><code>.class</code>来获取</li>\n</ul>\n<pre><code>Class aClass = new car().getClass();\nClass aClass1 = car.class;\nClass aClass2 = int.class;\nClass aClass3 = String.class;\n</code></pre><ul>\n<li><code>Class.forName(包名+类名)</code>例如某些类加上了@hide注解，表示这个类不会出现在SDK中，那么我们没办法获得Car，索性就直接传入它的名字好了。</li>\n</ul>\n<h4 id=\"Class的名字\"><a href=\"#Class的名字\" class=\"headerlink\" title=\"Class的名字\"></a>Class的名字</h4><ol>\n<li><code>getName()</code>获取到的名字包含包名</li>\n<li><code>getSimpleName()</code> 相较于<code>getName()</code>去掉了包名，注意，匿名内部类获取的simpleName是一个空的字符串</li>\n<li><code>getCanonicalName()</code>官方名字，如果没有返回null</li>\n</ol>\n<h4 id=\"Class获取修饰符\"><a href=\"#Class获取修饰符\" class=\"headerlink\" title=\"Class获取修饰符\"></a>Class获取修饰符</h4><p>Java中对于一个类的修饰符有很多<br>我们可以这样获取他们</p>\n<pre><code>System.out.println(Modifier.toString(testModeify.class.getModifiers()));\n</code></pre><p>结果为：public abstract<br>还提供了一系列的判断方法如：<br>isInterface、isAbstract、isSynchronized、isFinal等等</p>\n<pre><code>System.out.println(Modifier.isPrivate(testModeify.class.getModifiers()));\n</code></pre><p>结果为false</p>\n<h4 id=\"获取Class成员\"><a href=\"#获取Class成员\" class=\"headerlink\" title=\"获取Class成员\"></a>获取Class成员</h4><h5 id=\"获取属性\"><a href=\"#获取属性\" class=\"headerlink\" title=\"获取属性\"></a>获取属性</h5><ul>\n<li><code>getDeclaredField(String name)</code>获取的是Class中的属性，不包含父类中的属性。</li>\n<li><code>getField()</code>获取Class中的Public属性，并且如果获取不到的话，会向其父类获取。 </li>\n<li><code>public Field[] getDeclaredFields()</code>获取所有的属性，但不包括从父类继承下来的属性</li>\n<li><code>public Field[] getFields()</code>获取自身的所有的 public 属性，包括从父类继承下来的。<br>Look at these 注释掉的是不合法的。留下的就一目了然了。</li>\n</ul>\n<pre><code>Class son =  Son.class;\ntry {\nSystem.out.println(son.getDeclaredField(&quot;sonStrDef&quot;));\nSystem.out.println(son.getDeclaredField(&quot;sonPub&quot;));\nSystem.out.println(son.getDeclaredField(&quot;sonPro&quot;));\nSystem.out.println(son.getDeclaredField(&quot;sonPri&quot;));\n//            System.out.println(son.getDeclaredField(&quot;fatherStr&quot;));//error\n//            System.out.println(son.getDeclaredField(&quot;fatherPub&quot;));\n//            System.out.println(son.getDeclaredField(&quot;fatherPri&quot;));\n//            System.out.println(son.getDeclaredField(&quot;fatherProt&quot;));\n\n//            System.out.println(son.getField(&quot;sonStrDef&quot;));\nSystem.out.println(son.getField(&quot;sonPub&quot;));\n//            System.out.println(son.getField(&quot;sonPro&quot;));\n//            System.out.println(son.getField(&quot;sonPri&quot;));\n//            System.out.println(son.getField(&quot;fatherStr&quot;));\nSystem.out.println(son.getField(&quot;fatherPub&quot;));\n//            System.out.println(son.getField(&quot;fatherPri&quot;));\n//            System.out.println(son.getField(&quot;fatherProt&quot;));\n\n} catch (NoSuchFieldException e) {\ne.printStackTrace();\n}\n</code></pre><h5 id=\"获取方法\"><a href=\"#获取方法\" class=\"headerlink\" title=\"获取方法\"></a>获取方法</h5><p>与获取属性一样</p>\n<ul>\n<li><code>getDeclaredMethod</code></li>\n<li><code>getMethod</code></li>\n<li><code>getDeclaredMethods</code></li>\n<li><code>getMethod</code></li>\n</ul>\n<h5 id=\"获取构造方法\"><a href=\"#获取构造方法\" class=\"headerlink\" title=\"获取构造方法\"></a>获取构造方法</h5><p>一样</p>\n<h4 id=\"Field类型的获取\"><a href=\"#Field类型的获取\" class=\"headerlink\" title=\"Field类型的获取\"></a>Field类型的获取</h4><ul>\n<li><code>public Type getGenericType() {}</code></li>\n<li><code>public Class&lt;?&gt; getType() {}</code></li>\n</ul>\n<p>不同的是两者<strong>返回的类型</strong>不一样，<code>getGenericType()</code> 方法能够获取到<strong>泛型</strong>类型。</p>\n<p>看一个例子：</p>\n<ul>\n<li>定义一个公开list集合</li>\n</ul>\n<pre><code>public List&lt;String&gt; strs = new ArrayList&lt;&gt;();\n</code></pre><ul>\n<li>然后通过反射获取这个属性</li>\n</ul>\n<pre><code>for (Field field : son.getFields()) {\nSystem.out.println(field.getName());\nSystem.out.println(field.getType());\nSystem.out.println(field.getGenericType());\n}\n\n</code></pre><p>输出为：</p>\n<pre><code>strs\ninterface java.util.List\njava.util.List&lt;java.lang.String&gt;\n</code></pre><h4 id=\"Field读取与赋值\"><a href=\"#Field读取与赋值\" class=\"headerlink\" title=\"Field读取与赋值\"></a>Field读取与赋值</h4><p>Field这个类定义了一系列的<code>set/get</code>方法来获取不同类型的值。<br>例如：<br><code>public Object get(Object obj);</code><br><code>public void set(Object obj, Object value);</code><br>Object参数的作用是为了精确到到底修改的是哪一个对象</p>\n<blockquote>\n<p>Class 本身不对成员进行储存，它只提供检索，所以需要用 Field、Method、Constructor 对象来承载这些成员，所以，针对成员的操作时，一般需要为成员指定类的实例引用。如果难于理解的话，可以这样理解，班级这个概念是一个类，一个班级有几十名学生，现在有A、B、C 3 个班级，将所有班级的学生抽出来集合到一个场地来考试，但是学生在试卷上写上自己名字的时候，还要指定自己的班级，这里涉及到的 Object 其实就是类似的作用，表示这个成员是具体属于哪个 Object。这个是为了精确定位。  </p>\n</blockquote>\n<h6 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h6><p>修改一个类中的Public属性值</p>\n<pre><code>Class son =  Son.class;//Class\nSon s = new Son();// Object 用于精确修改的位置\nSon s2 = new Son();// Object 用于精确修改的位置\ns.sonInt = 111;\ns2.sonInt = 222;\ntry {\nField field = son.getField(&quot;sonInt&quot;);\nint a = field.getInt(s);\nint a1 = field.getInt(s2);\nSystem.out.println(&quot;field a = &quot; + a);\nSystem.out.println(&quot;field a1 = &quot; + a1);\nfield.setInt(s,1111);\nfield.setInt(s2,2222);\nSystem.out.println(&quot;field s.sonInt = &quot; + s.sonInt);\nSystem.out.println(&quot;field s2.sonInt = &quot; + s2.sonInt);\n} catch (NoSuchFieldException e) {\ne.printStackTrace();\n} catch (IllegalAccessException e) {\ne.printStackTrace();\n}\n</code></pre><pre><code>field a = 111\nfield a1 = 222\nfield s.sonInt = 1111\nfield s2.sonInt = 2222\n</code></pre><p>可以看到，一个field可以根据Object的参数不同，获取的值也不同，同样修改的值也不同。</p>\n<p>上面是修改的Public的属性值，如果要修改private属性的话，直接用上面的方法会报错。<code>can not access a member</code><br>应该加上<strong><code>field.setAccessible(true);</code></strong>就万事大吉了。</p>\n<h4 id=\"获取方法参数\"><a href=\"#获取方法参数\" class=\"headerlink\" title=\"获取方法参数\"></a>获取方法参数</h4><ul>\n<li><code>public Parameter[] getParameters() {}</code></li>\n<li>Parameter.java</li>\n<li><code>public String getName() {}</code>// 获取参数名字</li>\n<li><code>public Class&lt;?&gt; getType() {}</code>// 获取参数类型</li>\n<li><code>public int getModifiers() {}</code>// 获取参数的修饰符</li>\n<li>Method.java</li>\n<li><code>public Class&lt;?&gt;[] getParameterTypes() {}</code>// 获取所有的参数类型</li>\n<li><code>public Type[] getGenericParameterTypes() {}</code>// 获取所有的参数类型，包括泛型</li>\n</ul>\n<p>看一组例子：<br>Son.java</p>\n<pre><code>public class Son extends Father {\n\nvoid normalMethod(String name, int num) {\n}\n\npublic void test(String[] paraa, List&lt;String&gt; b, HashMap&lt;Integer, Son&gt; maps) {\n}\n\npublic void exe() {\nSystem.out.println(&quot;exexexeexexeexeexeexeee&quot;);\n}\n}\n</code></pre><pre><code>Class son = Son.class;\n\nMethod[] declaredMethods = son.getDeclaredMethods();\nfor (Method method : declaredMethods) {\nSystem.out.println(method.getName());\n// 参数类型\nParameter[] parameters = method.getParameters();\nfor (Parameter parameter : parameters) {\nSystem.out.println(&quot;parameter name = &quot; + parameter.getName() + &quot; &quot; + parameter.getType().getName());\n}\n\nClass&lt;?&gt;[] parameterTypes = method.getParameterTypes();\nSystem.out.println(&quot;method para types:&quot;);\nfor (Class&lt;?&gt; type : parameterTypes) {\nSystem.out.print(&quot; &quot; + type.getName());\n}\nSystem.out.println();\n\nType[] genericParameterTypes = method.getGenericParameterTypes();\nSystem.out.println(&quot;method para generic types:&quot;);\nfor (Type type : genericParameterTypes) {\nSystem.out.print(&quot; &quot; + type.getTypeName());\n}\nSystem.out.println();\nSystem.out.println(&quot;==========================================&quot;);\n\n}\n</code></pre><p>来看一下输出，很清晰</p>\n<pre><code>test\nparameter name = arg0 [Ljava.lang.String;\nparameter name = arg1 java.util.List\nparameter name = arg2 java.util.HashMap\nmethod para types:\n[Ljava.lang.String; java.util.List java.util.HashMap\nmethod para generic types:\njava.lang.String[] java.util.List&lt;java.lang.String&gt; java.util.HashMap&lt;java.lang.Integer, com.zcy.nidavellir.javaworld.Reflection.Son&gt;\n==========================================\nnormalMethod\nparameter name = arg0 java.lang.String\nparameter name = arg1 int\nmethod para types:\njava.lang.String int\nmethod para generic types:\njava.lang.String int\n==========================================\nexe\nmethod para types:\n\nmethod para generic types:\n\n==========================================\n</code></pre><h4 id=\"Method-获取返回值类型\"><a href=\"#Method-获取返回值类型\" class=\"headerlink\" title=\"Method 获取返回值类型\"></a>Method 获取返回值类型</h4><ul>\n<li><code>public Class&lt;?&gt; getReturnType() {}</code>// 获取返回值类型</li>\n<li><code>public Type getGenericReturnType() {}</code>// 获取返回值类型包括泛型</li>\n</ul>\n<h4 id=\"Method-获取修饰符\"><a href=\"#Method-获取修饰符\" class=\"headerlink\" title=\"Method 获取修饰符\"></a>Method 获取修饰符</h4><ul>\n<li><code>public int getModifiers() {}</code></li>\n</ul>\n<h4 id=\"Method-获取异常类型\"><a href=\"#Method-获取异常类型\" class=\"headerlink\" title=\"Method 获取异常类型\"></a>Method 获取异常类型</h4><ul>\n<li><code>public Class&lt;?&gt;[] getExceptionTypes() {}</code></li>\n<li><code>public Type[] getGenericExceptionTypes() {}</code></li>\n</ul>\n<h4 id=\"Method-方法的执行\"><a href=\"#Method-方法的执行\" class=\"headerlink\" title=\"Method 方法的执行\"></a>Method 方法的执行</h4><ul>\n<li><code>public Object invoke(Object obj, Object... args) {}</code></li>\n</ul>\n<p>说明一下:</p>\n<ul>\n<li>第一个参数是反射Class对应类的一个实例。如果是静态方法，那么传<code>null</code>。后面的参数对应方法Method的参数</li>\n<li><code>invoke()</code> 返回的对象是 Object，所以实际上执行的时候要进行强制转换。</li>\n<li>在对 Method 调用 <code>invoke()</code> 的时候，如果方法本身会抛出异常，那么这个异常就会经过包装，由 Method 统一抛出 <code>InvocationTargetException</code>。而通过 <code>InvocationTargetException.getCause()</code> 可以获取真正的异常。 </li>\n<li>例子：</li>\n</ul>\n<pre><code>public class testInvoke {\npublic static void staticMethod(){\nSystem.out.println(&quot;我是个静态方法，我被调用啦&quot;);\n}\n\nprivate  int add (int a,int b ) {\nreturn a + b;\n}\n\npublic void testException () throws IllegalAccessException {\nthrow new IllegalAccessException(&quot;You have some problem.&quot;);\n}\n}\n\n</code></pre><p>我们来验证一下：</p>\n<pre><code>Class cls = testInvoke.class;\ntry {\n\nMethod method = cls.getMethod(&quot;staticMethod&quot;, null);// 参数类型的Class，没有参数所以null\nmethod.invoke(null, null);// 静态方法，没有参数，所以都是null\n\ntestInvoke testInvoke = new testInvoke();\nMethod method1 = cls.getDeclaredMethod(&quot;add&quot;, int.class, int.class);\nmethod1.setAccessible(true);\nint result = (int) method1.invoke(testInvoke, 2, 3);\nSystem.out.println(&quot;result = &quot; + result);\n\nMethod method2 = cls.getDeclaredMethod(&quot;testException&quot;, null);\nmethod2.invoke(testInvoke, null);\n\n} catch (NoSuchMethodException e) {\ne.printStackTrace();\n} catch (SecurityException e) {\ne.printStackTrace();\n} catch (IllegalAccessException e) {\ne.printStackTrace();\n} catch (IllegalArgumentException e) {\ne.printStackTrace();\n} catch (InvocationTargetException e) {\n// 通过 InvocationTargetException.getCause() 获取被包装的异常\nSystem.out.println(&quot;testException occur some error,Error type is :&quot; + e.getCause().getClass().getName());\nSystem.out.println(&quot;Error message is :&quot; + e.getCause().getMessage());\ne.printStackTrace();\n}\n</code></pre><p>输出：</p>\n<pre><code>我是个静态方法，我被调用啦\n我是add方法，我被调用啦\nresult = 5\n我是testException方法，我被调用啦\ntestException occur some error,Error type is :java.lang.IllegalAccessException\nError message is :You have some problem.\njava.lang.reflect.InvocationTargetException\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:498)\nat com.zcy.nidavellir.javaworld.Reflection.main.main(main.java:110)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:498)\nat com.intellij.rt.execution.application.AppMainV2.main(AppMainV2.java:131)\nCaused by: java.lang.IllegalAccessException: You have some problem.\nat com.zcy.nidavellir.javaworld.Reflection.testInvoke.testException(testInvoke.java:20)\n... 10 more\n\n\n</code></pre>"},{"title":"Eventbus浅析","date":"2018-10-25T07:53:05.000Z","_content":"\n### 注册EventBus\n`EventBus.getDefault().register(this);`  \n\n我们来看看**`getDefault()`**中有什么\n\n```\n/** Convenience singleton for apps using a process-wide EventBus instance. */\npublic static EventBus getDefault() {\n    EventBus instance = defaultInstance;\n    if (instance == null) {\n        synchronized (EventBus.class) {\n            instance = EventBus.defaultInstance;\n            if (instance == null) {\n                instance = EventBus.defaultInstance = new EventBus();\n            }\n        }\n    }\n    return instance;\n}\n\n```\n很明显是一个**`DoubleCheck`**单例模式，具体的EventBus构造方法没贴，后面会介绍他其中的一些属性。\n  \n<!--more-->\n获取完了对象紧接着对当前activity或fragment进行了注册**register**\n\n```\npublic void register(Object subscriber) {\n    Class<?> subscriberClass = subscriber.getClass();\n    List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);\n    synchronized (this) {\n        for (SubscriberMethod subscriberMethod : subscriberMethods) {\n            subscribe(subscriber, subscriberMethod);\n        }\n    }\n}\n\n```\n\n我们可以看到，传入的`this`可以是Activity，进而得到了其class，通过**`findSubscriberMethods`**找到所有在这个class下的**Subscriber**们存放在一个List集合中，然后**逐个进行事件订阅**。\n\n关键方法 **findSubscriberMethods** \n\nsubscriberClass = 订阅类的class \n\n```\nList<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {\n    List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);\n    if (subscriberMethods != null) {\n        return subscriberMethods;\n    }\n\t //是否忽略注解器生成的MyEventBusIndex类 默认false\n    if (ignoreGeneratedIndex) {\n        subscriberMethods = findUsingReflection(subscriberClass);\n    } else {\n        subscriberMethods = findUsingInfo(subscriberClass);\n    }\n    if (subscriberMethods.isEmpty()) {\n        throw new EventBusException(\"Subscriber \" + subscriberClass\n                + \" and its super classes have no public methods with the @Subscribe annotation\");\n    } else {\n        METHOD_CACHE.put(subscriberClass, subscriberMethods);\n        return subscriberMethods;\n    }\n}\n```\n其中第一行的`METHOD_CACHE`作为缓存Map，以订阅类的class为key，订阅的方法集合作为value。\n`private static final Map<Class<?>, List<SubscriberMethod>> METHOD_CACHE = new ConcurrentHashMap<>();` \n\n如果没有缓存的时候，会判断是否**忽略生成index**，默认是false，那么我们来看一下`findUsingInfo(subscriberClass);`这个真正去查找该class下订阅方法的方法。\n\n先看一下FindState是什么东西。他里面存储了一些订阅者和订阅方法信息\n\n```\nstatic class FindState {\n\t//订阅方法集合，\n    final List<SubscriberMethod> subscriberMethods = new ArrayList<>();\n    //以event为key，以method为value\n    final Map<Class, Object> anyMethodByEventType = new HashMap<>();\n    //以method的名字生成一个methodKey为key，该method的类(订阅者)为value\n    final Map<String, Class> subscriberClassByMethodKey = new HashMap<>();\n    final StringBuilder methodKeyBuilder = new StringBuilder(128);\n\n    Class<?> subscriberClass;\n    Class<?> clazz;\n    boolean skipSuperClasses;\n    SubscriberInfo subscriberInfo;\n\n```\n这个方法返回的是我们最终需要的`List<SubscriberMethod>`\n\n```\nprivate List<SubscriberMethod> findUsingInfo(Class<?> subscriberClass) {\n    FindState findState = prepareFindState();\n    // 利用findState辅助来获取订阅方法\n    findState.initForSubscriber(subscriberClass);\n    while (findState.clazz != null) {\n        // 获取class对应的subscriberInfo\n        findState.subscriberInfo = getSubscriberInfo(findState);\n        if (findState.subscriberInfo != null) {\n            // 获取订阅方法数组\n            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();\n            for (SubscriberMethod subscriberMethod : array) {\n                if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {\n                    findState.subscriberMethods.add(subscriberMethod);\n                }\n            }\n        } else {\n            // subscriberInfo为null 则通过反射获取\n            findUsingReflectionInSingleClass(findState);\n        }\n        //接着获取父类的订阅方法\n        findState.moveToSuperclass();\n    }\n    return getMethodsAndRelease(findState);\n}\n```\n\n\n### 方法订阅（注册方法）\n\n其实上面这些就是为了获取到当前class 的所有订阅方法。然后遍历这些个订阅方法来完成订阅。接下来看一下**逐个订阅**  \n\n```\nfor (SubscriberMethod subscriberMethod : subscriberMethods) {\n    subscribe(subscriber, subscriberMethod);\n}\n```\n首先**映入眼帘**的是两个参数，一个**订阅Class**一个是订阅类中的要**订阅的方法**。\n\n上面把要订阅的方法封装成了`SubscriberMethod `。并且这个有一个事件类型（订阅方法的参数）`eventType`需要使用\n\n```\npublic class SubscriberMethod {\n    final Method method;\n    final ThreadMode threadMode;\n    final Class<?> eventType;\n    final int priority;\n    final boolean sticky;\n    /** Used for efficient comparison */\n    String methodString;\n\n```\n看订阅方法\n\n```\n// Must be called in synchronized block\nprivate void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {\n    \n\t//订阅方法的参数类型，也是事件类型\n\tClass<?> eventType = subscriberMethod.eventType;\n    // 封装订阅者和订阅方法\n    Subscription newSubscription = new Subscription(subscriber, subscriberMethod);\n    // 根据事件类型key，获取subscriptions （Map<Class<?>, CopyOnWriteArrayList<Subscription>>） \n    CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);\n    // 如果subscriptions集合为空，说明该事件类型没有注册，则创建一个新的集合。并把事件类型`eventType`作为key 和订阅方法集合作为value加入其中\n    if (subscriptions == null) {\n        subscriptions = new CopyOnWriteArrayList<>();\n        subscriptionsByEventType.put(eventType, subscriptions);\n    } else {\n        if (subscriptions.contains(newSubscription)) {\n            throw new EventBusException(\"Subscriber \" + subscriber.getClass() + \" already registered to event \"\n                    + eventType);\n        }\n    }\n\n    int size = subscriptions.size();\n    // 按照subscriberMethod的优先级插入newSubscription到正确的位置\n    for (int i = 0; i <= size; i++) {\n        // 最后一个直接插入，或者是要插入的method优先级大于 i 位置 的优先级\n        if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {\n            subscriptions.add(i, newSubscription);\n            break;\n        }\n    }\n\n    // 存放订阅Method的事件类型\n    List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);\n    if (subscribedEvents == null) {\n        subscribedEvents = new ArrayList<>();\n        typesBySubscriber.put(subscriber, subscribedEvents);\n    }\n    subscribedEvents.add(eventType);\n\n    // 黏性事件\n    if (subscriberMethod.sticky) {\n        if (eventInheritance) {\n            // Existing sticky events of all subclasses of eventType have to be considered.\n            // Note: Iterating over all events may be inefficient with lots of sticky events,\n            // thus data structure should be changed to allow a more efficient lookup\n            // (e.g. an additional map storing sub classes of super classes: Class -> List<Class>).\n            Set<Map.Entry<Class<?>, Object>> entries = stickyEvents.entrySet();\n            for (Map.Entry<Class<?>, Object> entry : entries) {\n                Class<?> candidateEventType = entry.getKey();\n                if (eventType.isAssignableFrom(candidateEventType)) {\n                    Object stickyEvent = entry.getValue();\n                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);\n                }\n            }\n        } else {\n            Object stickyEvent = stickyEvents.get(eventType);\n            checkPostStickyEventToSubscription(newSubscription, stickyEvent);\n        }\n    }\n}\n```\n**方法说明**\n>\n* 首先获取了方法参数类型 ： `eventType`\n* 根据事件类型`eventType`，获取其所有订阅方法 ：`subscriptionsByEventType.get(eventType);`\n* subscriptions如果已经被初始化了，那么按照优先级将新的method插入其中，如果没有初始化，那么就`new CopyOnWriteArrayList<>();`\n* 获取订阅者所有的订阅事件类型 ： `typesBySubscriber.get(subscriber);`\n* 如果初始化了，那么就直接添加这个`eventType `到对应的集合中，如果没有那么初始化并将**`Subscriber`（还记得参数传入的就是这个吗）**作为key，**`eventType `集合**作为value\n\n\n**不太明白没关系，我们再接着往下看。。。**\n\n### 事件发布\n`EventBus.getDefault().post(new UpdateUIEvent());`\n\npost：\n\n```\n/** Posts the given event to the event bus. */\npublic void post(Object event) {\n    PostingThreadState postingState = currentPostingThreadState.get();\n    List<Object> eventQueue = postingState.eventQueue;\n    // 将事件添加进当前线程的事件队列\n    eventQueue.add(event);\n\t // 判断当前线程是否正在发布事件\n    if (!postingState.isPosting) {\n        postingState.isMainThread = isMainThread();\n        postingState.isPosting = true;\n        if (postingState.canceled) {\n            throw new EventBusException(\"Internal error. Abort state was not reset\");\n        }\n        try {\n            while (!eventQueue.isEmpty()) {\n                postSingleEvent(eventQueue.remove(0), postingState);\n            }\n        } finally {\n            postingState.isPosting = false;\n            postingState.isMainThread = false;\n        }\n    }\n}\n\n```\n\n首先`currentPostingThreadState`是一个`ThreadLocal<PostingThreadState>`\n\nThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，而这段数据是不会与其他线程共享的。可以看出currentPostingThreadState的实现是一个包含了PostingThreadState的ThreadLocal对象,这样可以保证取到的都是自己线程对应的数据。\n\n```\n/** For ThreadLocal, much faster to set (and get multiple values). */\nfinal static class PostingThreadState {\n    final List<Object> eventQueue = new ArrayList<>();//当前线程的事件队列\n    boolean isPosting; //是否有事件正在分发\n    boolean isMainThread;//post的线程是否是主线程\n    Subscription subscription;\n    Object event;\n    boolean canceled;\n}\n```\nPostingThreadState中包含了当前线程的事件队列，就是当前线程所有分发的事件都保存在eventQueue事件队列中以及订阅者订阅事件等信息，有了这些信息我们就可以从事件队列中取出事件分发给对应的订阅者。\n\n\n我们看到了把当前的事件加入到了事件队列尾部，如果事件队列不为empty，那么就一直发送里面的事件直到为empty。我们看一下关键代码`postSingleEvent(eventQueue.remove(0), postingState);`  \n\n```\nprivate void postSingleEvent(Object event, PostingThreadState postingState) throws Error {\n    Class<?> eventClass = event.getClass();\n    boolean subscriptionFound = false;\n    if (eventInheritance) {\n        List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);\n        int countTypes = eventTypes.size();\n        for (int h = 0; h < countTypes; h++) {\n            Class<?> clazz = eventTypes.get(h);\n            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);\n        }\n    } else {\n        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);\n    }\n    if (!subscriptionFound) {\n        if (logNoSubscriberMessages) {\n            logger.log(Level.FINE, \"No subscribers registered for event \" + eventClass);\n        }\n        if (sendNoSubscriberEvent && eventClass != NoSubscriberEvent.class &&\n                eventClass != SubscriberExceptionEvent.class) {\n            post(new NoSubscriberEvent(this, event));\n        }\n    }\n}\n```\n首先判断的是`eventInheritance `是否开启了继承，由于EventBus创建的是默认的Builder，所以默认值为初始值true。那么会找到它所有的父类，然后依次发送事件。关键在于方法**`postSingleEventForEventType(event, postingState, eventClass);`**  \n\n```\nprivate boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {\n    CopyOnWriteArrayList<Subscription> subscriptions;\n    synchronized (this) {\n        // 根据事件类型找出相关的订阅信息\n        subscriptions = subscriptionsByEventType.get(eventClass);\n    }\n    if (subscriptions != null && !subscriptions.isEmpty()) {\n        for (Subscription subscription : subscriptions) {\n            postingState.event = event;\n            postingState.subscription = subscription;\n            boolean aborted = false;\n            try {\n                // 发布到具体的订阅者\n                postToSubscription(subscription, event, postingState.isMainThread);\n                aborted = postingState.canceled;\n            } finally {\n                postingState.event = null;\n                postingState.subscription = null;\n                postingState.canceled = false;\n            }\n            if (aborted) {\n                break;\n            }\n        }\n        return true;\n    }\n    return false;\n}\n```\n\n我们可以看到，如果根据事件类型找不到订阅方法，或者订阅方法为空，那么会返回false，上面抛出异常`No subscribers registered for event`。那如果找到了订阅的方法呢。\n\n```\nprivate void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {\n    switch (subscription.subscriberMethod.threadMode) {\n        // 订阅线程跟随发布线程\n        case POSTING:\n            // 订阅线程和发布线程相同，直接订阅\n            invokeSubscriber(subscription, event);\n            break;\n        // 订阅线程为主线程\n        case MAIN:\n            // 发布线程和订阅线程都是主线程，直接订阅\n            if (isMainThread) {\n                invokeSubscriber(subscription, event);\n            }\n            // 发布线程不是主线程，订阅线程切换到主线程订阅\n            else {\n                mainThreadPoster.enqueue(subscription, event);\n            }\n            break;\n        case MAIN_ORDERED:\n            if (mainThreadPoster != null) {\n                mainThreadPoster.enqueue(subscription, event);\n            }\n            else {\n                // temporary: technically not correct as poster not decoupled from subscriber\n                invokeSubscriber(subscription, event);\n            }\n            break;\n        // 订阅线程为后台线程\n        case BACKGROUND:\n            // 发布线程为主线程，切换到后台线程订阅\n            if (isMainThread) {\n                backgroundPoster.enqueue(subscription, event);\n            }\n            // 发布线程不为主线程，直接订阅\n            else {\n                invokeSubscriber(subscription, event);\n            }\n            break;\n        // 订阅线程为异步线程\n        case ASYNC:\n            // 使用线程池线程订阅\n            asyncPoster.enqueue(subscription, event);\n            break;\n        default:\n            throw new IllegalStateException(\"Unknown thread mode: \" + subscription.subscriberMethod.threadMode);\n    }\n}\n```\n* POSTING：事件发布在什么线程，就在什么线程订阅。\n* MAIN：无论事件在什么线程发布，都在主线程订阅。\n* BACKGROUND：如果发布的线程不是主线程，则在该线程订阅，如果是主线程，则使用一个单独的后台线程订阅。\n* ASYNC：在非主线程和发布线程中订阅。\n\n我们知道了根据不同类型进行区分。那么关键是如何调用Subscribe方法的呢？\n`invokeSubscriber(subscription, event);`\n\n```\nvoid invokeSubscriber(Subscription subscription, Object event) {\n    try {\n        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);\n    } catch (InvocationTargetException e) {\n        handleSubscriberException(subscription, event, e.getCause());\n    } catch (IllegalAccessException e) {\n        throw new IllegalStateException(\"Unexpected exception\", e);\n    }\n}\n\n```\n这样订阅者收到了时间，调用了订阅方法。event参数也成功传入。\n\n### 反注册\n\n```\n/** Unregisters the given subscriber from all event classes. */\npublic synchronized void unregister(Object subscriber) {\n    List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);\n    if (subscribedTypes != null) {\n        for (Class<?> eventType : subscribedTypes) {\n            unsubscribeByEventType(subscriber, eventType);\n        }\n        typesBySubscriber.remove(subscriber);\n    } else {\n        logger.log(Level.WARNING, \"Subscriber to unregister was not registered before: \" + subscriber.getClass());\n    }\n}\n\n```\n\n我们在注册的时候知道 **`typesBySubscriber`**是一个存储订阅者，订阅事件的Map  \n`private final Map<Object, List<Class<?>>> typesBySubscriber;`。  \n先解绑list中的元素再讲Subscribe也从map中移除。我们看关键代码`unsubscribeByEventType(subscriber, eventType);` \n\n```\n/** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */\nprivate void unsubscribeByEventType(Object subscriber, Class<?> eventType) {\n    List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);\n    if (subscriptions != null) {\n        int size = subscriptions.size();\n        for (int i = 0; i < size; i++) {\n            Subscription subscription = subscriptions.get(i);\n            if (subscription.subscriber == subscriber) {\n                subscription.active = false;\n                subscriptions.remove(i);\n                i--;\n                size--;\n            }\n        }\n    }\n}\n\n```\n\n多看几遍源码就OK了。 (●ﾟωﾟ●)，接下来尝试着自己写一个简版的EventBus  \n[观察者模式](https://o0o0oo00.github.io/2018/10/09/Observer/#more)\n\n参考链接：\n\n\n* https://juejin.im/post/5a3e19c26fb9a0452207b6b5\n* https://juejin.im/post/58f5c86a8d6d810057c12975","source":"_posts/eventbus.md","raw":"---\ntitle: Eventbus浅析\ndate: 2018-10-25 15:53:05\ntag: android\ncategories: 技术\n---\n\n### 注册EventBus\n`EventBus.getDefault().register(this);`  \n\n我们来看看**`getDefault()`**中有什么\n\n```\n/** Convenience singleton for apps using a process-wide EventBus instance. */\npublic static EventBus getDefault() {\n    EventBus instance = defaultInstance;\n    if (instance == null) {\n        synchronized (EventBus.class) {\n            instance = EventBus.defaultInstance;\n            if (instance == null) {\n                instance = EventBus.defaultInstance = new EventBus();\n            }\n        }\n    }\n    return instance;\n}\n\n```\n很明显是一个**`DoubleCheck`**单例模式，具体的EventBus构造方法没贴，后面会介绍他其中的一些属性。\n  \n<!--more-->\n获取完了对象紧接着对当前activity或fragment进行了注册**register**\n\n```\npublic void register(Object subscriber) {\n    Class<?> subscriberClass = subscriber.getClass();\n    List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);\n    synchronized (this) {\n        for (SubscriberMethod subscriberMethod : subscriberMethods) {\n            subscribe(subscriber, subscriberMethod);\n        }\n    }\n}\n\n```\n\n我们可以看到，传入的`this`可以是Activity，进而得到了其class，通过**`findSubscriberMethods`**找到所有在这个class下的**Subscriber**们存放在一个List集合中，然后**逐个进行事件订阅**。\n\n关键方法 **findSubscriberMethods** \n\nsubscriberClass = 订阅类的class \n\n```\nList<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {\n    List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);\n    if (subscriberMethods != null) {\n        return subscriberMethods;\n    }\n\t //是否忽略注解器生成的MyEventBusIndex类 默认false\n    if (ignoreGeneratedIndex) {\n        subscriberMethods = findUsingReflection(subscriberClass);\n    } else {\n        subscriberMethods = findUsingInfo(subscriberClass);\n    }\n    if (subscriberMethods.isEmpty()) {\n        throw new EventBusException(\"Subscriber \" + subscriberClass\n                + \" and its super classes have no public methods with the @Subscribe annotation\");\n    } else {\n        METHOD_CACHE.put(subscriberClass, subscriberMethods);\n        return subscriberMethods;\n    }\n}\n```\n其中第一行的`METHOD_CACHE`作为缓存Map，以订阅类的class为key，订阅的方法集合作为value。\n`private static final Map<Class<?>, List<SubscriberMethod>> METHOD_CACHE = new ConcurrentHashMap<>();` \n\n如果没有缓存的时候，会判断是否**忽略生成index**，默认是false，那么我们来看一下`findUsingInfo(subscriberClass);`这个真正去查找该class下订阅方法的方法。\n\n先看一下FindState是什么东西。他里面存储了一些订阅者和订阅方法信息\n\n```\nstatic class FindState {\n\t//订阅方法集合，\n    final List<SubscriberMethod> subscriberMethods = new ArrayList<>();\n    //以event为key，以method为value\n    final Map<Class, Object> anyMethodByEventType = new HashMap<>();\n    //以method的名字生成一个methodKey为key，该method的类(订阅者)为value\n    final Map<String, Class> subscriberClassByMethodKey = new HashMap<>();\n    final StringBuilder methodKeyBuilder = new StringBuilder(128);\n\n    Class<?> subscriberClass;\n    Class<?> clazz;\n    boolean skipSuperClasses;\n    SubscriberInfo subscriberInfo;\n\n```\n这个方法返回的是我们最终需要的`List<SubscriberMethod>`\n\n```\nprivate List<SubscriberMethod> findUsingInfo(Class<?> subscriberClass) {\n    FindState findState = prepareFindState();\n    // 利用findState辅助来获取订阅方法\n    findState.initForSubscriber(subscriberClass);\n    while (findState.clazz != null) {\n        // 获取class对应的subscriberInfo\n        findState.subscriberInfo = getSubscriberInfo(findState);\n        if (findState.subscriberInfo != null) {\n            // 获取订阅方法数组\n            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();\n            for (SubscriberMethod subscriberMethod : array) {\n                if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {\n                    findState.subscriberMethods.add(subscriberMethod);\n                }\n            }\n        } else {\n            // subscriberInfo为null 则通过反射获取\n            findUsingReflectionInSingleClass(findState);\n        }\n        //接着获取父类的订阅方法\n        findState.moveToSuperclass();\n    }\n    return getMethodsAndRelease(findState);\n}\n```\n\n\n### 方法订阅（注册方法）\n\n其实上面这些就是为了获取到当前class 的所有订阅方法。然后遍历这些个订阅方法来完成订阅。接下来看一下**逐个订阅**  \n\n```\nfor (SubscriberMethod subscriberMethod : subscriberMethods) {\n    subscribe(subscriber, subscriberMethod);\n}\n```\n首先**映入眼帘**的是两个参数，一个**订阅Class**一个是订阅类中的要**订阅的方法**。\n\n上面把要订阅的方法封装成了`SubscriberMethod `。并且这个有一个事件类型（订阅方法的参数）`eventType`需要使用\n\n```\npublic class SubscriberMethod {\n    final Method method;\n    final ThreadMode threadMode;\n    final Class<?> eventType;\n    final int priority;\n    final boolean sticky;\n    /** Used for efficient comparison */\n    String methodString;\n\n```\n看订阅方法\n\n```\n// Must be called in synchronized block\nprivate void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {\n    \n\t//订阅方法的参数类型，也是事件类型\n\tClass<?> eventType = subscriberMethod.eventType;\n    // 封装订阅者和订阅方法\n    Subscription newSubscription = new Subscription(subscriber, subscriberMethod);\n    // 根据事件类型key，获取subscriptions （Map<Class<?>, CopyOnWriteArrayList<Subscription>>） \n    CopyOnWriteArrayList<Subscription> subscriptions = subscriptionsByEventType.get(eventType);\n    // 如果subscriptions集合为空，说明该事件类型没有注册，则创建一个新的集合。并把事件类型`eventType`作为key 和订阅方法集合作为value加入其中\n    if (subscriptions == null) {\n        subscriptions = new CopyOnWriteArrayList<>();\n        subscriptionsByEventType.put(eventType, subscriptions);\n    } else {\n        if (subscriptions.contains(newSubscription)) {\n            throw new EventBusException(\"Subscriber \" + subscriber.getClass() + \" already registered to event \"\n                    + eventType);\n        }\n    }\n\n    int size = subscriptions.size();\n    // 按照subscriberMethod的优先级插入newSubscription到正确的位置\n    for (int i = 0; i <= size; i++) {\n        // 最后一个直接插入，或者是要插入的method优先级大于 i 位置 的优先级\n        if (i == size || subscriberMethod.priority > subscriptions.get(i).subscriberMethod.priority) {\n            subscriptions.add(i, newSubscription);\n            break;\n        }\n    }\n\n    // 存放订阅Method的事件类型\n    List<Class<?>> subscribedEvents = typesBySubscriber.get(subscriber);\n    if (subscribedEvents == null) {\n        subscribedEvents = new ArrayList<>();\n        typesBySubscriber.put(subscriber, subscribedEvents);\n    }\n    subscribedEvents.add(eventType);\n\n    // 黏性事件\n    if (subscriberMethod.sticky) {\n        if (eventInheritance) {\n            // Existing sticky events of all subclasses of eventType have to be considered.\n            // Note: Iterating over all events may be inefficient with lots of sticky events,\n            // thus data structure should be changed to allow a more efficient lookup\n            // (e.g. an additional map storing sub classes of super classes: Class -> List<Class>).\n            Set<Map.Entry<Class<?>, Object>> entries = stickyEvents.entrySet();\n            for (Map.Entry<Class<?>, Object> entry : entries) {\n                Class<?> candidateEventType = entry.getKey();\n                if (eventType.isAssignableFrom(candidateEventType)) {\n                    Object stickyEvent = entry.getValue();\n                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);\n                }\n            }\n        } else {\n            Object stickyEvent = stickyEvents.get(eventType);\n            checkPostStickyEventToSubscription(newSubscription, stickyEvent);\n        }\n    }\n}\n```\n**方法说明**\n>\n* 首先获取了方法参数类型 ： `eventType`\n* 根据事件类型`eventType`，获取其所有订阅方法 ：`subscriptionsByEventType.get(eventType);`\n* subscriptions如果已经被初始化了，那么按照优先级将新的method插入其中，如果没有初始化，那么就`new CopyOnWriteArrayList<>();`\n* 获取订阅者所有的订阅事件类型 ： `typesBySubscriber.get(subscriber);`\n* 如果初始化了，那么就直接添加这个`eventType `到对应的集合中，如果没有那么初始化并将**`Subscriber`（还记得参数传入的就是这个吗）**作为key，**`eventType `集合**作为value\n\n\n**不太明白没关系，我们再接着往下看。。。**\n\n### 事件发布\n`EventBus.getDefault().post(new UpdateUIEvent());`\n\npost：\n\n```\n/** Posts the given event to the event bus. */\npublic void post(Object event) {\n    PostingThreadState postingState = currentPostingThreadState.get();\n    List<Object> eventQueue = postingState.eventQueue;\n    // 将事件添加进当前线程的事件队列\n    eventQueue.add(event);\n\t // 判断当前线程是否正在发布事件\n    if (!postingState.isPosting) {\n        postingState.isMainThread = isMainThread();\n        postingState.isPosting = true;\n        if (postingState.canceled) {\n            throw new EventBusException(\"Internal error. Abort state was not reset\");\n        }\n        try {\n            while (!eventQueue.isEmpty()) {\n                postSingleEvent(eventQueue.remove(0), postingState);\n            }\n        } finally {\n            postingState.isPosting = false;\n            postingState.isMainThread = false;\n        }\n    }\n}\n\n```\n\n首先`currentPostingThreadState`是一个`ThreadLocal<PostingThreadState>`\n\nThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，而这段数据是不会与其他线程共享的。可以看出currentPostingThreadState的实现是一个包含了PostingThreadState的ThreadLocal对象,这样可以保证取到的都是自己线程对应的数据。\n\n```\n/** For ThreadLocal, much faster to set (and get multiple values). */\nfinal static class PostingThreadState {\n    final List<Object> eventQueue = new ArrayList<>();//当前线程的事件队列\n    boolean isPosting; //是否有事件正在分发\n    boolean isMainThread;//post的线程是否是主线程\n    Subscription subscription;\n    Object event;\n    boolean canceled;\n}\n```\nPostingThreadState中包含了当前线程的事件队列，就是当前线程所有分发的事件都保存在eventQueue事件队列中以及订阅者订阅事件等信息，有了这些信息我们就可以从事件队列中取出事件分发给对应的订阅者。\n\n\n我们看到了把当前的事件加入到了事件队列尾部，如果事件队列不为empty，那么就一直发送里面的事件直到为empty。我们看一下关键代码`postSingleEvent(eventQueue.remove(0), postingState);`  \n\n```\nprivate void postSingleEvent(Object event, PostingThreadState postingState) throws Error {\n    Class<?> eventClass = event.getClass();\n    boolean subscriptionFound = false;\n    if (eventInheritance) {\n        List<Class<?>> eventTypes = lookupAllEventTypes(eventClass);\n        int countTypes = eventTypes.size();\n        for (int h = 0; h < countTypes; h++) {\n            Class<?> clazz = eventTypes.get(h);\n            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);\n        }\n    } else {\n        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);\n    }\n    if (!subscriptionFound) {\n        if (logNoSubscriberMessages) {\n            logger.log(Level.FINE, \"No subscribers registered for event \" + eventClass);\n        }\n        if (sendNoSubscriberEvent && eventClass != NoSubscriberEvent.class &&\n                eventClass != SubscriberExceptionEvent.class) {\n            post(new NoSubscriberEvent(this, event));\n        }\n    }\n}\n```\n首先判断的是`eventInheritance `是否开启了继承，由于EventBus创建的是默认的Builder，所以默认值为初始值true。那么会找到它所有的父类，然后依次发送事件。关键在于方法**`postSingleEventForEventType(event, postingState, eventClass);`**  \n\n```\nprivate boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class<?> eventClass) {\n    CopyOnWriteArrayList<Subscription> subscriptions;\n    synchronized (this) {\n        // 根据事件类型找出相关的订阅信息\n        subscriptions = subscriptionsByEventType.get(eventClass);\n    }\n    if (subscriptions != null && !subscriptions.isEmpty()) {\n        for (Subscription subscription : subscriptions) {\n            postingState.event = event;\n            postingState.subscription = subscription;\n            boolean aborted = false;\n            try {\n                // 发布到具体的订阅者\n                postToSubscription(subscription, event, postingState.isMainThread);\n                aborted = postingState.canceled;\n            } finally {\n                postingState.event = null;\n                postingState.subscription = null;\n                postingState.canceled = false;\n            }\n            if (aborted) {\n                break;\n            }\n        }\n        return true;\n    }\n    return false;\n}\n```\n\n我们可以看到，如果根据事件类型找不到订阅方法，或者订阅方法为空，那么会返回false，上面抛出异常`No subscribers registered for event`。那如果找到了订阅的方法呢。\n\n```\nprivate void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {\n    switch (subscription.subscriberMethod.threadMode) {\n        // 订阅线程跟随发布线程\n        case POSTING:\n            // 订阅线程和发布线程相同，直接订阅\n            invokeSubscriber(subscription, event);\n            break;\n        // 订阅线程为主线程\n        case MAIN:\n            // 发布线程和订阅线程都是主线程，直接订阅\n            if (isMainThread) {\n                invokeSubscriber(subscription, event);\n            }\n            // 发布线程不是主线程，订阅线程切换到主线程订阅\n            else {\n                mainThreadPoster.enqueue(subscription, event);\n            }\n            break;\n        case MAIN_ORDERED:\n            if (mainThreadPoster != null) {\n                mainThreadPoster.enqueue(subscription, event);\n            }\n            else {\n                // temporary: technically not correct as poster not decoupled from subscriber\n                invokeSubscriber(subscription, event);\n            }\n            break;\n        // 订阅线程为后台线程\n        case BACKGROUND:\n            // 发布线程为主线程，切换到后台线程订阅\n            if (isMainThread) {\n                backgroundPoster.enqueue(subscription, event);\n            }\n            // 发布线程不为主线程，直接订阅\n            else {\n                invokeSubscriber(subscription, event);\n            }\n            break;\n        // 订阅线程为异步线程\n        case ASYNC:\n            // 使用线程池线程订阅\n            asyncPoster.enqueue(subscription, event);\n            break;\n        default:\n            throw new IllegalStateException(\"Unknown thread mode: \" + subscription.subscriberMethod.threadMode);\n    }\n}\n```\n* POSTING：事件发布在什么线程，就在什么线程订阅。\n* MAIN：无论事件在什么线程发布，都在主线程订阅。\n* BACKGROUND：如果发布的线程不是主线程，则在该线程订阅，如果是主线程，则使用一个单独的后台线程订阅。\n* ASYNC：在非主线程和发布线程中订阅。\n\n我们知道了根据不同类型进行区分。那么关键是如何调用Subscribe方法的呢？\n`invokeSubscriber(subscription, event);`\n\n```\nvoid invokeSubscriber(Subscription subscription, Object event) {\n    try {\n        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);\n    } catch (InvocationTargetException e) {\n        handleSubscriberException(subscription, event, e.getCause());\n    } catch (IllegalAccessException e) {\n        throw new IllegalStateException(\"Unexpected exception\", e);\n    }\n}\n\n```\n这样订阅者收到了时间，调用了订阅方法。event参数也成功传入。\n\n### 反注册\n\n```\n/** Unregisters the given subscriber from all event classes. */\npublic synchronized void unregister(Object subscriber) {\n    List<Class<?>> subscribedTypes = typesBySubscriber.get(subscriber);\n    if (subscribedTypes != null) {\n        for (Class<?> eventType : subscribedTypes) {\n            unsubscribeByEventType(subscriber, eventType);\n        }\n        typesBySubscriber.remove(subscriber);\n    } else {\n        logger.log(Level.WARNING, \"Subscriber to unregister was not registered before: \" + subscriber.getClass());\n    }\n}\n\n```\n\n我们在注册的时候知道 **`typesBySubscriber`**是一个存储订阅者，订阅事件的Map  \n`private final Map<Object, List<Class<?>>> typesBySubscriber;`。  \n先解绑list中的元素再讲Subscribe也从map中移除。我们看关键代码`unsubscribeByEventType(subscriber, eventType);` \n\n```\n/** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */\nprivate void unsubscribeByEventType(Object subscriber, Class<?> eventType) {\n    List<Subscription> subscriptions = subscriptionsByEventType.get(eventType);\n    if (subscriptions != null) {\n        int size = subscriptions.size();\n        for (int i = 0; i < size; i++) {\n            Subscription subscription = subscriptions.get(i);\n            if (subscription.subscriber == subscriber) {\n                subscription.active = false;\n                subscriptions.remove(i);\n                i--;\n                size--;\n            }\n        }\n    }\n}\n\n```\n\n多看几遍源码就OK了。 (●ﾟωﾟ●)，接下来尝试着自己写一个简版的EventBus  \n[观察者模式](https://o0o0oo00.github.io/2018/10/09/Observer/#more)\n\n参考链接：\n\n\n* https://juejin.im/post/5a3e19c26fb9a0452207b6b5\n* https://juejin.im/post/58f5c86a8d6d810057c12975","slug":"eventbus","published":1,"updated":"2019-02-28T09:07:11.179Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsogf13t002p5l26ym4j101z","content":"<h3 id=\"注册EventBus\"><a href=\"#注册EventBus\" class=\"headerlink\" title=\"注册EventBus\"></a>注册EventBus</h3><p><code>EventBus.getDefault().register(this);</code>  </p>\n<p>我们来看看<strong><code>getDefault()</code></strong>中有什么</p>\n<pre><code>/** Convenience singleton for apps using a process-wide EventBus instance. */\npublic static EventBus getDefault() {\n    EventBus instance = defaultInstance;\n    if (instance == null) {\n        synchronized (EventBus.class) {\n            instance = EventBus.defaultInstance;\n            if (instance == null) {\n                instance = EventBus.defaultInstance = new EventBus();\n            }\n        }\n    }\n    return instance;\n}\n\n</code></pre><p>很明显是一个<strong><code>DoubleCheck</code></strong>单例模式，具体的EventBus构造方法没贴，后面会介绍他其中的一些属性。</p>\n<a id=\"more\"></a>\n<p>获取完了对象紧接着对当前activity或fragment进行了注册<strong>register</strong></p>\n<pre><code>public void register(Object subscriber) {\n    Class&lt;?&gt; subscriberClass = subscriber.getClass();\n    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);\n    synchronized (this) {\n        for (SubscriberMethod subscriberMethod : subscriberMethods) {\n            subscribe(subscriber, subscriberMethod);\n        }\n    }\n}\n\n</code></pre><p>我们可以看到，传入的<code>this</code>可以是Activity，进而得到了其class，通过<strong><code>findSubscriberMethods</code></strong>找到所有在这个class下的<strong>Subscriber</strong>们存放在一个List集合中，然后<strong>逐个进行事件订阅</strong>。</p>\n<p>关键方法 <strong>findSubscriberMethods</strong> </p>\n<p>subscriberClass = 订阅类的class </p>\n<pre><code>List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) {\n    List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);\n    if (subscriberMethods != null) {\n        return subscriberMethods;\n    }\n     //是否忽略注解器生成的MyEventBusIndex类 默认false\n    if (ignoreGeneratedIndex) {\n        subscriberMethods = findUsingReflection(subscriberClass);\n    } else {\n        subscriberMethods = findUsingInfo(subscriberClass);\n    }\n    if (subscriberMethods.isEmpty()) {\n        throw new EventBusException(&quot;Subscriber &quot; + subscriberClass\n                + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);\n    } else {\n        METHOD_CACHE.put(subscriberClass, subscriberMethods);\n        return subscriberMethods;\n    }\n}\n</code></pre><p>其中第一行的<code>METHOD_CACHE</code>作为缓存Map，以订阅类的class为key，订阅的方法集合作为value。<br><code>private static final Map&lt;Class&lt;?&gt;, List&lt;SubscriberMethod&gt;&gt; METHOD_CACHE = new ConcurrentHashMap&lt;&gt;();</code> </p>\n<p>如果没有缓存的时候，会判断是否<strong>忽略生成index</strong>，默认是false，那么我们来看一下<code>findUsingInfo(subscriberClass);</code>这个真正去查找该class下订阅方法的方法。</p>\n<p>先看一下FindState是什么东西。他里面存储了一些订阅者和订阅方法信息</p>\n<pre><code>static class FindState {\n    //订阅方法集合，\n    final List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;();\n    //以event为key，以method为value\n    final Map&lt;Class, Object&gt; anyMethodByEventType = new HashMap&lt;&gt;();\n    //以method的名字生成一个methodKey为key，该method的类(订阅者)为value\n    final Map&lt;String, Class&gt; subscriberClassByMethodKey = new HashMap&lt;&gt;();\n    final StringBuilder methodKeyBuilder = new StringBuilder(128);\n\n    Class&lt;?&gt; subscriberClass;\n    Class&lt;?&gt; clazz;\n    boolean skipSuperClasses;\n    SubscriberInfo subscriberInfo;\n\n</code></pre><p>这个方法返回的是我们最终需要的<code>List&lt;SubscriberMethod&gt;</code></p>\n<pre><code>private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) {\n    FindState findState = prepareFindState();\n    // 利用findState辅助来获取订阅方法\n    findState.initForSubscriber(subscriberClass);\n    while (findState.clazz != null) {\n        // 获取class对应的subscriberInfo\n        findState.subscriberInfo = getSubscriberInfo(findState);\n        if (findState.subscriberInfo != null) {\n            // 获取订阅方法数组\n            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();\n            for (SubscriberMethod subscriberMethod : array) {\n                if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {\n                    findState.subscriberMethods.add(subscriberMethod);\n                }\n            }\n        } else {\n            // subscriberInfo为null 则通过反射获取\n            findUsingReflectionInSingleClass(findState);\n        }\n        //接着获取父类的订阅方法\n        findState.moveToSuperclass();\n    }\n    return getMethodsAndRelease(findState);\n}\n</code></pre><h3 id=\"方法订阅（注册方法）\"><a href=\"#方法订阅（注册方法）\" class=\"headerlink\" title=\"方法订阅（注册方法）\"></a>方法订阅（注册方法）</h3><p>其实上面这些就是为了获取到当前class 的所有订阅方法。然后遍历这些个订阅方法来完成订阅。接下来看一下<strong>逐个订阅</strong>  </p>\n<pre><code>for (SubscriberMethod subscriberMethod : subscriberMethods) {\n    subscribe(subscriber, subscriberMethod);\n}\n</code></pre><p>首先<strong>映入眼帘</strong>的是两个参数，一个<strong>订阅Class</strong>一个是订阅类中的要<strong>订阅的方法</strong>。</p>\n<p>上面把要订阅的方法封装成了<code>SubscriberMethod</code>。并且这个有一个事件类型（订阅方法的参数）<code>eventType</code>需要使用</p>\n<pre><code>public class SubscriberMethod {\n    final Method method;\n    final ThreadMode threadMode;\n    final Class&lt;?&gt; eventType;\n    final int priority;\n    final boolean sticky;\n    /** Used for efficient comparison */\n    String methodString;\n\n</code></pre><p>看订阅方法</p>\n<pre><code>// Must be called in synchronized block\nprivate void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {\n\n    //订阅方法的参数类型，也是事件类型\n    Class&lt;?&gt; eventType = subscriberMethod.eventType;\n    // 封装订阅者和订阅方法\n    Subscription newSubscription = new Subscription(subscriber, subscriberMethod);\n    // 根据事件类型key，获取subscriptions （Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt;） \n    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);\n    // 如果subscriptions集合为空，说明该事件类型没有注册，则创建一个新的集合。并把事件类型`eventType`作为key 和订阅方法集合作为value加入其中\n    if (subscriptions == null) {\n        subscriptions = new CopyOnWriteArrayList&lt;&gt;();\n        subscriptionsByEventType.put(eventType, subscriptions);\n    } else {\n        if (subscriptions.contains(newSubscription)) {\n            throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;\n                    + eventType);\n        }\n    }\n\n    int size = subscriptions.size();\n    // 按照subscriberMethod的优先级插入newSubscription到正确的位置\n    for (int i = 0; i &lt;= size; i++) {\n        // 最后一个直接插入，或者是要插入的method优先级大于 i 位置 的优先级\n        if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) {\n            subscriptions.add(i, newSubscription);\n            break;\n        }\n    }\n\n    // 存放订阅Method的事件类型\n    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);\n    if (subscribedEvents == null) {\n        subscribedEvents = new ArrayList&lt;&gt;();\n        typesBySubscriber.put(subscriber, subscribedEvents);\n    }\n    subscribedEvents.add(eventType);\n\n    // 黏性事件\n    if (subscriberMethod.sticky) {\n        if (eventInheritance) {\n            // Existing sticky events of all subclasses of eventType have to be considered.\n            // Note: Iterating over all events may be inefficient with lots of sticky events,\n            // thus data structure should be changed to allow a more efficient lookup\n            // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).\n            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();\n            for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) {\n                Class&lt;?&gt; candidateEventType = entry.getKey();\n                if (eventType.isAssignableFrom(candidateEventType)) {\n                    Object stickyEvent = entry.getValue();\n                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);\n                }\n            }\n        } else {\n            Object stickyEvent = stickyEvents.get(eventType);\n            checkPostStickyEventToSubscription(newSubscription, stickyEvent);\n        }\n    }\n}\n</code></pre><p><strong>方法说明</strong></p>\n<blockquote>\n</blockquote>\n<ul>\n<li>首先获取了方法参数类型 ： <code>eventType</code></li>\n<li>根据事件类型<code>eventType</code>，获取其所有订阅方法 ：<code>subscriptionsByEventType.get(eventType);</code></li>\n<li>subscriptions如果已经被初始化了，那么按照优先级将新的method插入其中，如果没有初始化，那么就<code>new CopyOnWriteArrayList&lt;&gt;();</code></li>\n<li>获取订阅者所有的订阅事件类型 ： <code>typesBySubscriber.get(subscriber);</code></li>\n<li>如果初始化了，那么就直接添加这个<code>eventType</code>到对应的集合中，如果没有那么初始化并将<strong><code>Subscriber</code>（还记得参数传入的就是这个吗）</strong>作为key，<strong><code>eventType</code>集合</strong>作为value</li>\n</ul>\n<p><strong>不太明白没关系，我们再接着往下看。。。</strong></p>\n<h3 id=\"事件发布\"><a href=\"#事件发布\" class=\"headerlink\" title=\"事件发布\"></a>事件发布</h3><p><code>EventBus.getDefault().post(new UpdateUIEvent());</code></p>\n<p>post：</p>\n<pre><code>/** Posts the given event to the event bus. */\npublic void post(Object event) {\n    PostingThreadState postingState = currentPostingThreadState.get();\n    List&lt;Object&gt; eventQueue = postingState.eventQueue;\n    // 将事件添加进当前线程的事件队列\n    eventQueue.add(event);\n     // 判断当前线程是否正在发布事件\n    if (!postingState.isPosting) {\n        postingState.isMainThread = isMainThread();\n        postingState.isPosting = true;\n        if (postingState.canceled) {\n            throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;);\n        }\n        try {\n            while (!eventQueue.isEmpty()) {\n                postSingleEvent(eventQueue.remove(0), postingState);\n            }\n        } finally {\n            postingState.isPosting = false;\n            postingState.isMainThread = false;\n        }\n    }\n}\n\n</code></pre><p>首先<code>currentPostingThreadState</code>是一个<code>ThreadLocal&lt;PostingThreadState&gt;</code></p>\n<p>ThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，而这段数据是不会与其他线程共享的。可以看出currentPostingThreadState的实现是一个包含了PostingThreadState的ThreadLocal对象,这样可以保证取到的都是自己线程对应的数据。</p>\n<pre><code>/** For ThreadLocal, much faster to set (and get multiple values). */\nfinal static class PostingThreadState {\n    final List&lt;Object&gt; eventQueue = new ArrayList&lt;&gt;();//当前线程的事件队列\n    boolean isPosting; //是否有事件正在分发\n    boolean isMainThread;//post的线程是否是主线程\n    Subscription subscription;\n    Object event;\n    boolean canceled;\n}\n</code></pre><p>PostingThreadState中包含了当前线程的事件队列，就是当前线程所有分发的事件都保存在eventQueue事件队列中以及订阅者订阅事件等信息，有了这些信息我们就可以从事件队列中取出事件分发给对应的订阅者。</p>\n<p>我们看到了把当前的事件加入到了事件队列尾部，如果事件队列不为empty，那么就一直发送里面的事件直到为empty。我们看一下关键代码<code>postSingleEvent(eventQueue.remove(0), postingState);</code>  </p>\n<pre><code>private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {\n    Class&lt;?&gt; eventClass = event.getClass();\n    boolean subscriptionFound = false;\n    if (eventInheritance) {\n        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);\n        int countTypes = eventTypes.size();\n        for (int h = 0; h &lt; countTypes; h++) {\n            Class&lt;?&gt; clazz = eventTypes.get(h);\n            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);\n        }\n    } else {\n        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);\n    }\n    if (!subscriptionFound) {\n        if (logNoSubscriberMessages) {\n            logger.log(Level.FINE, &quot;No subscribers registered for event &quot; + eventClass);\n        }\n        if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;\n                eventClass != SubscriberExceptionEvent.class) {\n            post(new NoSubscriberEvent(this, event));\n        }\n    }\n}\n</code></pre><p>首先判断的是<code>eventInheritance</code>是否开启了继承，由于EventBus创建的是默认的Builder，所以默认值为初始值true。那么会找到它所有的父类，然后依次发送事件。关键在于方法<strong><code>postSingleEventForEventType(event, postingState, eventClass);</code></strong>  </p>\n<pre><code>private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) {\n    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;\n    synchronized (this) {\n        // 根据事件类型找出相关的订阅信息\n        subscriptions = subscriptionsByEventType.get(eventClass);\n    }\n    if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) {\n        for (Subscription subscription : subscriptions) {\n            postingState.event = event;\n            postingState.subscription = subscription;\n            boolean aborted = false;\n            try {\n                // 发布到具体的订阅者\n                postToSubscription(subscription, event, postingState.isMainThread);\n                aborted = postingState.canceled;\n            } finally {\n                postingState.event = null;\n                postingState.subscription = null;\n                postingState.canceled = false;\n            }\n            if (aborted) {\n                break;\n            }\n        }\n        return true;\n    }\n    return false;\n}\n</code></pre><p>我们可以看到，如果根据事件类型找不到订阅方法，或者订阅方法为空，那么会返回false，上面抛出异常<code>No subscribers registered for event</code>。那如果找到了订阅的方法呢。</p>\n<pre><code>private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {\n    switch (subscription.subscriberMethod.threadMode) {\n        // 订阅线程跟随发布线程\n        case POSTING:\n            // 订阅线程和发布线程相同，直接订阅\n            invokeSubscriber(subscription, event);\n            break;\n        // 订阅线程为主线程\n        case MAIN:\n            // 发布线程和订阅线程都是主线程，直接订阅\n            if (isMainThread) {\n                invokeSubscriber(subscription, event);\n            }\n            // 发布线程不是主线程，订阅线程切换到主线程订阅\n            else {\n                mainThreadPoster.enqueue(subscription, event);\n            }\n            break;\n        case MAIN_ORDERED:\n            if (mainThreadPoster != null) {\n                mainThreadPoster.enqueue(subscription, event);\n            }\n            else {\n                // temporary: technically not correct as poster not decoupled from subscriber\n                invokeSubscriber(subscription, event);\n            }\n            break;\n        // 订阅线程为后台线程\n        case BACKGROUND:\n            // 发布线程为主线程，切换到后台线程订阅\n            if (isMainThread) {\n                backgroundPoster.enqueue(subscription, event);\n            }\n            // 发布线程不为主线程，直接订阅\n            else {\n                invokeSubscriber(subscription, event);\n            }\n            break;\n        // 订阅线程为异步线程\n        case ASYNC:\n            // 使用线程池线程订阅\n            asyncPoster.enqueue(subscription, event);\n            break;\n        default:\n            throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);\n    }\n}\n</code></pre><ul>\n<li>POSTING：事件发布在什么线程，就在什么线程订阅。</li>\n<li>MAIN：无论事件在什么线程发布，都在主线程订阅。</li>\n<li>BACKGROUND：如果发布的线程不是主线程，则在该线程订阅，如果是主线程，则使用一个单独的后台线程订阅。</li>\n<li>ASYNC：在非主线程和发布线程中订阅。</li>\n</ul>\n<p>我们知道了根据不同类型进行区分。那么关键是如何调用Subscribe方法的呢？<br><code>invokeSubscriber(subscription, event);</code></p>\n<pre><code>void invokeSubscriber(Subscription subscription, Object event) {\n    try {\n        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);\n    } catch (InvocationTargetException e) {\n        handleSubscriberException(subscription, event, e.getCause());\n    } catch (IllegalAccessException e) {\n        throw new IllegalStateException(&quot;Unexpected exception&quot;, e);\n    }\n}\n\n</code></pre><p>这样订阅者收到了时间，调用了订阅方法。event参数也成功传入。</p>\n<h3 id=\"反注册\"><a href=\"#反注册\" class=\"headerlink\" title=\"反注册\"></a>反注册</h3><pre><code>/** Unregisters the given subscriber from all event classes. */\npublic synchronized void unregister(Object subscriber) {\n    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);\n    if (subscribedTypes != null) {\n        for (Class&lt;?&gt; eventType : subscribedTypes) {\n            unsubscribeByEventType(subscriber, eventType);\n        }\n        typesBySubscriber.remove(subscriber);\n    } else {\n        logger.log(Level.WARNING, &quot;Subscriber to unregister was not registered before: &quot; + subscriber.getClass());\n    }\n}\n\n</code></pre><p>我们在注册的时候知道 <strong><code>typesBySubscriber</code></strong>是一个存储订阅者，订阅事件的Map<br><code>private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</code>。<br>先解绑list中的元素再讲Subscribe也从map中移除。我们看关键代码<code>unsubscribeByEventType(subscriber, eventType);</code> </p>\n<pre><code>/** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */\nprivate void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) {\n    List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);\n    if (subscriptions != null) {\n        int size = subscriptions.size();\n        for (int i = 0; i &lt; size; i++) {\n            Subscription subscription = subscriptions.get(i);\n            if (subscription.subscriber == subscriber) {\n                subscription.active = false;\n                subscriptions.remove(i);\n                i--;\n                size--;\n            }\n        }\n    }\n}\n\n</code></pre><p>多看几遍源码就OK了。 (●ﾟωﾟ●)，接下来尝试着自己写一个简版的EventBus<br><a href=\"https://o0o0oo00.github.io/2018/10/09/Observer/#more\">观察者模式</a></p>\n<p>参考链接：</p>\n<ul>\n<li><a href=\"https://juejin.im/post/5a3e19c26fb9a0452207b6b5\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5a3e19c26fb9a0452207b6b5</a></li>\n<li><a href=\"https://juejin.im/post/58f5c86a8d6d810057c12975\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/58f5c86a8d6d810057c12975</a></li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"https://avatars0.githubusercontent.com/u/26478376?s=400&v=4","name":"HealerJean梦想","introduction":"HealerJean的梦想博客，吾自仰天常笑，不知刀峰何归 ","url":"http://blog.healerjean.com/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/4027734.jpeg","name":"闪烁之狐","introduction":"编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬","url":"https://blinkfox.github.io/","title":"前去学习"},{"avatar":"http://image.luokangyuan.com/avatar.jpg","name":"ja_rome","introduction":"平凡的脚步也可以走出伟大的行程","url":"ttps://me.csdn.net/jlh912008548","title":"前去学习"},{"avatar":"https://avatars3.githubusercontent.com/u/12763277?s=400&v=4","name":"万神","introduction":"Dream of becoming an Independent musician Independent developer","url":"http://werbhelius.com/","title":"前去学习"}]}},"excerpt":"<h3 id=\"注册EventBus\"><a href=\"#注册EventBus\" class=\"headerlink\" title=\"注册EventBus\"></a>注册EventBus</h3><p><code>EventBus.getDefault().register(this);</code>  </p>\n<p>我们来看看<strong><code>getDefault()</code></strong>中有什么</p>\n<pre><code>/** Convenience singleton for apps using a process-wide EventBus instance. */\npublic static EventBus getDefault() {\n    EventBus instance = defaultInstance;\n    if (instance == null) {\n        synchronized (EventBus.class) {\n            instance = EventBus.defaultInstance;\n            if (instance == null) {\n                instance = EventBus.defaultInstance = new EventBus();\n            }\n        }\n    }\n    return instance;\n}\n\n</code></pre><p>很明显是一个<strong><code>DoubleCheck</code></strong>单例模式，具体的EventBus构造方法没贴，后面会介绍他其中的一些属性。</p>","more":"<p>获取完了对象紧接着对当前activity或fragment进行了注册<strong>register</strong></p>\n<pre><code>public void register(Object subscriber) {\n    Class&lt;?&gt; subscriberClass = subscriber.getClass();\n    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);\n    synchronized (this) {\n        for (SubscriberMethod subscriberMethod : subscriberMethods) {\n            subscribe(subscriber, subscriberMethod);\n        }\n    }\n}\n\n</code></pre><p>我们可以看到，传入的<code>this</code>可以是Activity，进而得到了其class，通过<strong><code>findSubscriberMethods</code></strong>找到所有在这个class下的<strong>Subscriber</strong>们存放在一个List集合中，然后<strong>逐个进行事件订阅</strong>。</p>\n<p>关键方法 <strong>findSubscriberMethods</strong> </p>\n<p>subscriberClass = 订阅类的class </p>\n<pre><code>List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) {\n    List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);\n    if (subscriberMethods != null) {\n        return subscriberMethods;\n    }\n     //是否忽略注解器生成的MyEventBusIndex类 默认false\n    if (ignoreGeneratedIndex) {\n        subscriberMethods = findUsingReflection(subscriberClass);\n    } else {\n        subscriberMethods = findUsingInfo(subscriberClass);\n    }\n    if (subscriberMethods.isEmpty()) {\n        throw new EventBusException(&quot;Subscriber &quot; + subscriberClass\n                + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);\n    } else {\n        METHOD_CACHE.put(subscriberClass, subscriberMethods);\n        return subscriberMethods;\n    }\n}\n</code></pre><p>其中第一行的<code>METHOD_CACHE</code>作为缓存Map，以订阅类的class为key，订阅的方法集合作为value。<br><code>private static final Map&lt;Class&lt;?&gt;, List&lt;SubscriberMethod&gt;&gt; METHOD_CACHE = new ConcurrentHashMap&lt;&gt;();</code> </p>\n<p>如果没有缓存的时候，会判断是否<strong>忽略生成index</strong>，默认是false，那么我们来看一下<code>findUsingInfo(subscriberClass);</code>这个真正去查找该class下订阅方法的方法。</p>\n<p>先看一下FindState是什么东西。他里面存储了一些订阅者和订阅方法信息</p>\n<pre><code>static class FindState {\n    //订阅方法集合，\n    final List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;();\n    //以event为key，以method为value\n    final Map&lt;Class, Object&gt; anyMethodByEventType = new HashMap&lt;&gt;();\n    //以method的名字生成一个methodKey为key，该method的类(订阅者)为value\n    final Map&lt;String, Class&gt; subscriberClassByMethodKey = new HashMap&lt;&gt;();\n    final StringBuilder methodKeyBuilder = new StringBuilder(128);\n\n    Class&lt;?&gt; subscriberClass;\n    Class&lt;?&gt; clazz;\n    boolean skipSuperClasses;\n    SubscriberInfo subscriberInfo;\n\n</code></pre><p>这个方法返回的是我们最终需要的<code>List&lt;SubscriberMethod&gt;</code></p>\n<pre><code>private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) {\n    FindState findState = prepareFindState();\n    // 利用findState辅助来获取订阅方法\n    findState.initForSubscriber(subscriberClass);\n    while (findState.clazz != null) {\n        // 获取class对应的subscriberInfo\n        findState.subscriberInfo = getSubscriberInfo(findState);\n        if (findState.subscriberInfo != null) {\n            // 获取订阅方法数组\n            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();\n            for (SubscriberMethod subscriberMethod : array) {\n                if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {\n                    findState.subscriberMethods.add(subscriberMethod);\n                }\n            }\n        } else {\n            // subscriberInfo为null 则通过反射获取\n            findUsingReflectionInSingleClass(findState);\n        }\n        //接着获取父类的订阅方法\n        findState.moveToSuperclass();\n    }\n    return getMethodsAndRelease(findState);\n}\n</code></pre><h3 id=\"方法订阅（注册方法）\"><a href=\"#方法订阅（注册方法）\" class=\"headerlink\" title=\"方法订阅（注册方法）\"></a>方法订阅（注册方法）</h3><p>其实上面这些就是为了获取到当前class 的所有订阅方法。然后遍历这些个订阅方法来完成订阅。接下来看一下<strong>逐个订阅</strong>  </p>\n<pre><code>for (SubscriberMethod subscriberMethod : subscriberMethods) {\n    subscribe(subscriber, subscriberMethod);\n}\n</code></pre><p>首先<strong>映入眼帘</strong>的是两个参数，一个<strong>订阅Class</strong>一个是订阅类中的要<strong>订阅的方法</strong>。</p>\n<p>上面把要订阅的方法封装成了<code>SubscriberMethod</code>。并且这个有一个事件类型（订阅方法的参数）<code>eventType</code>需要使用</p>\n<pre><code>public class SubscriberMethod {\n    final Method method;\n    final ThreadMode threadMode;\n    final Class&lt;?&gt; eventType;\n    final int priority;\n    final boolean sticky;\n    /** Used for efficient comparison */\n    String methodString;\n\n</code></pre><p>看订阅方法</p>\n<pre><code>// Must be called in synchronized block\nprivate void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {\n\n    //订阅方法的参数类型，也是事件类型\n    Class&lt;?&gt; eventType = subscriberMethod.eventType;\n    // 封装订阅者和订阅方法\n    Subscription newSubscription = new Subscription(subscriber, subscriberMethod);\n    // 根据事件类型key，获取subscriptions （Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt;） \n    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);\n    // 如果subscriptions集合为空，说明该事件类型没有注册，则创建一个新的集合。并把事件类型`eventType`作为key 和订阅方法集合作为value加入其中\n    if (subscriptions == null) {\n        subscriptions = new CopyOnWriteArrayList&lt;&gt;();\n        subscriptionsByEventType.put(eventType, subscriptions);\n    } else {\n        if (subscriptions.contains(newSubscription)) {\n            throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot;\n                    + eventType);\n        }\n    }\n\n    int size = subscriptions.size();\n    // 按照subscriberMethod的优先级插入newSubscription到正确的位置\n    for (int i = 0; i &lt;= size; i++) {\n        // 最后一个直接插入，或者是要插入的method优先级大于 i 位置 的优先级\n        if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) {\n            subscriptions.add(i, newSubscription);\n            break;\n        }\n    }\n\n    // 存放订阅Method的事件类型\n    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);\n    if (subscribedEvents == null) {\n        subscribedEvents = new ArrayList&lt;&gt;();\n        typesBySubscriber.put(subscriber, subscribedEvents);\n    }\n    subscribedEvents.add(eventType);\n\n    // 黏性事件\n    if (subscriberMethod.sticky) {\n        if (eventInheritance) {\n            // Existing sticky events of all subclasses of eventType have to be considered.\n            // Note: Iterating over all events may be inefficient with lots of sticky events,\n            // thus data structure should be changed to allow a more efficient lookup\n            // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).\n            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();\n            for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) {\n                Class&lt;?&gt; candidateEventType = entry.getKey();\n                if (eventType.isAssignableFrom(candidateEventType)) {\n                    Object stickyEvent = entry.getValue();\n                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);\n                }\n            }\n        } else {\n            Object stickyEvent = stickyEvents.get(eventType);\n            checkPostStickyEventToSubscription(newSubscription, stickyEvent);\n        }\n    }\n}\n</code></pre><p><strong>方法说明</strong></p>\n<blockquote>\n</blockquote>\n<ul>\n<li>首先获取了方法参数类型 ： <code>eventType</code></li>\n<li>根据事件类型<code>eventType</code>，获取其所有订阅方法 ：<code>subscriptionsByEventType.get(eventType);</code></li>\n<li>subscriptions如果已经被初始化了，那么按照优先级将新的method插入其中，如果没有初始化，那么就<code>new CopyOnWriteArrayList&lt;&gt;();</code></li>\n<li>获取订阅者所有的订阅事件类型 ： <code>typesBySubscriber.get(subscriber);</code></li>\n<li>如果初始化了，那么就直接添加这个<code>eventType</code>到对应的集合中，如果没有那么初始化并将<strong><code>Subscriber</code>（还记得参数传入的就是这个吗）</strong>作为key，<strong><code>eventType</code>集合</strong>作为value</li>\n</ul>\n<p><strong>不太明白没关系，我们再接着往下看。。。</strong></p>\n<h3 id=\"事件发布\"><a href=\"#事件发布\" class=\"headerlink\" title=\"事件发布\"></a>事件发布</h3><p><code>EventBus.getDefault().post(new UpdateUIEvent());</code></p>\n<p>post：</p>\n<pre><code>/** Posts the given event to the event bus. */\npublic void post(Object event) {\n    PostingThreadState postingState = currentPostingThreadState.get();\n    List&lt;Object&gt; eventQueue = postingState.eventQueue;\n    // 将事件添加进当前线程的事件队列\n    eventQueue.add(event);\n     // 判断当前线程是否正在发布事件\n    if (!postingState.isPosting) {\n        postingState.isMainThread = isMainThread();\n        postingState.isPosting = true;\n        if (postingState.canceled) {\n            throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;);\n        }\n        try {\n            while (!eventQueue.isEmpty()) {\n                postSingleEvent(eventQueue.remove(0), postingState);\n            }\n        } finally {\n            postingState.isPosting = false;\n            postingState.isMainThread = false;\n        }\n    }\n}\n\n</code></pre><p>首先<code>currentPostingThreadState</code>是一个<code>ThreadLocal&lt;PostingThreadState&gt;</code></p>\n<p>ThreadLocal 是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，而这段数据是不会与其他线程共享的。可以看出currentPostingThreadState的实现是一个包含了PostingThreadState的ThreadLocal对象,这样可以保证取到的都是自己线程对应的数据。</p>\n<pre><code>/** For ThreadLocal, much faster to set (and get multiple values). */\nfinal static class PostingThreadState {\n    final List&lt;Object&gt; eventQueue = new ArrayList&lt;&gt;();//当前线程的事件队列\n    boolean isPosting; //是否有事件正在分发\n    boolean isMainThread;//post的线程是否是主线程\n    Subscription subscription;\n    Object event;\n    boolean canceled;\n}\n</code></pre><p>PostingThreadState中包含了当前线程的事件队列，就是当前线程所有分发的事件都保存在eventQueue事件队列中以及订阅者订阅事件等信息，有了这些信息我们就可以从事件队列中取出事件分发给对应的订阅者。</p>\n<p>我们看到了把当前的事件加入到了事件队列尾部，如果事件队列不为empty，那么就一直发送里面的事件直到为empty。我们看一下关键代码<code>postSingleEvent(eventQueue.remove(0), postingState);</code>  </p>\n<pre><code>private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {\n    Class&lt;?&gt; eventClass = event.getClass();\n    boolean subscriptionFound = false;\n    if (eventInheritance) {\n        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);\n        int countTypes = eventTypes.size();\n        for (int h = 0; h &lt; countTypes; h++) {\n            Class&lt;?&gt; clazz = eventTypes.get(h);\n            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);\n        }\n    } else {\n        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);\n    }\n    if (!subscriptionFound) {\n        if (logNoSubscriberMessages) {\n            logger.log(Level.FINE, &quot;No subscribers registered for event &quot; + eventClass);\n        }\n        if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;\n                eventClass != SubscriberExceptionEvent.class) {\n            post(new NoSubscriberEvent(this, event));\n        }\n    }\n}\n</code></pre><p>首先判断的是<code>eventInheritance</code>是否开启了继承，由于EventBus创建的是默认的Builder，所以默认值为初始值true。那么会找到它所有的父类，然后依次发送事件。关键在于方法<strong><code>postSingleEventForEventType(event, postingState, eventClass);</code></strong>  </p>\n<pre><code>private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) {\n    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;\n    synchronized (this) {\n        // 根据事件类型找出相关的订阅信息\n        subscriptions = subscriptionsByEventType.get(eventClass);\n    }\n    if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) {\n        for (Subscription subscription : subscriptions) {\n            postingState.event = event;\n            postingState.subscription = subscription;\n            boolean aborted = false;\n            try {\n                // 发布到具体的订阅者\n                postToSubscription(subscription, event, postingState.isMainThread);\n                aborted = postingState.canceled;\n            } finally {\n                postingState.event = null;\n                postingState.subscription = null;\n                postingState.canceled = false;\n            }\n            if (aborted) {\n                break;\n            }\n        }\n        return true;\n    }\n    return false;\n}\n</code></pre><p>我们可以看到，如果根据事件类型找不到订阅方法，或者订阅方法为空，那么会返回false，上面抛出异常<code>No subscribers registered for event</code>。那如果找到了订阅的方法呢。</p>\n<pre><code>private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {\n    switch (subscription.subscriberMethod.threadMode) {\n        // 订阅线程跟随发布线程\n        case POSTING:\n            // 订阅线程和发布线程相同，直接订阅\n            invokeSubscriber(subscription, event);\n            break;\n        // 订阅线程为主线程\n        case MAIN:\n            // 发布线程和订阅线程都是主线程，直接订阅\n            if (isMainThread) {\n                invokeSubscriber(subscription, event);\n            }\n            // 发布线程不是主线程，订阅线程切换到主线程订阅\n            else {\n                mainThreadPoster.enqueue(subscription, event);\n            }\n            break;\n        case MAIN_ORDERED:\n            if (mainThreadPoster != null) {\n                mainThreadPoster.enqueue(subscription, event);\n            }\n            else {\n                // temporary: technically not correct as poster not decoupled from subscriber\n                invokeSubscriber(subscription, event);\n            }\n            break;\n        // 订阅线程为后台线程\n        case BACKGROUND:\n            // 发布线程为主线程，切换到后台线程订阅\n            if (isMainThread) {\n                backgroundPoster.enqueue(subscription, event);\n            }\n            // 发布线程不为主线程，直接订阅\n            else {\n                invokeSubscriber(subscription, event);\n            }\n            break;\n        // 订阅线程为异步线程\n        case ASYNC:\n            // 使用线程池线程订阅\n            asyncPoster.enqueue(subscription, event);\n            break;\n        default:\n            throw new IllegalStateException(&quot;Unknown thread mode: &quot; + subscription.subscriberMethod.threadMode);\n    }\n}\n</code></pre><ul>\n<li>POSTING：事件发布在什么线程，就在什么线程订阅。</li>\n<li>MAIN：无论事件在什么线程发布，都在主线程订阅。</li>\n<li>BACKGROUND：如果发布的线程不是主线程，则在该线程订阅，如果是主线程，则使用一个单独的后台线程订阅。</li>\n<li>ASYNC：在非主线程和发布线程中订阅。</li>\n</ul>\n<p>我们知道了根据不同类型进行区分。那么关键是如何调用Subscribe方法的呢？<br><code>invokeSubscriber(subscription, event);</code></p>\n<pre><code>void invokeSubscriber(Subscription subscription, Object event) {\n    try {\n        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);\n    } catch (InvocationTargetException e) {\n        handleSubscriberException(subscription, event, e.getCause());\n    } catch (IllegalAccessException e) {\n        throw new IllegalStateException(&quot;Unexpected exception&quot;, e);\n    }\n}\n\n</code></pre><p>这样订阅者收到了时间，调用了订阅方法。event参数也成功传入。</p>\n<h3 id=\"反注册\"><a href=\"#反注册\" class=\"headerlink\" title=\"反注册\"></a>反注册</h3><pre><code>/** Unregisters the given subscriber from all event classes. */\npublic synchronized void unregister(Object subscriber) {\n    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);\n    if (subscribedTypes != null) {\n        for (Class&lt;?&gt; eventType : subscribedTypes) {\n            unsubscribeByEventType(subscriber, eventType);\n        }\n        typesBySubscriber.remove(subscriber);\n    } else {\n        logger.log(Level.WARNING, &quot;Subscriber to unregister was not registered before: &quot; + subscriber.getClass());\n    }\n}\n\n</code></pre><p>我们在注册的时候知道 <strong><code>typesBySubscriber</code></strong>是一个存储订阅者，订阅事件的Map<br><code>private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</code>。<br>先解绑list中的元素再讲Subscribe也从map中移除。我们看关键代码<code>unsubscribeByEventType(subscriber, eventType);</code> </p>\n<pre><code>/** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */\nprivate void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) {\n    List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);\n    if (subscriptions != null) {\n        int size = subscriptions.size();\n        for (int i = 0; i &lt; size; i++) {\n            Subscription subscription = subscriptions.get(i);\n            if (subscription.subscriber == subscriber) {\n                subscription.active = false;\n                subscriptions.remove(i);\n                i--;\n                size--;\n            }\n        }\n    }\n}\n\n</code></pre><p>多看几遍源码就OK了。 (●ﾟωﾟ●)，接下来尝试着自己写一个简版的EventBus<br><a href=\"https://o0o0oo00.github.io/2018/10/09/Observer/#more\">观察者模式</a></p>\n<p>参考链接：</p>\n<ul>\n<li><a href=\"https://juejin.im/post/5a3e19c26fb9a0452207b6b5\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/5a3e19c26fb9a0452207b6b5</a></li>\n<li><a href=\"https://juejin.im/post/58f5c86a8d6d810057c12975\" target=\"_blank\" rel=\"noopener\">https://juejin.im/post/58f5c86a8d6d810057c12975</a></li>\n</ul>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjsogf10300015l26ub8sahek","category_id":"cjsogf10700035l26hzmll07i","_id":"cjsogf10k000e5l26k0hxe73s"},{"post_id":"cjsogf10500025l26dj0b4d3y","category_id":"cjsogf10700035l26hzmll07i","_id":"cjsogf10q000j5l261ew0hkp9"},{"post_id":"cjsogf10l000h5l26thn3rp5u","category_id":"cjsogf10700035l26hzmll07i","_id":"cjsogf10v000p5l26tlw2c17h"},{"post_id":"cjsogf10a00055l265nh7sie1","category_id":"cjsogf10k000d5l26zhhho7x3","_id":"cjsogf10x000t5l26jruoahnm"},{"post_id":"cjsogf10p000i5l26x5v5byut","category_id":"cjsogf10k000d5l26zhhho7x3","_id":"cjsogf10x000v5l26grrg7z7l"},{"post_id":"cjsogf10s000m5l26abkmp14f","category_id":"cjsogf10k000d5l26zhhho7x3","_id":"cjsogf10y000x5l26wkzou6h9"},{"post_id":"cjsogf10h000b5l26zu0zmzyw","category_id":"cjsogf10k000d5l26zhhho7x3","_id":"cjsogf10y000z5l26xq27i5ph"},{"post_id":"cjsogf10v000o5l26b7381v5o","category_id":"cjsogf10k000d5l26zhhho7x3","_id":"cjsogf10y00105l26s9fxsi41"},{"post_id":"cjsogf10j000c5l26eg054d1m","category_id":"cjsogf10k000d5l26zhhho7x3","_id":"cjsogf10z00135l266sb1j4ik"},{"post_id":"cjsogf11s00155l261uw1u0af","category_id":"cjsogf10k000d5l26zhhho7x3","_id":"cjsogf11x001e5l260lg0nrgt"},{"post_id":"cjsogf11t00175l26pzkoqtj1","category_id":"cjsogf10k000d5l26zhhho7x3","_id":"cjsogf11z001i5l26ct178nl4"},{"post_id":"cjsogf11v001a5l26l6e2nct8","category_id":"cjsogf10k000d5l26zhhho7x3","_id":"cjsogf120001l5l263n74nhro"},{"post_id":"cjsogf11w001d5l2692nwlzbs","category_id":"cjsogf10k000d5l26zhhho7x3","_id":"cjsogf121001p5l2622tbr7yq"},{"post_id":"cjsogf11z001k5l26o5me9etn","category_id":"cjsogf10k000d5l26zhhho7x3","_id":"cjsogf126001u5l26ir240khe"},{"post_id":"cjsogf121001o5l26ez8ggwk6","category_id":"cjsogf10k000d5l26zhhho7x3","_id":"cjsogf128001x5l26fai6d2aj"},{"post_id":"cjsogf122001r5l26u0fshvhw","category_id":"cjsogf10k000d5l26zhhho7x3","_id":"cjsogf12900215l26ufy7cava"},{"post_id":"cjsogf11y001h5l26xbq88nlf","category_id":"cjsogf120001m5l26ay2wwaxe","_id":"cjsogf12a00245l26fy2btm88"},{"post_id":"cjsogf126001t5l26acl13qlz","category_id":"cjsogf10k000d5l26zhhho7x3","_id":"cjsogf12b00265l26hzxbzybu"},{"post_id":"cjsogf127001w5l266q3plqkg","category_id":"cjsogf10k000d5l26zhhho7x3","_id":"cjsogf12d002a5l26nyeki86g"},{"post_id":"cjsogf12b00255l26o7sy25l9","category_id":"cjsogf10700035l26hzmll07i","_id":"cjsogf12e002e5l268098xiu6"},{"post_id":"cjsogf12c00295l262lo867ng","category_id":"cjsogf10700035l26hzmll07i","_id":"cjsogf12f002g5l26e14agext"},{"post_id":"cjsogf12d002c5l26y90f6byq","category_id":"cjsogf10700035l26hzmll07i","_id":"cjsogf12f002i5l266f2drefn"},{"post_id":"cjsogf12p002j5l26qi70wu7m","category_id":"cjsogf10k000d5l26zhhho7x3","_id":"cjsogf12s002n5l26i0k0hwwt"},{"post_id":"cjsogf12q002k5l26mm66ei3n","category_id":"cjsogf10k000d5l26zhhho7x3","_id":"cjsogf12s002o5l2644k7us2x"},{"post_id":"cjsogf13t002p5l26ym4j101z","category_id":"cjsogf10k000d5l26zhhho7x3","_id":"cjsogf13v002r5l26x8r88asd"}],"PostTag":[{"post_id":"cjsogf10300015l26ub8sahek","tag_id":"cjsogf10900045l260guvrvm3","_id":"cjsogf10h000a5l26myesgcxl"},{"post_id":"cjsogf10500025l26dj0b4d3y","tag_id":"cjsogf10900045l260guvrvm3","_id":"cjsogf10l000g5l2686hgxym8"},{"post_id":"cjsogf10a00055l265nh7sie1","tag_id":"cjsogf10k000f5l26dnfn5pf9","_id":"cjsogf10u000n5l2643r562mz"},{"post_id":"cjsogf10s000m5l26abkmp14f","tag_id":"cjsogf10k000f5l26dnfn5pf9","_id":"cjsogf10w000s5l26w4wng9uq"},{"post_id":"cjsogf10h000b5l26zu0zmzyw","tag_id":"cjsogf10q000l5l26jxyepg8w","_id":"cjsogf10x000u5l2669npexrv"},{"post_id":"cjsogf10j000c5l26eg054d1m","tag_id":"cjsogf10w000r5l26y2oeabbs","_id":"cjsogf10y000y5l26tuc4g46d"},{"post_id":"cjsogf10p000i5l26x5v5byut","tag_id":"cjsogf10y000w5l264ltagtci","_id":"cjsogf10z00125l26wrnatj9x"},{"post_id":"cjsogf10v000o5l26b7381v5o","tag_id":"cjsogf10y00115l26jniuhlqs","_id":"cjsogf10z00145l264d2djll1"},{"post_id":"cjsogf11s00155l261uw1u0af","tag_id":"cjsogf10k000f5l26dnfn5pf9","_id":"cjsogf11u00195l2675yu7f0q"},{"post_id":"cjsogf11t00175l26pzkoqtj1","tag_id":"cjsogf10q000l5l26jxyepg8w","_id":"cjsogf11w001c5l26qmosniet"},{"post_id":"cjsogf11v001a5l26l6e2nct8","tag_id":"cjsogf10y000w5l264ltagtci","_id":"cjsogf11y001g5l266g5s1m06"},{"post_id":"cjsogf11w001d5l2692nwlzbs","tag_id":"cjsogf10w000r5l26y2oeabbs","_id":"cjsogf11z001j5l26xd4sxakj"},{"post_id":"cjsogf11z001k5l26o5me9etn","tag_id":"cjsogf10w000r5l26y2oeabbs","_id":"cjsogf122001q5l26t3aksj4t"},{"post_id":"cjsogf121001o5l26ez8ggwk6","tag_id":"cjsogf10q000l5l26jxyepg8w","_id":"cjsogf125001s5l26jeb0bgcz"},{"post_id":"cjsogf122001r5l26u0fshvhw","tag_id":"cjsogf10k000f5l26dnfn5pf9","_id":"cjsogf127001v5l26hiyjzqao"},{"post_id":"cjsogf11y001h5l26xbq88nlf","tag_id":"cjsogf120001n5l268zm6mv8q","_id":"cjsogf128001z5l26t0n4btcy"},{"post_id":"cjsogf127001w5l266q3plqkg","tag_id":"cjsogf10w000r5l26y2oeabbs","_id":"cjsogf12a00225l26eh6ejbaq"},{"post_id":"cjsogf126001t5l26acl13qlz","tag_id":"cjsogf128001y5l26kihiieuk","_id":"cjsogf12c00285l261dc1b5qe"},{"post_id":"cjsogf12b00255l26o7sy25l9","tag_id":"cjsogf10900045l260guvrvm3","_id":"cjsogf12d002b5l26su3wrjey"},{"post_id":"cjsogf12c00295l262lo867ng","tag_id":"cjsogf10900045l260guvrvm3","_id":"cjsogf12e002d5l26twy5s3bg"},{"post_id":"cjsogf12d002c5l26y90f6byq","tag_id":"cjsogf10900045l260guvrvm3","_id":"cjsogf12f002f5l26il711vl8"},{"post_id":"cjsogf12a00235l26fibx0bto","tag_id":"cjsogf12c00275l26qeh0lu65","_id":"cjsogf12f002h5l26wqh58poa"},{"post_id":"cjsogf12p002j5l26qi70wu7m","tag_id":"cjsogf10w000r5l26y2oeabbs","_id":"cjsogf12r002l5l26wl999j35"},{"post_id":"cjsogf12q002k5l26mm66ei3n","tag_id":"cjsogf128001y5l26kihiieuk","_id":"cjsogf12s002m5l26jfg7uafg"},{"post_id":"cjsogf13t002p5l26ym4j101z","tag_id":"cjsogf10k000f5l26dnfn5pf9","_id":"cjsogf13u002q5l26dz3qu3aq"}],"Tag":[{"name":"diary","_id":"cjsogf10900045l260guvrvm3"},{"name":"android","_id":"cjsogf10k000f5l26dnfn5pf9"},{"name":"jetpack","_id":"cjsogf10q000l5l26jxyepg8w"},{"name":"kotlin","_id":"cjsogf10w000r5l26y2oeabbs"},{"name":"alert","_id":"cjsogf10y000w5l264ltagtci"},{"name":"dagger","_id":"cjsogf10y00115l26jniuhlqs"},{"name":"hexo","_id":"cjsogf120001n5l268zm6mv8q"},{"name":"技术","_id":"cjsogf128001y5l26kihiieuk"},{"name":"FAMOUS QUOTATION","_id":"cjsogf12c00275l26qeh0lu65"}]}}